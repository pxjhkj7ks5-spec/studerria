const express = require('express');
const http = require('http');
const session = require('express-session');
const PgSession = require('connect-pg-simple')(session);
const path = require('path');
const fs = require('fs');
const { randomUUID, createHash } = require('crypto');
const multer = require('multer');
const { Pool } = require('pg');
const { WebSocketServer } = require('ws');
const bcrypt = require('bcryptjs');
const pkg = require('./package.json');
const versionFile = path.join(__dirname, 'version.json');
const changelogFile = path.join(__dirname, 'changelog.json');
let appVersion = pkg.version || '0.0.0';
try {
  const raw = fs.readFileSync(versionFile, 'utf8');
  const parsed = JSON.parse(raw);
  if (parsed && typeof parsed.version === 'string') {
    appVersion = parsed.version;
  }
} catch (err) {
  // keep package.json version as fallback
}
let appChangelog = [];
try {
  const raw = fs.readFileSync(changelogFile, 'utf8');
  const parsed = JSON.parse(raw);
  if (parsed && Array.isArray(parsed.items)) {
    appChangelog = parsed.items;
  }
} catch (err) {
  appChangelog = [];
}
const buildStamp = new Date().toISOString();
const SYSTEM_HEALTH_ERROR_EVENT_LIMIT = 400;
const SYSTEM_HEALTH_ERROR_WINDOW_HOURS = 24;
const SYSTEM_INCIDENT_WINDOW_HOURS = 72;
const SYSTEM_INCIDENT_OPEN_HOURS = 2;
const SYSTEM_INCIDENT_ITEM_LIMIT = 25;
const runtimeErrorEvents = [];
const schedulerHealthState = {
  enabled: false,
  interval_ms: null,
  running: false,
  run_count: 0,
  skipped_count: 0,
  error_count: 0,
  last_started_at: null,
  last_run_at: null,
  last_duration_ms: null,
  last_result: null,
  last_error_at: null,
  last_error: null,
};

function normalizeRuntimeErrorMessage(rawError) {
  const normalized = String(rawError || '')
    .replace(/\s+/g, ' ')
    .trim();
  if (normalized.length <= 220) return normalized;
  return `${normalized.slice(0, 217)}...`;
}

function pushRuntimeErrorEvent(kind, label, rawError, extra = {}) {
  const event = {
    created_at: new Date().toISOString(),
    kind: String(kind || 'unknown').trim().toLowerCase() || 'unknown',
    label: String(label || 'unknown').trim() || 'unknown',
    message: normalizeRuntimeErrorMessage(rawError),
    ...extra,
  };
  runtimeErrorEvents.push(event);
  if (runtimeErrorEvents.length > SYSTEM_HEALTH_ERROR_EVENT_LIMIT) {
    runtimeErrorEvents.splice(0, runtimeErrorEvents.length - SYSTEM_HEALTH_ERROR_EVENT_LIMIT);
  }
  return event;
}

function clearRuntimeErrorEvents(predicate) {
  if (typeof predicate !== 'function') return 0;
  let removed = 0;
  for (let idx = runtimeErrorEvents.length - 1; idx >= 0; idx -= 1) {
    const item = runtimeErrorEvents[idx];
    if (!predicate(item)) continue;
    runtimeErrorEvents.splice(idx, 1);
    removed += 1;
  }
  return removed;
}

function getRuntimeErrorSummary(now = Date.now()) {
  const windowMs = SYSTEM_HEALTH_ERROR_WINDOW_HOURS * 60 * 60 * 1000;
  const cutoff = now - windowMs;
  const recent = runtimeErrorEvents
    .filter((event) => {
      const ts = new Date(event.created_at).getTime();
      return Number.isFinite(ts) && ts >= cutoff;
    })
    .sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime());
  const byKind = {
    db: 0,
    scheduler: 0,
    unhandled: 0,
    session: 0,
    security: 0,
    unknown: 0,
  };
  const topLabelMap = new Map();
  recent.forEach((event) => {
    const kind = Object.prototype.hasOwnProperty.call(byKind, event.kind) ? event.kind : 'unknown';
    byKind[kind] += 1;
    const labelKey = `${kind}::${event.label}`;
    if (!topLabelMap.has(labelKey)) {
      topLabelMap.set(labelKey, { kind, label: event.label, count: 0 });
    }
    topLabelMap.get(labelKey).count += 1;
  });
  const topLabels = Array.from(topLabelMap.values())
    .sort((a, b) => {
      if (Number(b.count || 0) !== Number(a.count || 0)) {
        return Number(b.count || 0) - Number(a.count || 0);
      }
      return String(a.label || '').localeCompare(String(b.label || ''));
    })
    .slice(0, 8);
  return {
    window_hours: SYSTEM_HEALTH_ERROR_WINDOW_HOURS,
    total: recent.length,
    by_kind: byKind,
    top_labels: topLabels,
    recent: recent.slice(0, 20),
  };
}

function resolveIncidentSeverity(kindRaw) {
  const kind = String(kindRaw || '').trim().toLowerCase();
  if (kind === 'unhandled') return 'critical';
  if (kind === 'session' || kind === 'scheduler' || kind === 'security') return 'high';
  if (kind === 'db') return 'medium';
  return 'low';
}

function buildIncidentFeed(now = Date.now()) {
  const windowMs = SYSTEM_INCIDENT_WINDOW_HOURS * 60 * 60 * 1000;
  const cutoff = now - windowMs;
  const recent = runtimeErrorEvents
    .filter((event) => {
      const ts = new Date(event.created_at).getTime();
      return Number.isFinite(ts) && ts >= cutoff;
    })
    .sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime());
  const grouped = new Map();
  recent.forEach((event) => {
    const kind = String(event.kind || 'unknown');
    const label = String(event.label || 'unknown');
    const message = String(event.message || '');
    const signature = `${kind}::${label}::${message}`;
    const severity = resolveIncidentSeverity(kind);
    if (!grouped.has(signature)) {
      grouped.set(signature, {
        signature,
        kind,
        label,
        message,
        severity,
        first_seen_at: event.created_at,
        last_seen_at: event.created_at,
        count: 0,
      });
    }
    const row = grouped.get(signature);
    row.count += 1;
    if (new Date(event.created_at).getTime() < new Date(row.first_seen_at).getTime()) {
      row.first_seen_at = event.created_at;
    }
    if (new Date(event.created_at).getTime() > new Date(row.last_seen_at).getTime()) {
      row.last_seen_at = event.created_at;
    }
  });
  const severityRank = { critical: 4, high: 3, medium: 2, low: 1 };
  const items = Array.from(grouped.values())
    .sort((a, b) => {
      const aRank = Number(severityRank[a.severity] || 0);
      const bRank = Number(severityRank[b.severity] || 0);
      if (aRank !== bRank) return bRank - aRank;
      const aSeen = new Date(a.last_seen_at).getTime();
      const bSeen = new Date(b.last_seen_at).getTime();
      if (aSeen !== bSeen) return bSeen - aSeen;
      return Number(b.count || 0) - Number(a.count || 0);
    })
    .slice(0, SYSTEM_INCIDENT_ITEM_LIMIT);
  const bySeverity = {
    critical: 0,
    high: 0,
    medium: 0,
    low: 0,
  };
  items.forEach((item) => {
    if (!Object.prototype.hasOwnProperty.call(bySeverity, item.severity)) return;
    bySeverity[item.severity] += 1;
  });
  const openCutoff = now - (SYSTEM_INCIDENT_OPEN_HOURS * 60 * 60 * 1000);
  const openCount = items.filter((item) => {
    const ts = new Date(item.last_seen_at).getTime();
    if (!Number.isFinite(ts) || ts < openCutoff) return false;
    return item.severity === 'critical' || item.severity === 'high';
  }).length;
  return {
    window_hours: SYSTEM_INCIDENT_WINDOW_HOURS,
    total_events: recent.length,
    unique_incidents: grouped.size,
    open_incidents: openCount,
    by_severity: bySeverity,
    items,
  };
}

const localesDir = path.join(__dirname, 'locales');
const locales = {};
['en', 'uk'].forEach((code) => {
  try {
    const raw = fs.readFileSync(path.join(localesDir, `${code}.json`), 'utf8');
    locales[code] = JSON.parse(raw);
  } catch (err) {
    locales[code] = {};
  }
});

const getPreferredLang = (req) => {
  const queryLang = typeof req.query.lang === 'string' ? req.query.lang.toLowerCase() : '';
  if (queryLang && locales[queryLang]) {
    req.session.lang = queryLang;
    return queryLang;
  }
  if (req.session && req.session.user && req.session.user.language && locales[req.session.user.language]) {
    return req.session.user.language;
  }
  if (req.session && req.session.lang && locales[req.session.lang]) {
    return req.session.lang;
  }
  const header = req.headers['accept-language'];
  if (typeof header === 'string' && header.length) {
    const preferred = header.split(',')[0].trim().slice(0, 2).toLowerCase();
    if (locales[preferred]) return preferred;
  }
  return locales.uk ? 'uk' : 'en';
};

const translate = (lang, key) => {
  if (!key) return '';
  const dict = locales[lang] || {};
  if (dict && Object.prototype.hasOwnProperty.call(dict, key)) {
    return dict[key];
  }
  const fallback = locales.en || {};
  if (fallback && Object.prototype.hasOwnProperty.call(fallback, key)) {
    return fallback[key];
  }
  return key;
};

const app = express();
const PORT = Number(process.env.PORT) || 3000;
const server = http.createServer(app);
const wss = new WebSocketServer({ server });

process.on('uncaughtException', (err) => {
  pushRuntimeErrorEvent('unhandled', 'uncaughtException', err && err.message ? err.message : err);
  console.error('Uncaught exception:', err);
});

process.on('unhandledRejection', (err) => {
  pushRuntimeErrorEvent('unhandled', 'unhandledRejection', err && err.message ? err.message : err);
  console.error('Unhandled rejection:', err);
});

const adminSeed = process.env.ADMIN_HASHED_PASS
  ? {
      full_name: process.env.ADMIN_NAME || 'Марченко Андрій Юрійович',
      role: 'admin',
      password_hash: process.env.ADMIN_HASHED_PASS,
    }
  : null;

const userSeed = adminSeed ? [adminSeed] : [];

const ADMIN_SECTION_OPTIONS = [
  { id: 'admin-overview', label: 'Огляд' },
  { id: 'admin-settings', label: 'Налаштування' },
  { id: 'admin-role-access', label: 'Role Studio' },
  { id: 'admin-visit-analytics', label: 'Security analytics' },
  { id: 'admin-students', label: 'Students' },
  { id: 'admin-schedule', label: 'Розклад' },
  { id: 'admin-import-export', label: 'Імпорт/Експорт' },
  { id: 'admin-schedule-generator', label: 'Генератор' },
  { id: 'admin-homework', label: 'Домашні' },
  { id: 'admin-users', label: 'Користувачі' },
  { id: 'admin-teachers', label: 'Заявки викладачів' },
  { id: 'admin-subjects', label: 'Предмети' },
  { id: 'admin-semesters', label: 'Семестри' },
  { id: 'admin-courses', label: 'Курси' },
  { id: 'admin-history', label: 'Історія' },
  { id: 'admin-activity', label: 'Активність' },
  { id: 'admin-teamwork', label: 'Командна робота' },
  { id: 'admin-messages', label: 'Повідомлення' },
];

const DEFAULT_ROLE_PERMISSIONS = {
  starosta: ['admin-homework', 'admin-teamwork', 'admin-messages', 'admin-overview'],
  deanery: ['admin-schedule', 'admin-subjects', 'admin-semesters', 'admin-courses', 'admin-students', 'admin-overview'],
  teacher: [],
  student: [],
};

const LEGACY_SESSION_ROLES = new Set(['admin', 'teacher', 'deanery', 'starosta', 'student']);
const ROLE_KEY_ALIASES = {
  admin: 'admin',
  administrator: 'admin',
  адмін: 'admin',
  администратор: 'admin',
  starosta: 'starosta',
  староста: 'starosta',
  deanery: 'deanery',
  деканат: 'deanery',
  teacher: 'teacher',
  викладач: 'teacher',
  student: 'student',
  студент: 'student',
};

const ADMIN_SECTION_PERMISSION_OPTIONS = ADMIN_SECTION_OPTIONS.map((section) => ({
  key: section.id,
  label: section.label,
  category: 'admin_section',
}));

const JOURNAL_PERMISSION_OPTIONS = [
  { key: 'journal-own', label: 'Журнал: свій доступ', category: 'feature' },
  { key: 'journal-full', label: 'Журнал: повний доступ', category: 'feature' },
];

const RBAC_PERMISSION_OPTIONS = [
  ...ADMIN_SECTION_PERMISSION_OPTIONS,
  ...JOURNAL_PERMISSION_OPTIONS,
];

const JOURNAL_OWN_PERMISSION = 'journal-own';
const JOURNAL_FULL_PERMISSION = 'journal-full';
const REVIEW_QUEUE_OVERDUE_HOURS = 48;
const REVIEW_QUEUE_ITEM_LIMIT = 120;
const HOMEWORK_REVIEW_SLA_SUBJECT_LIMIT = 8;
const REVIEW_QUEUE_FEEDBACK_TEMPLATES = [
  {
    key: 'strong',
    label: 'Сильна робота',
    text: 'Сильна робота: чітка структура, аргументи і висновок. Так тримати.',
  },
  {
    key: 'argumentation',
    label: 'Посилити аргументи',
    text: 'Добрий старт, але потрібно посилити аргументацію фактами та прикладами.',
  },
  {
    key: 'clarity',
    label: 'Більше конкретики',
    text: 'Потрібно більше конкретики: додай чіткі тези, приклади і короткий висновок.',
  },
  {
    key: 'revision',
    label: 'Потрібне доопрацювання',
    text: 'Робота потребує доопрацювання за критеріями предмета. Після правок можна перездати.',
  },
];
const STUDENT_RISK_ADMISSION_TARGET = 60;
const STUDENT_RISK_ON_TIME_WARNING_PERCENT = 65;

const COURSE_KIND_OPTIONS = [
  { key: 'regular', label: 'Regular courses' },
  { key: 'teacher', label: 'Teacher courses' },
];

const SETTINGS_RETENTION_MIN_DAYS = 14;
const SETTINGS_RETENTION_MAX_DAYS = 3650;
const SECURITY_REGISTRATION_ALERT_THRESHOLD_MIN = 2;
const SECURITY_REGISTRATION_ALERT_THRESHOLD_MAX = 20;
const SECURITY_REGISTRATION_ALERT_WINDOW_MINUTES_MIN = 15;
const SECURITY_REGISTRATION_ALERT_WINDOW_MINUTES_MAX = 1440;
const SECURITY_ADMIN_IP_ALLOWLIST_LIMIT = 120;
const SECURITY_ADMIN_IP_RULE_MAX_LENGTH = 64;

function normalizeRetentionDays(rawValue, fallbackDays) {
  const parsed = Number(rawValue);
  if (!Number.isFinite(parsed)) return fallbackDays;
  const rounded = Math.floor(parsed);
  if (rounded < SETTINGS_RETENTION_MIN_DAYS) return fallbackDays;
  if (rounded > SETTINGS_RETENTION_MAX_DAYS) return SETTINGS_RETENTION_MAX_DAYS;
  return rounded;
}

const SITE_VISIT_RETENTION_DAYS_DEFAULT = normalizeRetentionDays(
  process.env.SITE_VISIT_RETENTION_DAYS,
  120
);
const LOGIN_HISTORY_RETENTION_DAYS_DEFAULT = normalizeRetentionDays(
  process.env.LOGIN_HISTORY_RETENTION_DAYS,
  180
);
const ACTIVITY_LOG_RETENTION_DAYS_DEFAULT = normalizeRetentionDays(
  process.env.ACTIVITY_LOG_RETENTION_DAYS,
  365
);
const SECURITY_IP_RETENTION_DAYS_DEFAULT = normalizeRetentionDays(
  process.env.SECURITY_IP_RETENTION_DAYS,
  180
);
const SECURITY_USER_AGENT_RETENTION_DAYS_DEFAULT = normalizeRetentionDays(
  process.env.SECURITY_USER_AGENT_RETENTION_DAYS,
  120
);

const DEFAULT_SETTINGS = {
  session_duration_days: 14,
  max_file_size_mb: 20,
  allow_homework_creation: true,
  min_team_members: 2,
  allow_custom_deadlines: true,
  myday_show_student_homework: true,
  allow_messages: true,
  schedule_refresh_minutes: 5,
  site_visit_retention_days: SITE_VISIT_RETENTION_DAYS_DEFAULT,
  login_history_retention_days: LOGIN_HISTORY_RETENTION_DAYS_DEFAULT,
  activity_log_retention_days: ACTIVITY_LOG_RETENTION_DAYS_DEFAULT,
  security_admin_ip_allowlist: '',
  security_registration_alert_threshold: 3,
  security_registration_alert_window_minutes: 120,
  security_auto_quarantine_enabled: true,
  security_ip_retention_days: SECURITY_IP_RETENTION_DAYS_DEFAULT,
  security_user_agent_retention_days: SECURITY_USER_AGENT_RETENTION_DAYS_DEFAULT,
  role_permissions: { ...DEFAULT_ROLE_PERMISSIONS },
};
let settingsCache = { ...DEFAULT_SETTINGS };
const SESSION_DAY_MS = 24 * 60 * 60 * 1000;
const ADMIN_AUDIT_SCOPE_SYSTEM_SETTINGS = 'system_settings';
const ADMIN_AUDIT_SCOPE_ROLE_STUDIO = 'role_studio';
const SYSTEM_SETTINGS_AUDIT_KEYS = [
  'session_duration_days',
  'max_file_size_mb',
  'allow_homework_creation',
  'min_team_members',
  'allow_custom_deadlines',
  'myday_show_student_homework',
  'allow_messages',
  'schedule_refresh_minutes',
  'site_visit_retention_days',
  'login_history_retention_days',
  'activity_log_retention_days',
  'security_admin_ip_allowlist',
  'security_registration_alert_threshold',
  'security_registration_alert_window_minutes',
  'security_auto_quarantine_enabled',
  'security_ip_retention_days',
  'security_user_agent_retention_days',
];

function resolveSessionTtlDays(rawDays) {
  const parsedDays = Number(rawDays);
  if (!Number.isFinite(parsedDays) || parsedDays < 1) {
    return DEFAULT_SETTINGS.session_duration_days;
  }
  return Math.floor(parsedDays);
}

function resolveSessionTtlMs(rawDays) {
  return resolveSessionTtlDays(rawDays) * SESSION_DAY_MS;
}

function isRememberRequested(rawValue) {
  if (typeof rawValue === 'undefined' || rawValue === null || rawValue === '') {
    return true;
  }
  if (rawValue === true) return true;
  const normalized = String(rawValue).trim().toLowerCase();
  return normalized === '1' || normalized === 'true' || normalized === 'on' || normalized === 'yes';
}

const bellSchedule = {
  1: { start: '08:30', end: '09:50' },
  2: { start: '10:00', end: '11:20' },
  3: { start: '11:40', end: '13:00' },
  4: { start: '13:30', end: '14:50' },
  5: { start: '15:00', end: '16:20' },
  6: { start: '16:30', end: '17:50' },
  7: { start: '18:00', end: '19:20' },
};

app.set('view engine', 'ejs');

app.use(express.urlencoded({ extended: true }));
app.use(express.json());
app.use(express.static('public'));
app.use('/uploads', express.static('uploads'));

const isProd = process.env.NODE_ENV === 'production';
app.set('trust proxy', 1);

const pool = new Pool({
  host: process.env.DB_HOST || `/cloudsql/${process.env.INSTANCE_CONNECTION_NAME}`,
  user: process.env.DB_USER,
  password: process.env.DB_PASS,
  database: process.env.DB_NAME,
  port: process.env.DB_PORT ? Number(process.env.DB_PORT) : 5432,
  ssl: process.env.DB_SSL === 'true' ? { rejectUnauthorized: false } : false,
});

const sessionSecret = process.env.SESSION_SECRET || 'dev-secret-change-me';
if (isProd && !process.env.SESSION_SECRET) {
  console.warn('SESSION_SECRET is not set in production; use a stable secret to avoid forced logouts.');
}
const sessionTableNameRaw = String(process.env.SESSION_TABLE_NAME || 'user_sessions').trim();
const sessionTableName = /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(sessionTableNameRaw)
  ? sessionTableNameRaw
  : 'user_sessions';
if (sessionTableName !== sessionTableNameRaw) {
  console.warn(`Invalid SESSION_TABLE_NAME "${sessionTableNameRaw}", fallback to "${sessionTableName}".`);
}
const pruneIntervalRaw = Number(process.env.SESSION_PRUNE_INTERVAL_SECONDS || 900);
const pruneIntervalSeconds = Number.isFinite(pruneIntervalRaw) && pruneIntervalRaw >= 60
  ? Math.floor(pruneIntervalRaw)
  : 900;
const sessionHealthProbeIntervalRaw = Number(process.env.SESSION_HEALTHCHECK_INTERVAL_SECONDS || 60);
const sessionHealthProbeIntervalSeconds = Number.isFinite(sessionHealthProbeIntervalRaw) && sessionHealthProbeIntervalRaw >= 15
  ? Math.floor(sessionHealthProbeIntervalRaw)
  : 60;
const sessionHealthProbeIntervalMs = sessionHealthProbeIntervalSeconds * 1000;

const normalizeSessionHealthError = (rawError) => {
  const normalized = String(rawError || '')
    .replace(/\s+/g, ' ')
    .trim();
  if (normalized.length <= 220) return normalized;
  return `${normalized.slice(0, 217)}...`;
};

const sessionHealthState = {
  ok: true,
  table: sessionTableName,
  lastCheckedAt: null,
  lastOkAt: null,
  lastErrorAt: null,
  lastError: null,
  checks: 0,
  failures: 0,
  lastDurationMs: null,
};

const logSessionHealth = (event, payload = {}) => {
  const record = {
    type: 'session_health',
    event,
    ...payload,
  };
  if (event === 'probe_failed' || event === 'store_error' || event === 'probe_crashed') {
    console.error('SESSION_HEALTH', JSON.stringify(record));
    return;
  }
  console.log('SESSION_HEALTH', JSON.stringify(record));
};

const probeSessionStoreHealth = async (reason = 'interval') => {
  const startedAt = Date.now();
  const wasOk = sessionHealthState.ok;
  try {
    await new Promise((resolve, reject) => {
      sessionStore.get('__healthcheck__', (err) => {
        if (err) return reject(err);
        return resolve();
      });
    });
    const nowIso = new Date().toISOString();
    const durationMs = Date.now() - startedAt;
    sessionHealthState.ok = true;
    sessionHealthState.lastCheckedAt = nowIso;
    sessionHealthState.lastOkAt = nowIso;
    sessionHealthState.lastDurationMs = durationMs;
    sessionHealthState.lastError = null;
    sessionHealthState.checks += 1;
    logSessionHealth(wasOk ? 'probe_ok' : 'probe_recovered', { reason, duration_ms: durationMs });
  } catch (err) {
    const nowIso = new Date().toISOString();
    const durationMs = Date.now() - startedAt;
    const message = normalizeSessionHealthError(err && err.message ? err.message : err);
    sessionHealthState.ok = false;
    sessionHealthState.lastCheckedAt = nowIso;
    sessionHealthState.lastErrorAt = nowIso;
    sessionHealthState.lastError = message;
    sessionHealthState.lastDurationMs = durationMs;
    sessionHealthState.checks += 1;
    sessionHealthState.failures += 1;
    pushRuntimeErrorEvent('session', `probe:${reason}`, message);
    logSessionHealth('probe_failed', { reason, duration_ms: durationMs, error: message });
  }
};

const sessionStore = new PgSession({
  pool,
  tableName: sessionTableName,
  createTableIfMissing: true,
  pruneSessionInterval: pruneIntervalSeconds,
  ttl: Math.floor(resolveSessionTtlMs(DEFAULT_SETTINGS.session_duration_days) / 1000),
  errorLog: (...args) => {
    const nowIso = new Date().toISOString();
    const message = normalizeSessionHealthError(args
      .map((item) => (item && item.message ? item.message : String(item)))
      .join(' | '));
    sessionHealthState.ok = false;
    sessionHealthState.lastCheckedAt = nowIso;
    sessionHealthState.lastErrorAt = nowIso;
    sessionHealthState.lastError = message;
    sessionHealthState.failures += 1;
    pushRuntimeErrorEvent('session', 'store_error', message);
    console.error('SESSION_STORE_ERROR', ...args);
    logSessionHealth('store_error', { error: message });
  },
});

app.use(
  session({
    name: process.env.SESSION_COOKIE_NAME || 'sid',
    store: sessionStore,
    secret: sessionSecret,
    resave: false,
    saveUninitialized: false,
    rolling: true,
    unset: 'destroy',
    cookie: {
      httpOnly: true,
      sameSite: 'lax',
      secure: isProd,
      maxAge: resolveSessionTtlMs(DEFAULT_SETTINGS.session_duration_days),
    },
  })
);

app.use((req, _res, next) => {
  if (req.session && req.session.cookie) {
    req.session.cookie.maxAge = resolveSessionTtlMs(settingsCache.session_duration_days);
  }
  return next();
});

app.use((req, res, next) => {
  const lang = getPreferredLang(req);
  res.locals.messages = {
    error: req.query && req.query.err ? req.query.err : '',
    success: req.query && req.query.ok ? req.query.ok : '',
    operationId: req.query && req.query.op ? req.query.op : '',
  };
  res.locals.appVersion = appVersion;
  res.locals.buildStamp = buildStamp;
  res.locals.authorName = 'Andrii Marchenko';
  res.locals.changelog = appChangelog;
  res.locals.settings = settingsCache;
  res.locals.lang = lang;
  res.locals.t = (key) => translate(lang, key);
  next();
});

const convertPlaceholders = (sql) => {
  let index = 0;
  return sql.replace(/\?/g, () => {
    index += 1;
    return `$${index}`;
  });
};

const normalizeArgs = (sql, params, cb) => {
  let finalParams = params;
  let callback = cb;
  if (typeof params === 'function') {
    callback = params;
    finalParams = [];
  }
  return { sql, params: finalParams || [], cb: callback };
};

const db = {
  async run(sql, params, cb) {
    const { params: finalParams, cb: callback } = normalizeArgs(sql, params, cb);
    const query = convertPlaceholders(sql);
    try {
      const result = await pool.query(query, finalParams);
      const lastID = result.rows && result.rows[0] ? result.rows[0].id : undefined;
      if (callback) {
        callback.call({ lastID }, null);
      }
      return { changes: result.rowCount, lastID };
    } catch (err) {
      if (callback) {
        callback(err);
        return { changes: 0 };
      }
      throw err;
    }
  },
  async get(sql, params, cb) {
    const { params: finalParams, cb: callback } = normalizeArgs(sql, params, cb);
    const query = convertPlaceholders(sql);
    try {
      const result = await pool.query(query, finalParams);
      const row = result.rows[0];
      if (callback) {
        callback(null, row);
      }
      return row;
    } catch (err) {
      if (callback) {
        callback(err);
        return undefined;
      }
      throw err;
    }
  },
  async all(sql, params, cb) {
    const { params: finalParams, cb: callback } = normalizeArgs(sql, params, cb);
    const query = convertPlaceholders(sql);
    try {
      const result = await pool.query(query, finalParams);
      if (callback) {
        callback(null, result.rows);
      }
      return result.rows;
    } catch (err) {
      if (callback) {
        callback(err, []);
        return [];
      }
      throw err;
    }
  },
  prepare(sql) {
    const pending = [];
    return {
      run: (...params) => {
        const promise = db.run(sql, params);
        pending.push(promise);
        return promise;
      },
      get: (...params) => db.get(sql, params),
      all: (...params) => db.all(sql, params),
      finalize: async (cb) => {
        try {
          await Promise.all(pending);
          if (cb) cb();
        } catch (err) {
          if (cb) cb(err);
        }
      },
    };
  },
};

const txRun = async (client, sql, params = []) => {
  const result = await client.query(convertPlaceholders(sql), params);
  const lastID = result.rows && result.rows[0] ? result.rows[0].id : undefined;
  return { changes: result.rowCount, lastID };
};

const withTransaction = async (work) => {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    const result = await work(client);
    await client.query('COMMIT');
    return result;
  } catch (err) {
    try {
      await client.query('ROLLBACK');
    } catch (_) {
      // ignore rollback errors and return original error
    }
    throw err;
  } finally {
    client.release();
  }
};

let usersHasIsActive = true;

const refreshSettingsCache = async () => {
  const settingsRows = await pool.query('SELECT key, value FROM settings');
  const parsed = { ...DEFAULT_SETTINGS };
  for (const row of settingsRows.rows) {
    if (!row || !row.key) continue;
    if (row.key === 'session_duration_days') {
      const n = Number(row.value);
      if (!Number.isNaN(n) && n > 0) parsed.session_duration_days = n;
    } else if (row.key === 'max_file_size_mb') {
      const n = Number(row.value);
      if (!Number.isNaN(n) && n > 0) parsed.max_file_size_mb = n;
    } else if (row.key === 'allow_homework_creation') {
      parsed.allow_homework_creation = String(row.value).toLowerCase() === 'true';
    } else if (row.key === 'min_team_members') {
      const n = Number(row.value);
      if (!Number.isNaN(n) && n > 0) parsed.min_team_members = n;
    } else if (row.key === 'allow_custom_deadlines') {
      parsed.allow_custom_deadlines = String(row.value).toLowerCase() === 'true';
    } else if (row.key === 'myday_show_student_homework') {
      parsed.myday_show_student_homework = String(row.value).toLowerCase() === 'true';
    } else if (row.key === 'allow_messages') {
      parsed.allow_messages = String(row.value).toLowerCase() === 'true';
    } else if (row.key === 'schedule_refresh_minutes') {
      const n = Number(row.value);
      if (!Number.isNaN(n) && n > 0) parsed.schedule_refresh_minutes = n;
    } else if (row.key === 'site_visit_retention_days') {
      parsed.site_visit_retention_days = normalizeRetentionDays(row.value, DEFAULT_SETTINGS.site_visit_retention_days);
    } else if (row.key === 'login_history_retention_days') {
      parsed.login_history_retention_days = normalizeRetentionDays(row.value, DEFAULT_SETTINGS.login_history_retention_days);
    } else if (row.key === 'activity_log_retention_days') {
      parsed.activity_log_retention_days = normalizeRetentionDays(row.value, DEFAULT_SETTINGS.activity_log_retention_days);
    } else if (row.key === 'security_admin_ip_allowlist') {
      parsed.security_admin_ip_allowlist = normalizeSecurityAdminIpAllowlist(row.value);
    } else if (row.key === 'security_registration_alert_threshold') {
      parsed.security_registration_alert_threshold = normalizeSecurityRegistrationAlertThreshold(
        row.value,
        DEFAULT_SETTINGS.security_registration_alert_threshold
      );
    } else if (row.key === 'security_registration_alert_window_minutes') {
      parsed.security_registration_alert_window_minutes = normalizeSecurityRegistrationAlertWindowMinutes(
        row.value,
        DEFAULT_SETTINGS.security_registration_alert_window_minutes
      );
    } else if (row.key === 'security_auto_quarantine_enabled') {
      parsed.security_auto_quarantine_enabled = String(row.value).toLowerCase() === 'true';
    } else if (row.key === 'security_ip_retention_days') {
      parsed.security_ip_retention_days = normalizeRetentionDays(
        row.value,
        DEFAULT_SETTINGS.security_ip_retention_days
      );
    } else if (row.key === 'security_user_agent_retention_days') {
      parsed.security_user_agent_retention_days = normalizeRetentionDays(
        row.value,
        DEFAULT_SETTINGS.security_user_agent_retention_days
      );
    } else if (row.key === 'role_permissions') {
      try {
        const raw = JSON.parse(row.value);
        if (raw && typeof raw === 'object') {
          const allowedIds = new Set(ADMIN_SECTION_OPTIONS.map((item) => item.id));
          const normalized = {};
          Object.keys(DEFAULT_ROLE_PERMISSIONS).forEach((role) => {
            if (!Object.prototype.hasOwnProperty.call(raw, role)) return;
            const input = raw[role];
            const list = Array.isArray(input)
              ? input
              : typeof input === 'string'
                ? [input]
                : [];
            normalized[role] = list
              .map((id) => String(id))
              .filter((id) => allowedIds.has(id));
          });
          const restrictedForStaff = new Set([
            'admin-settings',
            'admin-role-access',
            'admin-users',
            'admin-students',
            'admin-import-export',
            'admin-schedule-generator',
          ]);
          ['teacher', 'student'].forEach((role) => {
            if (!normalized[role]) return;
            normalized[role] = normalized[role].filter((id) => !restrictedForStaff.has(id));
          });
          parsed.role_permissions = {
            ...DEFAULT_ROLE_PERMISSIONS,
            ...normalized,
          };
        }
      } catch (err) {
        // ignore invalid role permissions payload
      }
    }
  }
  settingsCache = parsed;
};

function normalizeRoleKey(rawRole) {
  const normalized = String(rawRole || 'student').trim().toLowerCase();
  return ROLE_KEY_ALIASES[normalized] || normalized || 'student';
}

function normalizeRoleList(input) {
  const list = Array.isArray(input) ? input : (typeof input === 'string' ? [input] : []);
  const seen = new Set();
  const normalized = [];
  list.forEach((role) => {
    const key = normalizeRoleKey(role);
    if (!key || seen.has(key)) return;
    seen.add(key);
    normalized.push(key);
  });
  return normalized;
}

function getSessionRoleList(req) {
  if (!req || !req.session) return ['student'];
  const roleList = normalizeRoleList(req.session.roles);
  if (roleList.length) return roleList;
  if (req.session.role) return normalizeRoleList([req.session.role]);
  return ['student'];
}

function hasSessionRole(req, roleKey) {
  return getSessionRoleList(req).includes(normalizeRoleKey(roleKey));
}

async function getUserRoleKeys(userId, fallbackRole = 'student') {
  const fallback = normalizeRoleKey(fallbackRole);
  if (!Number.isFinite(Number(userId))) {
    return [fallback];
  }
  try {
    const rows = await db.all(
      `
        SELECT ar.key, ur.is_primary
        FROM user_roles ur
        JOIN access_roles ar ON ar.id = ur.role_id
        WHERE ur.user_id = ? AND ar.is_active = true
        ORDER BY ur.is_primary DESC, ar.key ASC
      `,
      [userId]
    );
    const keys = normalizeRoleList((rows || []).map((row) => row.key));
    if (keys.length) return keys;
  } catch (err) {
    // fallback to legacy single-role field if RBAC tables are not available yet
  }
  return [fallback];
}

async function getRoleAllowedSectionsForRoleKeys(roleKeys = [], fallbackRole = 'student') {
  const normalizedRoles = normalizeRoleList(roleKeys);
  if (normalizedRoles.includes('admin')) return null;
  if (!normalizedRoles.length) {
    return getRoleAllowedSections(fallbackRole);
  }
  try {
    const rows = await db.all(
      `
        SELECT DISTINCT p.key
        FROM access_role_permissions rp
        JOIN access_roles ar ON ar.id = rp.role_id
        JOIN access_permissions p ON p.id = rp.permission_id
        WHERE rp.allowed = true
          AND ar.is_active = true
          AND p.category = 'admin_section'
          AND ar.key = ANY(?)
        ORDER BY p.key
      `,
      [normalizedRoles]
    );
    const list = (rows || []).map((row) => String(row.key));
    if (list.length) return list;
  } catch (err) {
    // fallback below
  }
  if (normalizedRoles.length === 1) {
    return getRoleAllowedSections(normalizedRoles[0]);
  }
  const merged = new Set();
  normalizedRoles.forEach((role) => {
    const sections = getRoleAllowedSections(role);
    if (Array.isArray(sections)) {
      sections.forEach((section) => merged.add(section));
    }
  });
  return Array.from(merged);
}

async function getRolePermissionKeysForRoleKeys(roleKeys = [], categories = []) {
  const normalizedRoles = normalizeRoleList(roleKeys);
  if (!normalizedRoles.length) {
    return new Set();
  }
  const normalizedCategories = Array.from(
    new Set((Array.isArray(categories) ? categories : []).map((value) => String(value || '').trim()).filter(Boolean))
  );
  try {
    const whereCategory = normalizedCategories.length ? 'AND p.category = ANY(?)' : '';
    const rows = await db.all(
      `
        SELECT DISTINCT p.key
        FROM access_role_permissions rp
        JOIN access_roles ar ON ar.id = rp.role_id
        JOIN access_permissions p ON p.id = rp.permission_id
        WHERE rp.allowed = true
          AND ar.is_active = true
          AND ar.key = ANY(?)
          ${whereCategory}
        ORDER BY p.key
      `,
      normalizedCategories.length ? [normalizedRoles, normalizedCategories] : [normalizedRoles]
    );
    return new Set((rows || []).map((row) => String(row.key)));
  } catch (err) {
    return new Set();
  }
}

async function getJournalAccessScope(req) {
  const roleKeys = getSessionRoleList(req);
  if (roleKeys.includes('admin')) {
    return { canUseJournal: true, ownOnly: false, fullAccess: true, permissionKeys: new Set([JOURNAL_OWN_PERMISSION, JOURNAL_FULL_PERMISSION]) };
  }
  const permissionKeys = await getRolePermissionKeysForRoleKeys(roleKeys, ['feature']);
  const fullAccess = permissionKeys.has(JOURNAL_FULL_PERMISSION);
  const ownByPermission = permissionKeys.has(JOURNAL_OWN_PERMISSION);
  const teacherFallback = roleKeys.includes('teacher');
  const studentFallback = roleKeys.includes('student') || roleKeys.includes('starosta');
  const canUseJournal = fullAccess || ownByPermission || teacherFallback || studentFallback;
  return {
    canUseJournal,
    ownOnly: !fullAccess,
    fullAccess,
    permissionKeys,
  };
}

const getRoleAllowedSections = (role) => {
  if (role === 'admin') return null;
  const permissions = settingsCache.role_permissions || {};
  if (Object.prototype.hasOwnProperty.call(permissions, role)) {
    return permissions[role];
  }
  return DEFAULT_ROLE_PERMISSIONS[role] || [];
};

const isTeacherCourseRow = (course) =>
  course && (course.is_teacher_course === true || Number(course.is_teacher_course) === 1);

async function getAllowedCourseKindsForRoleKeys(roleKeys = []) {
  const normalizedRoles = normalizeRoleList(roleKeys);
  if (!normalizedRoles.length) {
    return new Set(['regular']);
  }
  if (normalizedRoles.includes('admin')) {
    return new Set(['regular', 'teacher']);
  }
  try {
    const rows = await db.all(
      `
        SELECT DISTINCT rca.course_kind
        FROM access_role_course_access rca
        JOIN access_roles ar ON ar.id = rca.role_id
        WHERE rca.allowed = true
          AND ar.is_active = true
          AND ar.key = ANY(?)
      `,
      [normalizedRoles]
    );
    const courseKinds = new Set((rows || []).map((row) => String(row.course_kind)));
    if (courseKinds.size) return courseKinds;
  } catch (err) {
    // fallback below
  }
  if (normalizedRoles.includes('teacher')) {
    return new Set(['regular', 'teacher']);
  }
  return new Set(['regular']);
}

async function buildStaffCourseAccess(userCourseId, courses, roleOrRoles = '') {
  const roleKeys = normalizeRoleList(roleOrRoles);
  const allowedKinds = await getAllowedCourseKindsForRoleKeys(roleKeys);
  const allowedCourseIds = new Set();
  const baseCourseId = Number(userCourseId);
  if (Number.isFinite(baseCourseId)) {
    const baseCourse = (courses || []).find((course) => Number(course.id) === baseCourseId);
    const baseKind = isTeacherCourseRow(baseCourse) ? 'teacher' : 'regular';
    if (allowedKinds.has(baseKind)) {
      allowedCourseIds.add(baseCourseId);
    }
  }
  (courses || []).forEach((course) => {
    const courseKind = isTeacherCourseRow(course) ? 'teacher' : 'regular';
    if (allowedKinds.has(courseKind)) {
      allowedCourseIds.add(Number(course.id));
    }
  });
  const allowedCourses = (courses || []).filter((course) => allowedCourseIds.has(Number(course.id)));
  return { allowedCourseIds, allowedCourses, allowedKinds };
}

async function getRbacRolesDetailed() {
  try {
    const [roleRows, permissionRows, courseRows, memberRows] = await Promise.all([
      db.all(
        `
          SELECT id, key, label, description, is_system, is_active
          FROM access_roles
          ORDER BY is_system DESC, key ASC
        `
      ),
      db.all(
        `
          SELECT ar.key AS role_key, p.key AS permission_key
          FROM access_role_permissions rp
          JOIN access_roles ar ON ar.id = rp.role_id
          JOIN access_permissions p ON p.id = rp.permission_id
          WHERE rp.allowed = true
        `
      ),
      db.all(
        `
          SELECT ar.key AS role_key, rca.course_kind
          FROM access_role_course_access rca
          JOIN access_roles ar ON ar.id = rca.role_id
          WHERE rca.allowed = true
        `
      ),
      db.all(
        `
          SELECT ar.key AS role_key, COUNT(*)::int AS members_count
          FROM user_roles ur
          JOIN access_roles ar ON ar.id = ur.role_id
          GROUP BY ar.key
        `
      ),
    ]);
    const permissionsByRole = {};
    (permissionRows || []).forEach((row) => {
      if (!permissionsByRole[row.role_key]) permissionsByRole[row.role_key] = new Set();
      permissionsByRole[row.role_key].add(String(row.permission_key));
    });
    const courseByRole = {};
    (courseRows || []).forEach((row) => {
      if (!courseByRole[row.role_key]) courseByRole[row.role_key] = new Set();
      courseByRole[row.role_key].add(String(row.course_kind));
    });
    const membersByRole = {};
    (memberRows || []).forEach((row) => {
      membersByRole[row.role_key] = Number(row.members_count || 0);
    });
    return (roleRows || []).map((row) => ({
      id: Number(row.id),
      key: String(row.key),
      label: String(row.label || row.key),
      description: String(row.description || ''),
      is_system: row.is_system === true || Number(row.is_system) === 1,
      is_active: row.is_active === true || Number(row.is_active) === 1,
      permission_keys: Array.from(permissionsByRole[row.key] || []).sort(),
      course_kinds: Array.from(courseByRole[row.key] || []).sort(),
      members_count: membersByRole[row.key] || 0,
    }));
  } catch (err) {
    return [];
  }
}

async function getUserRoleAssignmentsForUserIds(userIds = []) {
  const numericIds = Array.from(
    new Set(
      (Array.isArray(userIds) ? userIds : [])
        .map((id) => Number(id))
        .filter((id) => Number.isFinite(id))
    )
  );
  const roleKeysByUser = {};
  const primaryRoleByUser = {};
  if (!numericIds.length) {
    return { roleKeysByUser, primaryRoleByUser };
  }
  try {
    const rows = await pool.query(
      `
        SELECT ur.user_id, ar.key, ur.is_primary
        FROM user_roles ur
        JOIN access_roles ar ON ar.id = ur.role_id
        WHERE ur.user_id = ANY($1::int[])
          AND ar.is_active = true
        ORDER BY ur.user_id ASC, ur.is_primary DESC, ar.key ASC
      `,
      [numericIds]
    );
    rows.rows.forEach((row) => {
      const userId = Number(row.user_id);
      if (!roleKeysByUser[userId]) roleKeysByUser[userId] = [];
      const key = normalizeRoleKey(row.key);
      if (!roleKeysByUser[userId].includes(key)) {
        roleKeysByUser[userId].push(key);
      }
      if (!primaryRoleByUser[userId] && (row.is_primary === true || Number(row.is_primary) === 1)) {
        primaryRoleByUser[userId] = key;
      }
    });
  } catch (err) {
    // fallback below
  }
  if (Object.keys(roleKeysByUser).length !== numericIds.length) {
    const missing = numericIds.filter((id) => !roleKeysByUser[id]);
    if (missing.length) {
      const fallbackRows = await pool.query(
        'SELECT id, role FROM users WHERE id = ANY($1::int[])',
        [missing]
      );
      fallbackRows.rows.forEach((row) => {
        const userId = Number(row.id);
        const key = normalizeRoleKey(row.role || 'student');
        roleKeysByUser[userId] = [key];
        primaryRoleByUser[userId] = key;
      });
    }
  }
  return { roleKeysByUser, primaryRoleByUser };
}

async function assignUserRoles(userId, roleKeysInput, options = {}) {
  const userIdNum = Number(userId);
  if (!Number.isFinite(userIdNum) || userIdNum < 1) {
    throw new Error('Invalid user');
  }
  let roleKeys = normalizeRoleList(roleKeysInput);
  if (!roleKeys.length) {
    throw new Error('At least one role is required');
  }
  if (!roleKeys.some((role) => LEGACY_SESSION_ROLES.has(role))) {
    roleKeys.push('student');
  }
  roleKeys = normalizeRoleList(roleKeys);

  const preferredPrimary = options.preferredPrimary ? normalizeRoleKey(options.preferredPrimary) : '';
  let primaryRoleKey = preferredPrimary && roleKeys.includes(preferredPrimary)
    ? preferredPrimary
    : (roleKeys.find((role) => LEGACY_SESSION_ROLES.has(role)) || roleKeys[0]);
  if (!primaryRoleKey) {
    primaryRoleKey = 'student';
  }

  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    const currentRows = await client.query(
      `
        SELECT ar.key
        FROM user_roles ur
        JOIN access_roles ar ON ar.id = ur.role_id
        WHERE ur.user_id = $1
      `,
      [userIdNum]
    );
    const currentRoles = normalizeRoleList(currentRows.rows.map((row) => row.key));
    const currentHasAdmin = currentRoles.includes('admin');
    const nextHasAdmin = roleKeys.includes('admin');
    if (currentHasAdmin && !nextHasAdmin) {
      const adminCountRow = await client.query(
        `
          SELECT COUNT(DISTINCT ur.user_id)::int AS count
          FROM user_roles ur
          JOIN access_roles ar ON ar.id = ur.role_id
          WHERE ar.key = 'admin'
        `
      );
      if (Number(adminCountRow.rows[0]?.count || 0) <= 1) {
        throw new Error('At least one admin required');
      }
    }
    const roleRows = await client.query(
      `
        SELECT id, key
        FROM access_roles
        WHERE is_active = true
          AND key = ANY($1::text[])
      `,
      [roleKeys]
    );
    if (roleRows.rows.length !== roleKeys.length) {
      throw new Error('Invalid role selection');
    }
    const roleIdByKey = new Map(roleRows.rows.map((row) => [String(row.key), Number(row.id)]));
    const roleIds = roleKeys.map((key) => roleIdByKey.get(key)).filter((id) => Number.isFinite(id));
    const primaryRoleId = roleIdByKey.get(primaryRoleKey);
    if (!Number.isFinite(primaryRoleId)) {
      throw new Error('Invalid primary role');
    }

    await client.query(
      'DELETE FROM user_roles WHERE user_id = $1 AND NOT (role_id = ANY($2::int[]))',
      [userIdNum, roleIds]
    );
    for (const roleId of roleIds) {
      await client.query(
        `
          INSERT INTO user_roles (user_id, role_id, is_primary, created_at, updated_at)
          VALUES ($1, $2, false, NOW(), NOW())
          ON CONFLICT (user_id, role_id)
          DO UPDATE SET updated_at = EXCLUDED.updated_at
        `,
        [userIdNum, roleId]
      );
    }
    await client.query(
      'UPDATE user_roles SET is_primary = false, updated_at = NOW() WHERE user_id = $1',
      [userIdNum]
    );
    await client.query(
      'UPDATE user_roles SET is_primary = true, updated_at = NOW() WHERE user_id = $1 AND role_id = $2',
      [userIdNum, primaryRoleId]
    );
    const legacyRole = LEGACY_SESSION_ROLES.has(primaryRoleKey)
      ? primaryRoleKey
      : (roleKeys.find((key) => LEGACY_SESSION_ROLES.has(key)) || 'student');
    await client.query(
      'UPDATE users SET role = $1 WHERE id = $2',
      [legacyRole, userIdNum]
    );
    await client.query('COMMIT');
    return { roleKeys, primaryRoleKey, legacyRole };
  } catch (err) {
    await client.query('ROLLBACK');
    throw err;
  } finally {
    client.release();
  }
}

const ensureUser = async (fullName, role, passwordHash, options = {}) => {
  const { courseId = 1 } = options;
  const { forcePassword = false, forceRole = false } = options;
  if (!passwordHash) {
    return;
  }
  const existing = await db.get('SELECT id, password_hash, role FROM users WHERE full_name = ?', [fullName]);
  if (!existing) {
    await db.run(
      'INSERT INTO users (full_name, role, password_hash, is_active, schedule_group, course_id, language) VALUES (?, ?, ?, ?, ?, ?, ?)',
      [fullName, role, passwordHash, 1, 'A', courseId, 'uk']
    );
    return;
  }
  if (forcePassword || !existing.password_hash) {
    await db.run('UPDATE users SET password_hash = ?, is_active = 1 WHERE id = ?', [
      passwordHash,
      existing.id,
    ]);
  } else {
    await db.run('UPDATE users SET is_active = 1 WHERE id = ?', [existing.id]);
  }
  if (forceRole && existing.role !== role) {
    await db.run('UPDATE users SET role = ? WHERE id = ?', [role, existing.id]);
  }
};

const syncRbacPermissionCatalog = async () => {
  for (const permission of RBAC_PERMISSION_OPTIONS) {
    await db.run(
      `
        INSERT INTO access_permissions (key, label, category)
        VALUES (?, ?, ?)
        ON CONFLICT (key) DO UPDATE
        SET label = EXCLUDED.label,
            category = EXCLUDED.category
      `,
      [permission.key, permission.label, permission.category]
    );
  }
  await pool.query(
    `
      INSERT INTO access_role_permissions (role_id, permission_id, allowed, created_at, updated_at)
      SELECT r.id, p.id, true, NOW(), NOW()
      FROM access_roles r
      JOIN access_permissions p ON p.category IN ('admin_section', 'feature')
      WHERE r.key = 'admin'
      ON CONFLICT (role_id, permission_id) DO NOTHING
    `
  );
};

const initDb = async () => {
  await runMigrations(pool);
  await syncRbacPermissionCatalog();

  await pool.query('UPDATE subjects SET is_required = true WHERE is_required IS NULL');

  try {
    await pool.query("UPDATE courses SET location = 'kyiv' WHERE location IS NULL");
  } catch (err) {
    if (!(err && err.code === '42703')) {
      throw err;
    }
  }
  await pool.query('UPDATE users SET course_id = 1 WHERE course_id IS NULL');
  await pool.query("UPDATE users SET language = 'uk' WHERE language IS NULL");
  await pool.query('UPDATE users SET created_at = NOW() WHERE created_at IS NULL');
  await pool.query('UPDATE subjects SET course_id = 1 WHERE course_id IS NULL');
  await pool.query('UPDATE subjects SET visible = 1 WHERE visible IS NULL');
  await pool.query('UPDATE schedule_entries SET course_id = 1 WHERE course_id IS NULL');
  await pool.query('UPDATE homework SET course_id = 1 WHERE course_id IS NULL');
  await pool.query("UPDATE homework SET status = 'published' WHERE status IS NULL");
  await pool.query('UPDATE history_log SET course_id = 1 WHERE course_id IS NULL');
  await pool.query('UPDATE login_history SET course_id = 1 WHERE course_id IS NULL');
  await pool.query('UPDATE teamwork_tasks SET course_id = 1 WHERE course_id IS NULL');
  await pool.query('UPDATE messages SET course_id = 1 WHERE course_id IS NULL');
  await pool.query("UPDATE messages SET status = 'published' WHERE status IS NULL");
  await pool.query('UPDATE personal_reminders SET course_id = 1 WHERE course_id IS NULL');
  await pool.query('UPDATE personal_reminders SET updated_at = created_at WHERE updated_at IS NULL');
  try {
    await pool.query("UPDATE subject_materials SET material_type = 'lecture' WHERE material_type IS NULL");
    await pool.query('UPDATE subject_materials SET course_id = 1 WHERE course_id IS NULL');
    await pool.query('UPDATE subject_materials SET is_syllabus = 0 WHERE is_syllabus IS NULL');
    await pool.query('UPDATE subject_materials SET updated_at = created_at WHERE updated_at IS NULL');
  } catch (err) {
    if (!(err && (err.code === '42P01' || err.code === '42703'))) {
      throw err;
    }
  }
  await pool.query('UPDATE users SET password = NULL WHERE password IS NOT NULL');

  const courseRows = await pool.query('SELECT id, name FROM courses ORDER BY id');
  for (const course of courseRows.rows) {
    const activeRow = await pool.query(
      'SELECT id, is_active FROM semesters WHERE course_id = $1 ORDER BY is_active DESC, id ASC LIMIT 1',
      [course.id]
    );
    if (!activeRow.rows.length) {
      await pool.query(
        'INSERT INTO semesters (course_id, title, start_date, weeks_count, is_active, is_archived) VALUES ($1, $2, $3, $4, 1, 0)',
        [course.id, `${course.name} семестр`, '2026-01-19', 15]
      );
    } else if (activeRow.rows[0].is_active !== 1) {
      await pool.query('UPDATE semesters SET is_active = 1 WHERE id = $1', [activeRow.rows[0].id]);
    }

    const currentActive = await pool.query(
      'SELECT id FROM semesters WHERE course_id = $1 AND is_active = 1 ORDER BY id ASC LIMIT 1',
      [course.id]
    );
    if (currentActive.rows.length) {
      const semesterId = currentActive.rows[0].id;
      await pool.query('UPDATE schedule_entries SET semester_id = $1 WHERE semester_id IS NULL AND course_id = $2', [
        semesterId,
        course.id,
      ]);
      await pool.query('UPDATE homework SET semester_id = $1 WHERE semester_id IS NULL AND course_id = $2', [
        semesterId,
        course.id,
      ]);
      await pool.query('UPDATE teamwork_tasks SET semester_id = $1 WHERE semester_id IS NULL AND course_id = $2', [
        semesterId,
        course.id,
      ]);
      await pool.query('UPDATE messages SET semester_id = $1 WHERE semester_id IS NULL AND course_id = $2', [
        semesterId,
        course.id,
      ]);
      await pool.query('UPDATE personal_reminders SET semester_id = $1 WHERE semester_id IS NULL AND course_id = $2', [
        semesterId,
        course.id,
      ]);
    }
  }

  for (const user of userSeed) {
    const isAdmin = user.role === 'admin';
    await ensureUser(user.full_name, user.role, user.password_hash, {
      forcePassword: isAdmin,
      forceRole: isAdmin,
    });
  }

  await refreshSettingsCache();
};

let initPromise;
let initStatus = 'pending';
let initError = null;
const ensureDbReady = async () => {
  if (initPromise) {
    return initPromise;
  }
  initPromise = (async () => {
    const maxAttempts = 8;
    let lastError;
    for (let attempt = 1; attempt <= maxAttempts; attempt += 1) {
      try {
        initStatus = 'pending';
        await initDb();
        initStatus = 'ok';
        initError = null;
        return true;
      } catch (err) {
        lastError = err;
        initStatus = 'error';
        initError = err;
        const delay = Math.min(1000 * 2 ** (attempt - 1), 15000);
        console.error(`DB init attempt ${attempt} failed, retrying in ${delay}ms`, err);
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }
    throw lastError;
  })();
  try {
    return await initPromise;
  } catch (err) {
    initPromise = null;
    throw err;
  }
};

app.use(async (req, res, next) => {
  if (!req.session || !req.session.user) {
    return next();
  }
  try {
    await ensureDbReady();
    const roleKeys = await getUserRoleKeys(req.session.user.id, req.session.role || 'student');
    req.session.roles = roleKeys;
    const legacyRole = roleKeys.find((key) => LEGACY_SESSION_ROLES.has(key))
      || normalizeRoleKey(req.session.role || 'student');
    req.session.role = legacyRole;
    res.locals.userRoles = roleKeys;
  } catch (err) {
    req.session.roles = getSessionRoleList(req);
    req.session.role = normalizeRoleKey(req.session.role || req.session.roles[0] || 'student');
    res.locals.userRoles = req.session.roles;
  }
  return next();
});

function requireAdminPanelAccess(req, res, next) {
  if (!req.session || !req.session.user) {
    return res.status(403).send('Forbidden (update page)');
  }
  if (hasSessionRole(req, 'admin') || req.canAccessAdminPanel) {
    return next();
  }
  return res.status(403).send('Forbidden (update page)');
}

function hasAdminSectionAccess(req, sectionId) {
  if (!req || !req.session || !req.session.user) return false;
  if (hasSessionRole(req, 'admin')) return true;
  const allowedSections = Array.isArray(req.allowedAdminSections) ? req.allowedAdminSections : [];
  if (!sectionId) {
    return allowedSections.length > 0;
  }
  return allowedSections.includes(sectionId);
}

function requireAdminSectionAccess(sectionId) {
  return (req, res, next) => {
    if (!hasAdminSectionAccess(req, sectionId)) {
      return res.status(403).send('Forbidden (update page)');
    }
    return next();
  };
}

function hasUsersSectionAccess(req) {
  return hasAdminSectionAccess(req, 'admin-users');
}

function hasStudentsSectionAccess(req) {
  return hasAdminSectionAccess(req, 'admin-students');
}

function requireUsersOrStudentsSectionAccess(req, res, next) {
  if (hasUsersSectionAccess(req) || hasStudentsSectionAccess(req)) {
    return next();
  }
  return res.status(403).send('Forbidden (update page)');
}

function isStudentLikeLegacyRole(rawRole) {
  const normalized = normalizeRoleKey(rawRole);
  return normalized === 'student' || normalized === 'starosta';
}

function canManageStudentOnlyScope(req) {
  return !hasUsersSectionAccess(req) && hasStudentsSectionAccess(req);
}

const requireOverviewSectionAccess = requireAdminSectionAccess('admin-overview');
const requireSettingsSectionAccess = requireAdminSectionAccess('admin-settings');
const requireRoleAccessSectionAccess = requireAdminSectionAccess('admin-role-access');
const requireVisitAnalyticsSectionAccess = requireAdminSectionAccess('admin-visit-analytics');
const requireScheduleSectionAccess = requireAdminSectionAccess('admin-schedule');
const requireImportExportSectionAccess = requireAdminSectionAccess('admin-import-export');
const requireScheduleGeneratorSectionAccess = requireAdminSectionAccess('admin-schedule-generator');
const requireHomeworkSectionAccess = requireAdminSectionAccess('admin-homework');
const requireUsersSectionAccess = requireAdminSectionAccess('admin-users');
const requireTeachersSectionAccess = requireAdminSectionAccess('admin-teachers');
const requireSubjectsSectionAccess = requireAdminSectionAccess('admin-subjects');
const requireSemestersSectionAccess = requireAdminSectionAccess('admin-semesters');
const requireCoursesSectionAccess = requireAdminSectionAccess('admin-courses');
const requireHistorySectionAccess = requireAdminSectionAccess('admin-history');
const requireActivitySectionAccess = requireAdminSectionAccess('admin-activity');
const requireTeamworkSectionAccess = requireAdminSectionAccess('admin-teamwork');
const requireMessagesSectionAccess = requireAdminSectionAccess('admin-messages');

app.use(async (req, res, next) => {
  if (!req.session || !req.session.user) {
    req.allowedAdminSections = [];
    req.canAccessAdminPanel = false;
    res.locals.hasCustomAdminPanelAccess = false;
    res.locals.customAdminPanelHref = '/admin';
    return next();
  }
  const roleKeys = getSessionRoleList(req);
  const isAdmin = roleKeys.includes('admin');
  let allowedSections = null;
  if (!isAdmin) {
    try {
      allowedSections = await getRoleAllowedSectionsForRoleKeys(roleKeys, req.session.role || roleKeys[0] || 'student');
    } catch (err) {
      allowedSections = getRoleAllowedSections(req.session.role || roleKeys[0] || 'student');
    }
    if (!Array.isArray(allowedSections)) {
      allowedSections = [];
    }
  }
  const canAccessAdminPanel = isAdmin || (Array.isArray(allowedSections) && allowedSections.length > 0);
  const hasLegacyStaffRole = roleKeys.some((key) => ['admin', 'deanery', 'starosta'].includes(key));
  req.allowedAdminSections = isAdmin ? null : allowedSections;
  req.canAccessAdminPanel = canAccessAdminPanel;
  res.locals.hasCustomAdminPanelAccess = canAccessAdminPanel && !hasLegacyStaffRole;
  res.locals.customAdminPanelHref = '/admin';
  return next();
});

app.use(async (req, res, next) => {
  if (!req.session || !req.session.user) {
    return next();
  }
  if (hasSessionRole(req, 'admin')) {
    return next();
  }
  const allowedPrefixes = [
    '/teacher/pending',
    '/teacher/subjects',
    '/profile',
    '/logout',
    '/login',
    '/register',
    '/register/course',
    '/register/teacher-subjects',
    '/register/subjects',
  ];
  if (allowedPrefixes.some((prefix) => req.path === prefix || req.path.startsWith(`${prefix}/`))) {
    return next();
  }
  try {
    const courseId = req.session.user.course_id;
    if (!courseId) {
      return next();
    }
    const isTeacher = await isTeacherCourse(courseId);
    if (!isTeacher) {
      return next();
    }
    const request = await db.get('SELECT status FROM teacher_requests WHERE user_id = ?', [req.session.user.id]);
    if (!request) {
      return next();
    }
    if (request.status === 'approved') {
      if (!hasSessionRole(req, 'teacher')) {
        req.session.roles = normalizeRoleList([...getSessionRoleList(req), 'teacher']);
      }
      if (!hasSessionRole(req, 'admin') && !hasSessionRole(req, 'deanery') && !hasSessionRole(req, 'starosta')) {
        req.session.role = 'teacher';
      }
      return next();
    }
    return res.redirect('/teacher/pending');
  } catch (err) {
    console.error('Teacher gate error', err);
    return next();
  }
});

const uploadsDir = path.join(__dirname, 'uploads');
try {
  fs.mkdirSync(uploadsDir, { recursive: true });
} catch (err) {
  console.error('Failed to ensure uploads directory', err);
}

function normalizeUploadedOriginalName(rawName, fallbackName = null) {
  const initial = String(rawName || '').replace(/[\u0000-\u001F\u007F]/g, '').trim();
  if (!initial) return fallbackName;
  let normalized = initial;
  try {
    const decoded = Buffer.from(initial, 'latin1').toString('utf8');
    const hasMojibakeMarkers = /[ÐÑÃÂ]/.test(initial);
    const hasCyrillic = /[\u0400-\u04FF]/.test(decoded);
    const hasReplacement = decoded.includes('\uFFFD');
    if (hasMojibakeMarkers && hasCyrillic && !hasReplacement) {
      normalized = decoded;
    }
  } catch (err) {
    normalized = initial;
  }
  return normalized.replace(/[\u0000-\u001F\u007F]/g, '').trim() || fallbackName;
}

const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    try {
      fs.mkdirSync(uploadsDir, { recursive: true });
    } catch (err) {
      return cb(err);
    }
    return cb(null, uploadsDir);
  },
  filename: (req, file, cb) => {
    const originalName = normalizeUploadedOriginalName(file.originalname, 'file');
    file.originalname = originalName;
    const ext = path.extname(originalName);
    const base = path
      .basename(originalName, ext)
      .replace(/\s+/g, '_')
      .replace(/[^a-zA-Z0-9-_]/g, '_')
      .replace(/_+/g, '_')
      .replace(/^_+|_+$/g, '') || 'file';
    const stamp = Date.now();
    cb(null, `${base}-${stamp}${ext}`);
  },
});

const allowedTypes = new Set([
  'image/png',
  'image/jpeg',
  'image/gif',
  'application/pdf',
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  'application/msword',
  'application/vnd.openxmlformats-officedocument.presentationml.presentation',
  'application/vnd.ms-powerpoint',
  'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  'application/vnd.ms-excel',
  'text/plain',
]);

const upload = multer({
  storage,
  limits: { fileSize: (settingsCache.max_file_size_mb || 20) * 1024 * 1024 },
  fileFilter: (req, file, cb) => {
    if (!allowedTypes.has(file.mimetype)) {
      return cb(new Error('Invalid file type'));
    }
    return cb(null, true);
  },
});

const csvUpload = multer({
  storage: multer.memoryStorage(),
  limits: { fileSize: 2 * 1024 * 1024 },
  fileFilter: (req, file, cb) => {
    const okTypes = new Set(['text/csv', 'application/vnd.ms-excel', 'application/csv', 'text/plain', 'application/octet-stream']);
    if (!okTypes.has(file.mimetype)) {
      return cb(new Error('Invalid file type'));
    }
    return cb(null, true);
  },
});

const sanitizeCsvValue = (value) => {
  const raw = String(value ?? '');
  const safe = raw.replace(/\r?\n/g, ' ');
  if (/^[=+\-@]/.test(safe)) {
    return `'${safe}`;
  }
  return safe;
};

const escapeCsvValue = (value) => `"${sanitizeCsvValue(value).replace(/\"/g, '""')}"`;

const IMPORT_CONFIRM_THRESHOLD = 20;
const IMPORT_VALIDATION_TTL_MS = 15 * 60 * 1000;
const IMPORT_REQUIRED_COLUMNS = {
  schedule: ['subject', 'group_number', 'day_of_week', 'class_number', 'week_number'],
  users: ['full_name', 'role', 'schedule_group', 'is_active', 'course_id'],
  subjects: ['name', 'group_count', 'default_group', 'is_required', 'is_general'],
};
const importValidationCache = new Map();

const setImportValidationCache = (operationId, payload) => {
  importValidationCache.set(operationId, {
    ...payload,
    expiresAt: Date.now() + IMPORT_VALIDATION_TTL_MS,
  });
};

const getImportValidationCache = (operationId) => {
  const entry = importValidationCache.get(operationId);
  if (!entry) return null;
  if (entry.expiresAt < Date.now()) {
    importValidationCache.delete(operationId);
    return null;
  }
  return entry;
};

const pushImportError = (errors, rowNumber, column, value, reason) => {
  errors.push({
    row_number: rowNumber,
    column,
    value: value === undefined ? '' : String(value),
    reason,
  });
};

const normalizeLessonType = (value) => {
  if (value === null || typeof value === 'undefined') return null;
  const raw = String(value).trim().toLowerCase();
  if (!raw) return null;
  if (['lecture', 'seminar', 'lab', 'practice'].includes(raw)) return raw;
  if (raw.startsWith('лек')) return 'lecture';
  if (raw.startsWith('сем')) return 'seminar';
  if (raw.startsWith('лаб')) return 'lab';
  if (raw.startsWith('практ')) return 'practice';
  return null;
};

const resolveImportScope = async (req, type) => {
  const courses = await getCoursesCached();
  const fallbackCourseId = getAdminCourse(req);
  const rawCourseId = Number(req.body.scope_course_id || req.body.course_id || fallbackCourseId);
  const scopeCourse =
    (courses || []).find((course) => Number(course.id) === Number(rawCourseId)) ||
    (courses || []).find((course) => Number(course.id) === Number(fallbackCourseId)) ||
    null;
  if (!scopeCourse) {
    return { error: 'Invalid course scope' };
  }
  let semester = null;
  if (type === 'schedule') {
    const rawSemesterId = Number(req.body.scope_semester_id || req.body.semester_id);
    if (Number.isFinite(rawSemesterId) && rawSemesterId > 0) {
      semester = await db.get('SELECT * FROM semesters WHERE id = ? AND course_id = ?', [rawSemesterId, scopeCourse.id]);
    }
    if (!semester) {
      semester = await getActiveSemester(scopeCourse.id);
    }
    if (!semester) {
      return { error: 'No active semester' };
    }
  }
  return {
    course: scopeCourse,
    semester,
    campus: scopeCourse.location || 'kyiv',
  };
};

const referenceCache = {
  courses: { data: null, expiresAt: 0 },
  subjects: new Map(),
  semesters: new Map(),
  activeSemester: new Map(),
  studyDays: new Map(),
  weekTime: new Map(),
};
const REFERENCE_TTL_MS = 5 * 60 * 1000;

function cacheGet(store, key) {
  const entry = store instanceof Map ? store.get(key) : store[key];
  if (!entry || !entry.expiresAt || entry.expiresAt < Date.now()) {
    return null;
  }
  return entry.data;
}

function cacheSet(store, key, data, ttlMs = REFERENCE_TTL_MS) {
  const entry = { data, expiresAt: Date.now() + ttlMs };
  if (store instanceof Map) {
    store.set(key, entry);
  } else {
    store[key] = entry;
  }
  return data;
}

function cacheDelete(store, key) {
  if (store instanceof Map) {
    store.delete(key);
  } else {
    store[key] = { data: null, expiresAt: 0 };
  }
}

function invalidateCoursesCache() {
  cacheDelete(referenceCache.courses, 'courses');
}

function invalidateSubjectsCache(courseId) {
  if (!courseId) {
    referenceCache.subjects.clear();
    return;
  }
  referenceCache.subjects.delete(`${courseId}|all`);
  referenceCache.subjects.delete(`${courseId}|visible`);
}

function invalidateSemestersCache(courseId) {
  if (!courseId) {
    referenceCache.semesters.clear();
  } else {
    referenceCache.semesters.delete(courseId);
  }
  invalidateActiveSemesterCache(courseId);
}

function invalidateActiveSemesterCache(courseId) {
  if (!courseId) {
    referenceCache.activeSemester.clear();
  } else {
    referenceCache.activeSemester.delete(courseId);
  }
}

function invalidateStudyDaysCache(courseId) {
  if (!courseId) {
    referenceCache.studyDays.clear();
  } else {
    referenceCache.studyDays.delete(courseId);
  }
}

function invalidateWeekTimeCache() {
  referenceCache.weekTime.clear();
}

async function getCoursesCached() {
  const cached = cacheGet(referenceCache.courses, 'courses');
  if (cached) return cached;
  try {
    const rows = await db.all('SELECT id, name, is_teacher_course, location FROM courses ORDER BY id');
    const normalized = (rows || []).map((row) => ({
      ...row,
      location: row.location || 'kyiv',
    }));
    return cacheSet(referenceCache.courses, 'courses', normalized);
  } catch (err) {
    const missingColumn = err && err.code === '42703';
    if (missingColumn) {
      const rows = await db.all('SELECT id, name, is_teacher_course FROM courses ORDER BY id');
      const normalized = (rows || []).map((row) => ({
        ...row,
        location: 'kyiv',
      }));
      return cacheSet(referenceCache.courses, 'courses', normalized);
    }
    throw err;
  }
}

async function getCourseById(courseId) {
  const courses = await getCoursesCached();
  return (courses || []).find((c) => Number(c.id) === Number(courseId)) || null;
}

async function isTeacherCourse(courseId) {
  if (!courseId) return false;
  const course = await getCourseById(courseId);
  if (!course) return false;
  return course.is_teacher_course === true || Number(course.is_teacher_course) === 1;
}

async function getSubjectsCached(courseId, options = {}) {
  const key = `${courseId}|${options.visibleOnly ? 'visible' : 'all'}`;
  const cached = cacheGet(referenceCache.subjects, key);
  if (cached) return cached;
  const sql = options.visibleOnly
    ? 'SELECT * FROM subjects WHERE course_id = ? AND visible = 1 ORDER BY name'
    : 'SELECT * FROM subjects WHERE course_id = ? ORDER BY name';
  const rows = await db.all(sql, [courseId]);
  return cacheSet(referenceCache.subjects, key, rows || []);
}

async function getSemestersCached(courseId) {
  const cached = cacheGet(referenceCache.semesters, courseId);
  if (cached) return cached;
  const rows = await db.all('SELECT * FROM semesters WHERE course_id = ? ORDER BY start_date DESC', [courseId]);
  return cacheSet(referenceCache.semesters, courseId, rows || []);
}

const DEFAULT_GENERATOR_CONFIG = {
  distribution: 'even',
  seminar_distribution: 'even',
  max_daily_pairs: 7,
  target_daily_pairs: 4,
  evenness_bias: 50,
  late_slot_weight: 60,
  blocked_weeks: '',
  special_weeks_mode: 'block',
  prefer_compactness: false,
  mirror_groups: false,
  strict_no_evening: false,
  auto_subject_days: true,
  subject_single_day: true,
  lecture_seminar_same_day: true,
  lecture_before_seminar: true,
  active_location: 'kyiv',
  course_semesters: {},
  course_semesters_by_location: {
    kyiv: {},
    munich: {},
  },
};

const parseGeneratorConfig = (raw) => {
  if (!raw) return { ...DEFAULT_GENERATOR_CONFIG };
  try {
    const parsed = JSON.parse(raw) || {};
    if (parsed.course_semesters && !parsed.course_semesters_by_location) {
      parsed.course_semesters_by_location = {
        kyiv: parsed.course_semesters,
        munich: {},
      };
    }
    const merged = {
      ...DEFAULT_GENERATOR_CONFIG,
      ...parsed,
    };
    if (!merged.course_semesters_by_location) {
      merged.course_semesters_by_location = { kyiv: {}, munich: {} };
    }
    merged.course_semesters_by_location = {
      kyiv: {
        ...(DEFAULT_GENERATOR_CONFIG.course_semesters_by_location || {}).kyiv,
        ...(merged.course_semesters_by_location.kyiv || {}),
      },
      munich: {
        ...(DEFAULT_GENERATOR_CONFIG.course_semesters_by_location || {}).munich,
        ...(merged.course_semesters_by_location.munich || {}),
      },
    };
    merged.distribution = normalizeDistribution(merged.distribution, DEFAULT_GENERATOR_CONFIG.distribution);
    merged.seminar_distribution = normalizeDistribution(
      merged.seminar_distribution,
      DEFAULT_GENERATOR_CONFIG.seminar_distribution
    );
    merged.active_location = merged.active_location === 'munich' ? 'munich' : 'kyiv';
    return merged;
  } catch (err) {
    return { ...DEFAULT_GENERATOR_CONFIG };
  }
};

const serializeGeneratorConfig = (config) => JSON.stringify({ ...DEFAULT_GENERATOR_CONFIG, ...(config || {}) });

const normalizeGeneratorDays = (days) =>
  (Array.isArray(days) ? days : typeof days === 'string' ? [days] : [])
    .map((d) => String(d))
    .filter(Boolean);

const normalizeWeekdayName = (value) => {
  if (!value) return null;
  const match = fullWeekDays.find((day) => day.toLowerCase() === String(value).toLowerCase());
  return match || null;
};

const normalizeGeneratorLocation = (value) =>
  String(value || '').toLowerCase() === 'munich' ? 'munich' : 'kyiv';

const getConfiguredCourseSemesterId = (config, courseId, location) => {
  const loc = normalizeGeneratorLocation(location || config?.active_location);
  const byLocation = config && config.course_semesters_by_location
    ? config.course_semesters_by_location[loc]
    : null;
  if (byLocation && Object.keys(byLocation).length) {
    return byLocation[courseId] || byLocation[String(courseId)] || null;
  }
  const fallback = config && config.course_semesters ? config.course_semesters : null;
  if (!fallback) return null;
  return fallback[courseId] || fallback[String(courseId)] || null;
};

async function getCoursesByLocation(location) {
  const target = String(location || 'kyiv').toLowerCase();
  const courses = await getCoursesCached();
  return (courses || []).filter((course) => {
    const isTeacher = course.is_teacher_course === true || Number(course.is_teacher_course) === 1;
    const courseLocation = String(course.location || 'kyiv').toLowerCase();
    return !isTeacher && courseLocation === target;
  });
}

const normalizeMirrorKey = (value) => String(value || '').trim().toLowerCase();
const ALLOWED_DISTRIBUTIONS = new Set(['start', 'even', 'end']);
const normalizeDistribution = (value, fallback = 'even') => {
  const raw = String(value || '').trim().toLowerCase();
  if (ALLOWED_DISTRIBUTIONS.has(raw)) return raw;
  return ALLOWED_DISTRIBUTIONS.has(String(fallback || '').trim().toLowerCase())
    ? String(fallback).trim().toLowerCase()
    : 'even';
};

const parseSubjectTypeSuffix = (name) => {
  const raw = String(name || '').trim();
  const match = raw.match(/\s*\(([^)]+)\)\s*$/i);
  if (!match) {
    return { base: raw, type: null };
  }
  const label = match[1].trim().toLowerCase();
  let type = null;
  if (label.startsWith('лек') || label === 'lecture' || label === 'lect') {
    type = 'lecture';
  } else if (label.startsWith('сем') || label === 'seminar') {
    type = 'seminar';
  }
  if (!type) {
    return { base: raw, type: null };
  }
  const base = raw.replace(match[0], '').trim();
  return { base, type };
};

const loadSubjectCounts = async (table) => {
  const rows = await db.all(`SELECT subject_id, COUNT(*) AS cnt FROM ${table} GROUP BY subject_id`);
  const map = new Map();
  (rows || []).forEach((row) => {
    map.set(Number(row.subject_id), Number(row.cnt || 0));
  });
  return map;
};

const buildSubjectMergePreview = async (courseIdFilter) => {
  const subjects = await db.all(
    `SELECT id, name, group_count, default_group, show_in_teamwork, visible, is_required, is_general, course_id
     FROM subjects
     ORDER BY id`
  );
  if (!subjects.length) return [];

  const countTables = [
    'schedule_entries',
    'student_groups',
    'teacher_subjects',
    'user_subject_optouts',
    'course_day_subjects',
    'homework',
    'teamwork_tasks',
    'messages',
    'schedule_generator_items',
    'schedule_generator_entries',
  ];
  const usageCounts = new Map();
  for (const table of countTables) {
    const tableCounts = await loadSubjectCounts(table);
    tableCounts.forEach((count, subjectId) => {
      usageCounts.set(subjectId, (usageCounts.get(subjectId) || 0) + count);
    });
  }

  const groups = new Map();
  subjects.forEach((subject) => {
    const parsed = parseSubjectTypeSuffix(subject.name);
    if (!parsed.base) return;
    const key = `${subject.course_id || 0}|${parsed.base.toLowerCase()}`;
    if (!groups.has(key)) {
      groups.set(key, {
        courseId: subject.course_id,
        baseName: parsed.base,
        lecture: null,
        seminar: null,
        base: null,
      });
    }
    const group = groups.get(key);
    if (parsed.type === 'lecture') {
      group.lecture = subject;
    } else if (parsed.type === 'seminar') {
      group.seminar = subject;
    } else if (String(subject.name).trim().toLowerCase() === parsed.base.toLowerCase()) {
      group.base = subject;
    }
  });

  const courses = await getCoursesCached();
  const courseNameById = {};
  (courses || []).forEach((course) => {
    courseNameById[course.id] = course.name;
  });

  const preview = [];
  for (const group of groups.values()) {
    if (!group.lecture || !group.seminar) continue;
    if (Number.isFinite(courseIdFilter) && Number(group.courseId) !== Number(courseIdFilter)) {
      continue;
    }
    const lecture = group.lecture;
    const seminar = group.seminar;
    const baseSubject = group.base;

    let canonical = baseSubject || null;
    if (!canonical) {
      const lectureScore = usageCounts.get(lecture.id) || 0;
      const seminarScore = usageCounts.get(seminar.id) || 0;
      canonical = lectureScore === seminarScore ? lecture : lectureScore > seminarScore ? lecture : seminar;
    }

    const canonicalId = canonical.id;
    const targetName = group.baseName;
    let finalName = canonical.name;
    let renameConflict = false;
    if (targetName && String(canonical.name) !== String(targetName)) {
      const nameCheck = await db.all('SELECT id FROM subjects WHERE LOWER(name) = LOWER(?)', [targetName]);
      const conflict = (nameCheck || []).find(
        (row) =>
          Number(row.id) !== Number(canonicalId) && ![lecture.id, seminar.id].includes(Number(row.id))
      );
      if (!conflict) {
        finalName = targetName;
      } else {
        renameConflict = true;
      }
    }

    preview.push({
      course_id: group.courseId,
      course_name: courseNameById[group.courseId] || null,
      base_name: group.baseName,
      canonical_id: canonicalId,
      canonical_name: finalName,
      canonical_source: canonicalId === lecture.id ? 'lecture' : canonicalId === seminar.id ? 'seminar' : 'base',
      lecture: {
        id: lecture.id,
        name: lecture.name,
        usage: usageCounts.get(lecture.id) || 0,
      },
      seminar: {
        id: seminar.id,
        name: seminar.name,
        usage: usageCounts.get(seminar.id) || 0,
      },
      base_subject_id: baseSubject ? baseSubject.id : null,
      rename: finalName !== canonical.name ? { from: canonical.name, to: finalName } : null,
      rename_conflict: renameConflict,
    });
  }

  return preview;
};

const buildHeatmap = (entries, days, slots) => {
  const counts = {};
  days.forEach((day) => {
    counts[day] = {};
    slots.forEach((slot) => {
      counts[day][slot] = 0;
    });
  });
  (entries || []).forEach((entry) => {
    const day = normalizeWeekdayName(entry.day_of_week);
    const slot = Number(entry.class_number);
    if (!day || !counts[day] || !Number.isFinite(slot)) return;
    if (counts[day][slot] === undefined) return;
    counts[day][slot] += 1;
  });
  let max = 0;
  Object.values(counts).forEach((row) => {
    Object.values(row).forEach((value) => {
      if (value > max) max = value;
    });
  });
  return { counts, max };
};

const buildGenerationInsights = ({
  validationByLocation,
  conflictDetails,
  heatmapByLocation,
  mirrorSummaryByLocation,
  config,
}) => {
  const reasonLabels = {
    missing_course_context: 'Немає активного семестру',
    missing_weeks_count: 'Не задано кількість тижнів',
    no_available_weeks: 'Немає доступних тижнів',
    no_allowed_days: 'Немає доступних днів',
    no_allowed_classes: 'Немає дозволених слотів',
    no_slot_found: 'Немає слота',
    partial_schedule: 'Часткова генерація',
    subject_day_mismatch: 'Предмет має різні дні',
    unknown: 'Невідома причина',
  };
  const result = { kyiv: null, munich: null };
  ['kyiv', 'munich'].forEach((location) => {
    const validation = validationByLocation && validationByLocation[location]
      ? validationByLocation[location]
      : { issues: [] };
    const issues = Array.isArray(validation.issues) ? validation.issues : [];
    const blockers = issues.filter((issue) => issue.level === 'error').length;
    const warnings = issues.filter((issue) => issue.level !== 'error').length;
    const conflicts = conflictDetails && conflictDetails[location] ? conflictDetails[location] : [];
    const reasonCounts = {};
    (conflicts || []).forEach((row) => {
      const reason = String(row.reason || 'unknown');
      reasonCounts[reason] = (reasonCounts[reason] || 0) + 1;
    });
    const conflictTop = Object.entries(reasonCounts)
      .sort((a, b) => b[1] - a[1] || a[0].localeCompare(b[0]))
      .slice(0, 3)
      .map(([reason, count]) => ({
        reason,
        label: reasonLabels[reason] || reasonLabels.unknown,
        count,
      }));

    const heatmap = heatmapByLocation && heatmapByLocation[location] ? heatmapByLocation[location] : null;
    const slotTotals = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0 };
    const dayTotals = (fullWeekDays || []).map((day) => {
      const row = heatmap && heatmap.counts && heatmap.counts[day] ? heatmap.counts[day] : {};
      let total = 0;
      [1, 2, 3, 4, 5, 6, 7].forEach((slot) => {
        const count = Number(row[slot] || 0);
        slotTotals[slot] += count;
        total += count;
      });
      return { day, total };
    });
    const totalEntries = dayTotals.reduce((sum, row) => sum + row.total, 0);
    const lateEntries = slotTotals[5] + slotTotals[6] + slotTotals[7];
    const lateShare = totalEntries ? lateEntries / totalEntries : 0;
    const activeDayTotals = dayTotals.map((row) => row.total).filter((value) => value > 0);
    const averageDayLoad = activeDayTotals.length
      ? activeDayTotals.reduce((sum, value) => sum + value, 0) / activeDayTotals.length
      : 0;
    const dayVariance = activeDayTotals.length
      ? activeDayTotals.reduce((sum, value) => sum + (value - averageDayLoad) ** 2, 0) / activeDayTotals.length
      : 0;
    const dayStd = Math.sqrt(dayVariance);
    const dayImbalance = averageDayLoad ? dayStd / averageDayLoad : 0;
    const peakDay = [...dayTotals].sort((a, b) => b.total - a.total)[0] || { day: null, total: 0 };
    const peakSlot = Object.entries(slotTotals)
      .sort((a, b) => b[1] - a[1] || Number(a[0]) - Number(b[0]))[0] || ['1', 0];

    const mirrorSummary = mirrorSummaryByLocation && mirrorSummaryByLocation[location]
      ? mirrorSummaryByLocation[location]
      : [];
    const mirrorWarn = (mirrorSummary || []).filter((row) => row.status && row.status !== 'ok').length;
    const mirrorMissing = (mirrorSummary || []).filter((row) => row.status === 'missing').length;
    const partialCount = Number(reasonCounts.partial_schedule || 0);
    const noSlotCount = Number(reasonCounts.no_slot_found || 0);
    const noAllowedClassesCount = Number(reasonCounts.no_allowed_classes || 0);

    const tips = [];
    if (blockers > 0) {
      tips.push('Спершу закрийте критичні пункти у блоці "Перед запуском".');
    }
    if (partialCount > 0) {
      tips.push('Є часткова генерація: зменшіть к-сть пар або розширте доступні тижні/дні.');
    }
    if (noSlotCount > 0) {
      tips.push('Для no-slot перевірте fixed-обмеження та ліміти викладачів.');
    }
    if (noAllowedClassesCount > 0) {
      tips.push('Немає дозволених слотів: вимкніть strict no-evening або перегляньте fixed-слоти.');
    }
    if (mirrorWarn > 0) {
      tips.push('Перевірте дзеркальні ключі: A/B має формуватися між різними предметами.');
    }
    if (lateShare > 0.22 && Number(config.late_slot_weight || 0) > 0) {
      tips.push('Багато вечірніх пар: зменшіть compactness або target пар/день.');
    }
    if (dayImbalance > 0.42) {
      tips.push('Є перекіс по днях: підніміть evenness або вимкніть фіксацію дня для частини предметів.');
    }
    const finalTips = tips.length ? tips.slice(0, 3) : ['Поточна конфігурація виглядає збалансовано.'];

    let healthScore = 100;
    healthScore -= blockers * 22;
    healthScore -= warnings * 6;
    healthScore -= partialCount * 8;
    healthScore -= noSlotCount * 10;
    healthScore -= noAllowedClassesCount * 12;
    healthScore -= mirrorWarn * 7;
    healthScore -= Math.round(lateShare * 35);
    healthScore -= Math.round(Math.min(1, dayImbalance) * 25);
    healthScore = Math.max(0, Math.min(100, healthScore));
    const healthState = healthScore >= 75 ? 'good' : healthScore >= 45 ? 'warn' : 'critical';

    result[location] = {
      blockers,
      warnings,
      partialCount,
      noSlotCount,
      noAllowedClassesCount,
      mirrorWarn,
      mirrorMissing,
      totalEntries,
      lateEntries,
      lateShare,
      dayImbalance,
      peakDay,
      peakSlot: {
        slot: Number(peakSlot[0]),
        count: Number(peakSlot[1] || 0),
      },
      conflictTop,
      tips: finalTips,
      healthScore,
      healthState,
    };
  });
  return result;
};

const buildSafeAutoTunePatch = (config, insight) => {
  const clamp = (value, min, max, fallback) => {
    const n = Number(value);
    if (!Number.isFinite(n)) return fallback;
    return Math.min(Math.max(n, min), max);
  };
  const maxDailyPairs = clamp(config.max_daily_pairs, 1, 7, 7);
  const baseTarget = clamp(config.target_daily_pairs, 1, Math.min(7, maxDailyPairs), 4);
  const patch = {
    distribution: 'even',
    seminar_distribution: 'even',
    evenness_bias: clamp(Math.max(65, Number(config.evenness_bias || 50)), 45, 90, 70),
    late_slot_weight: clamp(Math.max(70, Number(config.late_slot_weight || 60)), 0, 100, 80),
    target_daily_pairs: clamp(Math.min(baseTarget, 4), 1, Math.min(7, maxDailyPairs), Math.min(4, maxDailyPairs)),
    prefer_compactness: false,
    strict_no_evening: Boolean(config.strict_no_evening),
    auto_subject_days: true,
    subject_single_day: true,
    lecture_seminar_same_day: true,
    lecture_before_seminar: true,
  };

  if (!insight) {
    if (patch.target_daily_pairs > maxDailyPairs) {
      patch.target_daily_pairs = maxDailyPairs;
    }
    return patch;
  }

  if (Number(insight.dayImbalance || 0) > 0.42) {
    patch.evenness_bias = clamp(Math.max(patch.evenness_bias, 82), 45, 90, patch.evenness_bias);
  }
  if (Number(insight.lateShare || 0) > 0.22) {
    patch.late_slot_weight = clamp(Math.max(patch.late_slot_weight, 92), 0, 100, patch.late_slot_weight);
  }

  const hasCapacityPressure = Number(insight.noSlotCount || 0) > 0
    || Number(insight.partialCount || 0) > 0
    || Number(insight.noAllowedClassesCount || 0) > 0;
  if (hasCapacityPressure) {
    patch.prefer_compactness = false;
    patch.evenness_bias = clamp(Math.max(60, patch.evenness_bias - 10), 45, 90, patch.evenness_bias);
    patch.late_slot_weight = clamp(Math.min(patch.late_slot_weight, 80), 0, 100, patch.late_slot_weight);
    patch.target_daily_pairs = clamp(Math.min(patch.target_daily_pairs, 4), 1, Math.min(7, maxDailyPairs), patch.target_daily_pairs);
    patch.strict_no_evening = false;
  } else if (Number(insight.lateShare || 0) <= 0.18 && Number(insight.healthScore || 0) >= 70) {
    patch.strict_no_evening = true;
  }

  if (Number(insight.blockers || 0) > 0) {
    patch.strict_no_evening = false;
  }

  if (patch.target_daily_pairs > maxDailyPairs) {
    patch.target_daily_pairs = maxDailyPairs;
  }
  return patch;
};

const buildMirrorSummary = (items, courseById) => {
  const groups = new Map();
  (items || []).forEach((item) => {
    const key = normalizeMirrorKey(item.mirror_key);
    if (!key) return;
    if (!groups.has(key)) {
      groups.set(key, { key, raw: item.mirror_key, items: [] });
    }
    groups.get(key).items.push(item);
  });
  const summary = [];
  groups.forEach((group) => {
    const group1Items = group.items.filter((item) => Number(item.group_number) === 1);
    const group2Items = group.items.filter((item) => Number(item.group_number) === 2);
    const group1 = group1Items.length;
    const group2 = group2Items.length;
    const subjects = Array.from(new Set(group.items.map((item) => item.subject_name).filter(Boolean)));
    const courses = Array.from(new Set(group.items.map((item) => courseById[item.course_id]).filter(Boolean)));
    const canPairCrossSubject = () => {
      if (!group1 || !group2 || group1 !== group2) return false;
      const sortedG1 = [...group1Items].sort((a, b) => Number(a.id) - Number(b.id));
      const sortedG2 = [...group2Items].sort((a, b) => Number(a.id) - Number(b.id));
      const used = new Set();
      let matched = 0;
      sortedG1.forEach((left) => {
        const idx = sortedG2.findIndex((right, pos) =>
          !used.has(pos) && Number(right.subject_id) !== Number(left.subject_id)
        );
        if (idx === -1) return;
        used.add(idx);
        matched += 1;
      });
      return matched === group1;
    };
    const status = group1 && group2
      ? (group1 === group2 && canPairCrossSubject() ? 'ok' : 'warn')
      : 'missing';
    summary.push({
      key: group.raw || group.key,
      group1,
      group2,
      subjects,
      courses,
      status,
    });
  });
  summary.sort((a, b) => a.key.localeCompare(b.key));
  return summary;
};

const buildGeneratorValidation = ({
  items,
  courseMetaById,
  teacherLimits,
  config,
  locationLabel,
}) => {
  const issues = [];
  const itemIssues = {};
  const specialWeeksMode = String(config.special_weeks_mode || 'block') === 'overlay' ? 'overlay' : 'block';
  const blockedWeeksRaw = String(config.blocked_weeks || '');

  const pushIssue = (level, message, itemId) => {
    issues.push({ level, message, itemId });
    if (!itemId) return;
    if (!itemIssues[itemId]) {
      itemIssues[itemId] = { level };
    } else if (itemIssues[itemId].level !== 'error' && level === 'error') {
      itemIssues[itemId].level = 'error';
    }
  };

  if (!items.length) {
    pushIssue('error', `Немає предметів для ${locationLabel}.`);
    return { issues, itemIssues, hasCritical: true };
  }

  items.forEach((item) => {
    const meta = courseMetaById[item.course_id];
    if (!meta) {
      pushIssue('error', `Предмет "${item.subject_name}" без активного семестру.`, item.id);
      return;
    }
    const weeksCount = Number(meta.weeks_count || 0);
    if (!weeksCount) {
      pushIssue('error', `Курс "${item.subject_name}" без кількості тижнів.`, item.id);
    }
    const targetPairs = Number(item.pairs_count || 0);
    const allWeeks = weeksCount ? Array.from({ length: weeksCount }, (_, idx) => idx + 1) : [];
    let baseWeeks = allWeeks;
    if (weeksCount && specialWeeksMode === 'block') {
      const blocked = new Set(parseWeekSet(blockedWeeksRaw, weeksCount));
      baseWeeks = allWeeks.filter((week) => !blocked.has(week));
    }
    if (weeksCount && targetPairs > baseWeeks.length) {
      const maxDailyPairs = Math.max(1, Math.min(7, Number(config.max_daily_pairs || 7)));
      const allowedSlotsPerWeek = config.strict_no_evening ? Math.min(maxDailyPairs, 5) : maxDailyPairs;
      const roughCapacity = baseWeeks.length * Math.max(1, allowedSlotsPerWeek);
      if (item.fixed_class_number) {
        pushIssue(
          'warn',
          `"${item.subject_name}" має ${targetPairs} пар при фіксованому слоті: за ${baseWeeks.length} тижнів це майже точно призведе до часткової генерації.`,
          item.id
        );
      } else if (targetPairs > roughCapacity) {
        pushIssue(
          'warn',
          `"${item.subject_name}" має ${targetPairs} пар, а груба місткість за період близько ${roughCapacity} (тижні × слоти). Ймовірна часткова генерація.`,
          item.id
        );
      } else {
        pushIssue(
          'warn',
          `"${item.subject_name}" має ${targetPairs} пар на ${baseWeeks.length} тижнів: генератору доведеться ставити більше ніж 1 пару на тиждень.`,
          item.id
        );
      }
    }
    if (item.group_number && item.group_count && Number(item.group_number) > Number(item.group_count)) {
      pushIssue('error', `Група ${item.group_number} перевищує кількість груп у "${item.subject_name}".`, item.id);
    }
    const lessonType = String(item.lesson_type || '').toLowerCase();
    const seminarAllGroups = (lessonType.includes('seminar') || lessonType.includes('сем'))
      && !item.group_number
      && Number(item.group_count || 1) > 1;
    if (seminarAllGroups) {
      pushIssue('warn', `"${item.subject_name}" як семінар для "Усі групи" буде автоматично розбитий на окремі групи.`, item.id);
    }
    if (config.strict_no_evening && item.fixed_class_number && Number(item.fixed_class_number) > 5) {
      pushIssue('error', `"${item.subject_name}" має фіксований слот ${item.fixed_class_number}, але strict no-evening забороняє 6-7 пари.`, item.id);
    }
    if (item.fixed_class_number && Number(item.fixed_class_number) > Number(config.max_daily_pairs || 7)) {
      pushIssue('warn', `"${item.subject_name}" має фіксований слот поза max пар/день.`, item.id);
    }
    if (item.weeks_set && weeksCount) {
      const parsedWeeks = parseWeekSet(item.weeks_set, weeksCount);
      if (!parsedWeeks.length) {
        pushIssue('warn', `"${item.subject_name}" має некоректний набір тижнів.`, item.id);
      } else {
        const parsedSet = new Set(parsedWeeks);
        const effectiveWeeks = baseWeeks.filter((week) => parsedSet.has(week));
        if (effectiveWeeks.length < targetPairs) {
          pushIssue(
            'warn',
            `"${item.subject_name}" має менше доступних тижнів (${effectiveWeeks.length}) ніж пар (${targetPairs}).`,
            item.id
          );
        }
      }
    }
    if (item.fixed_day && meta.active_days && meta.active_days.length && !meta.active_days.includes(item.fixed_day)) {
      pushIssue('warn', `"${item.subject_name}" стоїть на день поза активними днями курсу.`, item.id);
    }
    const limit = teacherLimits[item.teacher_id] || null;
    if (limit && limit.allowed_weekdays && limit.allowed_weekdays.length) {
      if (item.fixed_day && !limit.allowed_weekdays.includes(item.fixed_day)) {
        pushIssue('error', `"${item.subject_name}" у день, коли викладач недоступний.`, item.id);
      }
      if (!item.fixed_day && meta.active_days && meta.active_days.length) {
        const overlap = meta.active_days.some((day) => limit.allowed_weekdays.includes(day));
        if (!overlap) {
          pushIssue('error', `"${item.subject_name}" не має доступних днів викладача.`, item.id);
        }
      }
    }
  });

  if (config.mirror_groups) {
    const mirrorMap = new Map();
    items.forEach((item) => {
      const key = normalizeMirrorKey(item.mirror_key);
      if (!key) return;
      if (!mirrorMap.has(key)) {
        mirrorMap.set(key, { group1: [], group2: [] });
      }
      const bucket = mirrorMap.get(key);
      if (Number(item.group_number) === 1) bucket.group1.push(item);
      if (Number(item.group_number) === 2) bucket.group2.push(item);
    });
    mirrorMap.forEach((bucket, key) => {
      if (!bucket.group1.length || !bucket.group2.length) {
        const list = [...bucket.group1, ...bucket.group2];
        list.forEach((item) => {
          pushIssue('warn', `"${item.subject_name}" дзеркало "${key}" без пари.`, item.id);
        });
      } else if (bucket.group1.length !== bucket.group2.length) {
        const list = [...bucket.group1, ...bucket.group2];
        list.forEach((item) => {
          pushIssue('warn', `"${item.subject_name}" дзеркало "${key}" має різні кількості пар.`, item.id);
        });
      }
    });
  }

  const hasCritical = issues.some((issue) => issue.level === 'error');
  return { issues, itemIssues, hasCritical };
};

const buildConflictContext = (conflicts, itemsById, courseById, courseLocationMap) => {
  const conflictDetails = { kyiv: [], munich: [] };
  const conflictItemIds = { kyiv: new Set(), munich: new Set() };
  const reasonPriority = {
    missing_course_context: 0,
    missing_weeks_count: 1,
    no_available_weeks: 2,
    no_allowed_days: 3,
    no_allowed_classes: 4,
    no_slot_found: 5,
    partial_schedule: 6,
    subject_day_mismatch: 7,
    unknown: 99,
  };
  (conflicts || []).forEach((conflict) => {
    const rawId = String(conflict.item_id || '');
    const ids = rawId
      .split('|')
      .map((id) => Number(id))
      .filter((id) => Number.isFinite(id) && id > 0);
    const items = ids.map((id) => itemsById[id]).filter(Boolean);
    const location = items.length
      ? (courseLocationMap[items[0].course_id] || 'kyiv')
      : 'kyiv';
    ids.forEach((id) => conflictItemIds[location].add(id));
    conflictDetails[location].push({
      id: rawId,
      reason: conflict.reason || 'unknown',
      subject: conflict.subject,
      scheduled: conflict.scheduled,
      target: conflict.target,
      diagnostics: conflict.diagnostics || null,
      items: items.map((item) => ({
        id: item.id,
        subject: item.subject_name,
        course: courseById[item.course_id],
        teacher: item.teacher_name,
        group: item.group_number ? `Група ${item.group_number}` : 'Усі групи',
      })),
    });
  });
  Object.values(conflictDetails).forEach((list) => {
    list.sort((a, b) => {
      const pa = Object.prototype.hasOwnProperty.call(reasonPriority, a.reason) ? reasonPriority[a.reason] : reasonPriority.unknown;
      const pb = Object.prototype.hasOwnProperty.call(reasonPriority, b.reason) ? reasonPriority[b.reason] : reasonPriority.unknown;
      if (pa !== pb) return pa - pb;
      const sa = String(a.subject || '');
      const sb = String(b.subject || '');
      return sa.localeCompare(sb, 'uk');
    });
  });
  return { conflictDetails, conflictItemIds };
};

const buildScheduleDiff = async (entries) => {
  const diff = { added: 0, updated: 0, removed: 0, unchanged: 0, overwrite: 0 };
  if (!entries || !entries.length) {
    return { diff, existing: [] };
  }
  const pairKeys = new Set();
  const courseIds = new Set();
  const semesterIds = new Set();
  entries.forEach((entry) => {
    pairKeys.add(`${entry.course_id}|${entry.semester_id}`);
    courseIds.add(Number(entry.course_id));
    semesterIds.add(Number(entry.semester_id));
  });
  const courseList = Array.from(courseIds).filter((id) => Number.isFinite(id));
  const semesterList = Array.from(semesterIds).filter((id) => Number.isFinite(id));
  if (!courseList.length || !semesterList.length) {
    return { diff, existing: [] };
  }
  const coursePlaceholders = courseList.map(() => '?').join(',');
  const semesterPlaceholders = semesterList.map(() => '?').join(',');
  const existingRows = await db.all(
    `
      SELECT se.subject_id, se.course_id, se.semester_id, se.group_number, se.day_of_week,
             se.class_number, se.week_number, se.lesson_type, s.name AS subject_name
      FROM schedule_entries se
      JOIN subjects s ON s.id = se.subject_id
      WHERE se.course_id IN (${coursePlaceholders}) AND se.semester_id IN (${semesterPlaceholders})
    `,
    [...courseList, ...semesterList]
  );
  const existing = (existingRows || []).filter((row) => pairKeys.has(`${row.course_id}|${row.semester_id}`));
  diff.overwrite = existing.length;

  const existingMap = new Map();
  existing.forEach((row) => {
    const key = `${row.course_id}|${row.semester_id}|${row.week_number}|${row.day_of_week}|${row.class_number}|${row.group_number}`;
    existingMap.set(key, row);
  });
  const generatedMap = new Map();
  entries.forEach((entry) => {
    const key = `${entry.course_id}|${entry.semester_id}|${entry.week_number}|${entry.day_of_week}|${entry.class_number}|${entry.group_number}`;
    generatedMap.set(key, entry);
  });

  generatedMap.forEach((entry, key) => {
    const prev = existingMap.get(key);
    if (!prev) {
      diff.added += 1;
      return;
    }
    const prevType = normalizeLessonType(prev.lesson_type);
    const nextType = normalizeLessonType(entry.lesson_type);
    if (Number(prev.subject_id) !== Number(entry.subject_id) || prevType !== nextType) {
      diff.updated += 1;
    } else {
      diff.unchanged += 1;
    }
  });
  existingMap.forEach((_row, key) => {
    if (!generatedMap.has(key)) {
      diff.removed += 1;
    }
  });
  return { diff, existing };
};

const writeGeneratorBackupCsv = (rows, operationId) => {
  if (!rows || !rows.length) return null;
  const backupDir = path.join(uploadsDir, 'generator-backups');
  try {
    fs.mkdirSync(backupDir, { recursive: true });
  } catch (err) {
    console.error('Failed to ensure backup directory', err);
  }
  const header = 'course_id,semester_id,subject,group_number,day_of_week,class_number,week_number,lesson_type';
  const lines = rows.map((row) =>
    [
      row.course_id,
      row.semester_id,
      row.subject_name,
      row.group_number,
      row.day_of_week,
      row.class_number,
      row.week_number,
      row.lesson_type || '',
    ]
      .map((value) => escapeCsvValue(value))
      .join(',')
  );
  const csv = [header, ...lines].join('\n');
  const filename = `schedule-backup-${operationId}.csv`;
  const filePath = path.join(backupDir, filename);
  try {
    fs.writeFileSync(filePath, csv, 'utf8');
    return { filename, path: filePath };
  } catch (err) {
    console.error('Failed to write backup CSV', err);
    return null;
  }
};

const { createRateLimiter, getClientIp } = require('./lib/rateLimit');
const {
  requireLogin,
  requireAdmin,
  requireStaff,
  requireDeanery,
} = require('./lib/auth');
const {
  daysOfWeek,
  fullWeekDays,
  studyDayLabels,
  parseDateUTC,
  isValidDateString,
  isValidTimeString,
  parseCsvText,
  getWeekDayForDate,
  getAcademicWeekForSemester,
  getDateForWeekDay,
  getDateForWeekIndex,
  getDayNameFromDate,
  formatLocalDate,
  addDays,
} = require('./lib/dateUtils');
const { generateSchedule, parseWeekSet } = require('./lib/scheduleGenerator');
const { runMigrations } = require('./lib/migrations');
const migrationCatalog = require('./migrations');

const authLimiter = createRateLimiter({
  windowMs: 60 * 1000,
  max: 8,
  keyFn: (req) => `auth:${getClientIp(req)}`,
  onLimit: (req, res) => res.redirect('/login?error=1'),
});

const registerLimiter = createRateLimiter({
  windowMs: 60 * 1000,
  max: 5,
  keyFn: (req) => `register:${getClientIp(req)}`,
  onLimit: (req, res) => res.redirect('/register?error=Too%20many%20requests'),
});

const writeLimiter = createRateLimiter({
  windowMs: 30 * 1000,
  max: 30,
  keyFn: (req) => `write:${req.session?.user?.id || getClientIp(req)}`,
});

const readLimiter = createRateLimiter({
  windowMs: 60 * 1000,
  max: 90,
  keyFn: (req) => `read:${req.session?.user?.id || getClientIp(req)}`,
});

const uploadLimiter = createRateLimiter({
  windowMs: 60 * 1000,
  max: 6,
  keyFn: (req) => `upload:${req.session?.user?.id || getClientIp(req)}`,
});

function logAction(dbRef, req, action, details) {
  const actorId = req.session.user ? req.session.user.id : null;
  const actorName = req.session.user ? req.session.user.username : null;
  const courseId = req.session && req.session.adminCourse
    ? Number(req.session.adminCourse)
    : req.session && req.session.user
    ? req.session.user.course_id || 1
    : null;
  const createdAt = new Date().toISOString();
  dbRef.run(
    'INSERT INTO history_log (actor_id, actor_name, action, details, created_at, course_id) VALUES (?, ?, ?, ?, ?, ?)',
    [actorId, actorName, action, details ? JSON.stringify(details) : null, createdAt, courseId]
  );
  broadcast('history_updated');
}

function logActivity(dbRef, req, actionType, targetType, targetId, details, courseIdOverride, semesterIdOverride) {
  const userId = req.session.user ? req.session.user.id : null;
  const userName = req.session.user ? req.session.user.username : null;
  const courseId = Number.isFinite(courseIdOverride)
    ? courseIdOverride
    : req.session && req.session.adminCourse
    ? Number(req.session.adminCourse)
    : req.session && req.session.user
    ? req.session.user.course_id || 1
    : null;
  const semesterId = Number.isFinite(semesterIdOverride) ? semesterIdOverride : null;
  const createdAt = new Date().toISOString();
  dbRef.run(
    'INSERT INTO activity_log (user_id, user_name, action_type, target_type, target_id, details, created_at, course_id, semester_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)',
    [
      userId,
      userName,
      actionType,
      targetType,
      targetId,
      details ? JSON.stringify(details) : null,
      createdAt,
      courseId,
      semesterId,
    ]
  );
}

function normalizeForensicsIp(rawValue) {
  if (rawValue === null || rawValue === undefined) return null;
  const value = String(rawValue).trim();
  if (!value) return null;
  if (value.startsWith('::ffff:')) return value.slice(7);
  if (value === '::1') return '127.0.0.1';
  return value;
}

function normalizeForensicsAgent(rawValue) {
  if (rawValue === null || rawValue === undefined) return null;
  const value = String(rawValue).trim().replace(/\s+/g, ' ');
  if (!value) return null;
  return value.slice(0, 500);
}

function normalizeForensicsToken(rawValue) {
  if (rawValue === null || rawValue === undefined) return null;
  const value = String(rawValue).trim();
  return value || null;
}

function normalizeSecurityRegistrationAlertThreshold(rawValue, fallback = DEFAULT_SETTINGS.security_registration_alert_threshold) {
  const parsed = Number(rawValue);
  if (!Number.isFinite(parsed)) return Number(fallback);
  const rounded = Math.floor(parsed);
  if (rounded < SECURITY_REGISTRATION_ALERT_THRESHOLD_MIN) return Number(fallback);
  if (rounded > SECURITY_REGISTRATION_ALERT_THRESHOLD_MAX) return SECURITY_REGISTRATION_ALERT_THRESHOLD_MAX;
  return rounded;
}

function normalizeSecurityRegistrationAlertWindowMinutes(rawValue, fallback = DEFAULT_SETTINGS.security_registration_alert_window_minutes) {
  const parsed = Number(rawValue);
  if (!Number.isFinite(parsed)) return Number(fallback);
  const rounded = Math.floor(parsed);
  if (rounded < SECURITY_REGISTRATION_ALERT_WINDOW_MINUTES_MIN) return Number(fallback);
  if (rounded > SECURITY_REGISTRATION_ALERT_WINDOW_MINUTES_MAX) return SECURITY_REGISTRATION_ALERT_WINDOW_MINUTES_MAX;
  return rounded;
}

function parseSecurityAdminIpAllowlist(rawValue) {
  const input = String(rawValue || '');
  const seen = new Set();
  const rules = [];
  input
    .split(/[\n,;]+/)
    .map((chunk) => String(chunk || '').trim())
    .filter(Boolean)
    .forEach((chunk) => {
      const cleaned = chunk.replace(/\s+/g, '').slice(0, SECURITY_ADMIN_IP_RULE_MAX_LENGTH);
      if (!cleaned) return;
      const normalized = normalizeForensicsIp(cleaned) || cleaned;
      const key = normalized.toLowerCase();
      if (seen.has(key)) return;
      seen.add(key);
      rules.push(normalized);
    });
  return rules.slice(0, SECURITY_ADMIN_IP_ALLOWLIST_LIMIT);
}

function normalizeSecurityAdminIpAllowlist(rawValue) {
  return parseSecurityAdminIpAllowlist(rawValue).join('\n');
}

function parseIpv4ToInt(rawIp) {
  const ip = String(rawIp || '').trim();
  const parts = ip.split('.');
  if (parts.length !== 4) return null;
  let acc = 0;
  for (const part of parts) {
    if (!/^\d{1,3}$/.test(part)) return null;
    const value = Number(part);
    if (!Number.isInteger(value) || value < 0 || value > 255) return null;
    acc = (acc << 8) + value;
  }
  return acc >>> 0;
}

function parseIpv4CidrRule(rawRule) {
  const value = String(rawRule || '').trim();
  const segments = value.split('/');
  if (segments.length !== 2) return null;
  const ipInt = parseIpv4ToInt(segments[0]);
  if (ipInt === null) return null;
  const prefix = Number(segments[1]);
  if (!Number.isInteger(prefix) || prefix < 0 || prefix > 32) return null;
  const mask = prefix === 0 ? 0 : ((0xffffffff << (32 - prefix)) >>> 0);
  return {
    network: ipInt & mask,
    mask,
  };
}

function isSecurityAdminIpAllowlisted(rawIp, rawAllowlist = settingsCache.security_admin_ip_allowlist) {
  const ip = normalizeForensicsIp(rawIp);
  if (!ip) return false;
  const rules = Array.isArray(rawAllowlist)
    ? rawAllowlist
    : parseSecurityAdminIpAllowlist(rawAllowlist);
  if (!rules.length) return false;
  const normalizedIp = String(ip).toLowerCase();
  const ipInt = parseIpv4ToInt(normalizedIp);
  for (const rawRule of rules) {
    const rule = String(rawRule || '').trim().toLowerCase();
    if (!rule) continue;
    if (rule === normalizedIp) return true;
    if (rule.endsWith('*')) {
      const prefix = rule.slice(0, -1);
      if (prefix && normalizedIp.startsWith(prefix)) return true;
      continue;
    }
    if (rule.includes('/')) {
      const cidr = parseIpv4CidrRule(rule);
      if (!cidr || ipInt === null) continue;
      if ((ipInt & cidr.mask) === cidr.network) return true;
    }
  }
  return false;
}

function buildForensicsDeviceFingerprint(rawValue) {
  const normalized = normalizeForensicsAgent(rawValue);
  if (!normalized) return null;
  const compact = normalized.toLowerCase();
  const browserMatch = compact.match(/(edg|chrome|safari|firefox|opr|opera|trident|msie)\/[0-9.]+/);
  const osMatch = compact.match(/(windows nt [0-9.]+|android [0-9.]+|iphone os [0-9_]+|ipad; cpu os [0-9_]+|mac os x [0-9_]+|linux)/);
  const deviceMatch = compact.match(/(mobile|tablet|desktop)/);
  const browser = browserMatch ? browserMatch[1] : 'browser';
  const os = osMatch ? osMatch[1].replace(/\s+/g, '-') : 'os';
  const device = deviceMatch ? deviceMatch[1] : 'device';
  return `${browser}|${os}|${device}`.slice(0, 180);
}

function resolveForensicsConfidence(scoreRaw) {
  const score = Number(scoreRaw || 0);
  if (score >= 110) return { key: 'high', label: 'Висока' };
  if (score >= 65) return { key: 'medium', label: 'Середня' };
  if (score >= 35) return { key: 'low', label: 'Низька' };
  return { key: 'weak', label: 'Слабка' };
}

function resolveForensicsRiskState(scoreRaw) {
  const score = Number(scoreRaw || 0);
  if (score >= 90) return { key: 'high', label: 'Високий ризик' };
  if (score >= 50) return { key: 'watch', label: 'Під наглядом' };
  if (score >= 20) return { key: 'low', label: 'Низький ризик' };
  return { key: 'clear', label: 'Ознак ризику не виявлено' };
}

const SECURITY_CASE_SCORE_WATCH = 50;
const SECURITY_CASE_SCORE_HIGH = 90;
const SECURITY_ALERT_LOOKBACK_HOURS = 72;
const SECURITY_SESSION_LIST_LIMIT = 120;
const SECURITY_DASHBOARD_RECOMPUTE_LIMIT_DEFAULT = 220;
const SECURITY_DASHBOARD_RECOMPUTE_LIMIT_MAX = 500;
const STEPUP_CODE_ROLE = 'ROLE';
const STEPUP_CODE_BULK = 'BULK';
const STEPUP_CODE_FINALIZE = 'FINALIZE';

function normalizeSecurityCaseLevel(rawLevel) {
  const normalized = String(rawLevel || '').trim().toLowerCase();
  if (normalized === 'high-risk' || normalized === 'high' || normalized === 'risk') return 'high-risk';
  if (normalized === 'watch' || normalized === 'warning') return 'watch';
  return 'normal';
}

function normalizeSecurityCaseStatus(rawStatus) {
  const normalized = String(rawStatus || '').trim().toLowerCase();
  if (normalized === 'confirmed') return 'confirmed';
  if (normalized === 'closed') return 'closed';
  return 'open';
}

function resolveSecurityCaseLevel(scoreRaw) {
  const score = Number(scoreRaw || 0);
  if (score >= SECURITY_CASE_SCORE_HIGH) {
    return { key: 'high-risk', label: 'Високий ризик' };
  }
  if (score >= SECURITY_CASE_SCORE_WATCH) {
    return { key: 'watch', label: 'Під наглядом' };
  }
  return { key: 'normal', label: 'Нормально' };
}

function normalizeRoleListForAudit(rawRoles) {
  return normalizeRoleList(Array.isArray(rawRoles) ? rawRoles : []);
}

function safeJsonParse(rawValue, fallbackValue = null) {
  if (rawValue === null || rawValue === undefined) return fallbackValue;
  if (typeof rawValue === 'object') return rawValue;
  try {
    return JSON.parse(String(rawValue));
  } catch (_) {
    return fallbackValue;
  }
}

function isStepUpPhraseValid(rawValue, expectedPhrase) {
  const expected = String(expectedPhrase || '').trim().toUpperCase();
  if (!expected) return true;
  return String(rawValue || '').trim().toUpperCase() === expected;
}

function buildGradeAuditState(gradeRow) {
  if (!gradeRow) return null;
  const score = Number(gradeRow.score);
  return {
    score: Number.isFinite(score) ? Math.round(score * 100) / 100 : null,
    teacher_comment: gradeRow.teacher_comment ? String(gradeRow.teacher_comment) : null,
    submission_status: gradeRow.submission_status ? String(gradeRow.submission_status) : null,
    graded_by: Number.isFinite(Number(gradeRow.graded_by)) ? Number(gradeRow.graded_by) : null,
    graded_at: toIsoStringSafe(gradeRow.graded_at),
    deleted_at: toIsoStringSafe(gradeRow.deleted_at),
    deleted_by: Number.isFinite(Number(gradeRow.deleted_by)) ? Number(gradeRow.deleted_by) : null,
  };
}

function computeGradeAuditHash({
  columnId,
  studentId,
  actionType,
  actorUserId,
  beforeState,
  afterState,
  previousHash,
  createdAt,
}) {
  const payload = {
    column_id: Number(columnId),
    student_id: Number(studentId),
    action_type: String(actionType || 'update'),
    actor_user_id: Number.isFinite(Number(actorUserId)) ? Number(actorUserId) : null,
    before_state: beforeState || null,
    after_state: afterState || null,
    created_at: String(createdAt || new Date().toISOString()),
  };
  const serialized = JSON.stringify(payload);
  return createHash('sha256')
    .update(`${String(previousHash || '')}|${serialized}`)
    .digest('hex');
}

async function appendJournalGradeHashAudit({
  columnId,
  studentId,
  subjectId = null,
  courseId = null,
  semesterId = null,
  actorUserId = null,
  actionType = 'grade_update',
  beforeState = null,
  afterState = null,
  note = null,
}) {
  const normalizedColumnId = Number(columnId);
  const normalizedStudentId = Number(studentId);
  if (!Number.isFinite(normalizedColumnId) || normalizedColumnId < 1) return null;
  if (!Number.isFinite(normalizedStudentId) || normalizedStudentId < 1) return null;

  let previousHash = null;
  try {
    const prevRow = await db.get(
      `
        SELECT entry_hash
        FROM journal_grade_hash_audit
        WHERE column_id = ?
          AND student_id = ?
        ORDER BY created_at DESC, id DESC
        LIMIT 1
      `,
      [normalizedColumnId, normalizedStudentId]
    );
    previousHash = prevRow && prevRow.entry_hash ? String(prevRow.entry_hash) : null;
  } catch (_) {
    previousHash = null;
  }

  const createdAt = new Date().toISOString();
  const entryHash = computeGradeAuditHash({
    columnId: normalizedColumnId,
    studentId: normalizedStudentId,
    actionType,
    actorUserId,
    beforeState,
    afterState,
    previousHash,
    createdAt,
  });

  await db.run(
    `
      INSERT INTO journal_grade_hash_audit
        (
          column_id,
          student_id,
          subject_id,
          course_id,
          semester_id,
          actor_user_id,
          action_type,
          before_state,
          after_state,
          previous_hash,
          entry_hash,
          note,
          created_at
        )
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `,
    [
      normalizedColumnId,
      normalizedStudentId,
      Number.isFinite(Number(subjectId)) ? Number(subjectId) : null,
      Number.isFinite(Number(courseId)) ? Number(courseId) : null,
      Number.isFinite(Number(semesterId)) ? Number(semesterId) : null,
      Number.isFinite(Number(actorUserId)) ? Number(actorUserId) : null,
      String(actionType || 'grade_update').trim() || 'grade_update',
      beforeState ? JSON.stringify(beforeState) : null,
      afterState ? JSON.stringify(afterState) : null,
      previousHash,
      entryHash,
      note ? String(note).slice(0, 240) : null,
      createdAt,
    ]
  );

  return entryHash;
}

function toIsoStringSafe(rawValue) {
  const parsed = new Date(rawValue);
  if (Number.isNaN(parsed.getTime())) return null;
  return parsed.toISOString();
}

const securityAlertDedupCache = new Map();
const SECURITY_ALERT_DEDUP_TTL_MS = 20 * 60 * 1000;
const SECURITY_ALERT_DEDUP_MAX_KEYS = 500;

function shouldEmitSecurityAlert(signature, nowMs = Date.now()) {
  const key = String(signature || '').trim();
  if (!key) return false;
  const prevTs = Number(securityAlertDedupCache.get(key) || 0);
  if (prevTs && nowMs - prevTs < SECURITY_ALERT_DEDUP_TTL_MS) {
    return false;
  }
  securityAlertDedupCache.set(key, nowMs);
  if (securityAlertDedupCache.size > SECURITY_ALERT_DEDUP_MAX_KEYS) {
    const cutoff = nowMs - (SECURITY_ALERT_DEDUP_TTL_MS * 2);
    for (const [cacheKey, ts] of securityAlertDedupCache.entries()) {
      if (Number(ts || 0) < cutoff) {
        securityAlertDedupCache.delete(cacheKey);
      }
    }
  }
  return true;
}

function resolveRegistrationSecurityRiskLevel(scoreRaw) {
  const score = Number(scoreRaw || 0);
  if (score >= 95) return { key: 'high', label: 'High' };
  if (score >= 55) return { key: 'medium', label: 'Medium' };
  if (score >= 28) return { key: 'low', label: 'Low' };
  return { key: 'none', label: 'None' };
}

async function evaluateRegistrationSecuritySignals({
  userId,
  ip,
  sessionId,
  deviceFingerprint,
  source = 'register_form',
  courseId = null,
}) {
  const normalizedSource = String(source || '').trim().toLowerCase() || 'register_form';
  if (normalizedSource !== 'register_form') {
    return {
      risk: { score: 0, level: 'none', label: 'None', reasons: [] },
      allowlisted: false,
      skipped: true,
    };
  }
  const normalizedIp = normalizeForensicsIp(ip);
  const normalizedSession = normalizeForensicsToken(sessionId);
  const normalizedFingerprint = normalizeForensicsToken(deviceFingerprint);
  if (!normalizedIp && !normalizedSession && !normalizedFingerprint) {
    return {
      risk: { score: 0, level: 'none', label: 'None', reasons: [] },
      allowlisted: false,
      skipped: true,
    };
  }

  const allowlist = parseSecurityAdminIpAllowlist(settingsCache.security_admin_ip_allowlist);
  const isAllowlistedIp = isSecurityAdminIpAllowlisted(normalizedIp, allowlist);
  if (isAllowlistedIp) {
    return {
      risk: {
        score: 0,
        level: 'none',
        label: 'Suppressed',
        reasons: [`IP ${normalizedIp} is in admin allowlist`],
      },
      allowlisted: true,
      skipped: true,
    };
  }

  const windowMinutes = normalizeSecurityRegistrationAlertWindowMinutes(
    settingsCache.security_registration_alert_window_minutes,
    DEFAULT_SETTINGS.security_registration_alert_window_minutes
  );
  const threshold = normalizeSecurityRegistrationAlertThreshold(
    settingsCache.security_registration_alert_threshold,
    DEFAULT_SETTINGS.security_registration_alert_threshold
  );
  const numericCourseId = Number.isFinite(Number(courseId)) ? Number(courseId) : null;

  const loadDistinctUsersCount = async (column, value) => {
    if (!value) {
      return { users_count: 0, sample_user_ids: [] };
    }
    const params = [value, windowMinutes];
    let sql = `
      SELECT
        COUNT(DISTINCT user_id)::int AS users_count,
        ARRAY_AGG(DISTINCT user_id ORDER BY user_id DESC) FILTER (WHERE user_id IS NOT NULL) AS sample_user_ids
      FROM user_registration_events
      WHERE ${column} = ?
        AND created_at::timestamptz >= NOW() - (?::int * INTERVAL '1 minute')
    `;
    if (Number.isFinite(numericCourseId)) {
      sql += ' AND (course_id IS NULL OR course_id = ?) ';
      params.push(numericCourseId);
    }
    const row = await db.get(sql, params);
    const sampleIds = Array.isArray(row?.sample_user_ids)
      ? row.sample_user_ids.map((id) => Number(id)).filter((id) => Number.isFinite(id))
      : [];
    return {
      users_count: Number(row?.users_count || 0),
      sample_user_ids: sampleIds.slice(0, 12),
    };
  };

  const [ipSignal, sessionSignal, fingerprintSignal] = await Promise.all([
    loadDistinctUsersCount('ip', normalizedIp),
    loadDistinctUsersCount('session_id', normalizedSession),
    loadDistinctUsersCount('device_fingerprint', normalizedFingerprint),
  ]);

  let score = 0;
  const reasons = [];
  if (normalizedIp && ipSignal.users_count >= threshold) {
    score += 44 + Math.max(0, (ipSignal.users_count - threshold) * 6);
    reasons.push(`IP reused by ${ipSignal.users_count} accounts in ${windowMinutes}m`);
  }
  if (normalizedSession && sessionSignal.users_count >= 2) {
    score += 62 + Math.max(0, (sessionSignal.users_count - 2) * 8);
    reasons.push(`Session reused by ${sessionSignal.users_count} accounts`);
  }
  if (normalizedFingerprint && fingerprintSignal.users_count >= threshold) {
    score += 30 + Math.max(0, (fingerprintSignal.users_count - threshold) * 5);
    reasons.push(`Fingerprint reused by ${fingerprintSignal.users_count} accounts`);
  }
  if (reasons.length >= 2) {
    score += 12;
  }
  const risk = resolveRegistrationSecurityRiskLevel(score);
  const shouldAlert = risk.key === 'high' || risk.key === 'medium';
  if (!shouldAlert) {
    return {
      risk: {
        score,
        level: risk.key,
        label: risk.label,
        reasons: reasons.slice(0, 4),
      },
      allowlisted: false,
      skipped: false,
    };
  }
  const signature = [
    'registration-pattern',
    normalizedIp || '-',
    normalizedSession || '-',
    normalizedFingerprint || '-',
    String(risk.key),
  ].join('|');
  if (!shouldEmitSecurityAlert(signature)) {
    return {
      risk: {
        score,
        level: risk.key,
        label: risk.label,
        reasons: reasons.slice(0, 4),
      },
      allowlisted: false,
      skipped: false,
      deduped: true,
    };
  }

  const signalPayload = {
    user_id: Number(userId) || null,
    ip: normalizedIp || null,
    session_id: normalizedSession || null,
    device_fingerprint: normalizedFingerprint || null,
    score,
    threshold,
    window_minutes: windowMinutes,
    counts: {
      ip_users: Number(ipSignal.users_count || 0),
      session_users: Number(sessionSignal.users_count || 0),
      fingerprint_users: Number(fingerprintSignal.users_count || 0),
    },
    sample_user_ids: Array.from(new Set([
      ...(ipSignal.sample_user_ids || []),
      ...(sessionSignal.sample_user_ids || []),
      ...(fingerprintSignal.sample_user_ids || []),
    ])).filter((id) => Number(id) !== Number(userId)).slice(0, 12),
  };
  const message = `Registration anomaly: ${reasons.slice(0, 3).join(' | ') || 'multi-account pattern'}`;
  await emitSecurityAlertEvent({
    alertKey: 'registration-anomaly',
    severity: risk.key === 'high' ? 'high' : 'medium',
    title: 'Registration anomaly detected',
    message,
    userId: Number(userId) || null,
    courseId: Number.isFinite(numericCourseId) ? numericCourseId : null,
    details: signalPayload,
    dedupKey: `registration|${normalizedIp || '-'}|${normalizedSession || '-'}|${normalizedFingerprint || '-'}|${risk.key}`,
  });
  return {
    risk: {
      score,
      level: risk.key,
      label: risk.label,
      reasons: reasons.slice(0, 4),
    },
    allowlisted: false,
    skipped: false,
    alerted: true,
  };
}

async function recordUserRegistrationEvent({ userId, fullName, ip, userAgent, sessionId, source = 'register_form', courseId = null }) {
  const normalizedUserId = Number(userId);
  if (!Number.isFinite(normalizedUserId) || normalizedUserId <= 0) return null;
  const normalizedName = String(fullName || '').trim() || `User ${normalizedUserId}`;
  const normalizedIp = normalizeForensicsIp(ip);
  const normalizedAgent = normalizeForensicsAgent(userAgent);
  const normalizedSessionId = String(sessionId || '').trim() || null;
  const normalizedSource = ['register_form', 'import', 'admin_create'].includes(String(source))
    ? String(source)
    : 'register_form';
  await db.run(
    `
      INSERT INTO user_registration_events (
        user_id,
        full_name,
        ip,
        user_agent,
        device_fingerprint,
        session_id,
        source,
        course_id,
        created_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, NOW())
    `,
    [
      normalizedUserId,
      normalizedName,
      normalizedIp,
      normalizedAgent,
      buildForensicsDeviceFingerprint(normalizedAgent),
      normalizedSessionId,
      normalizedSource,
      Number.isFinite(Number(courseId)) ? Number(courseId) : null,
    ]
  );
  let evaluation = null;
  try {
    evaluation = await evaluateRegistrationSecuritySignals({
      userId: normalizedUserId,
      ip: normalizedIp,
      sessionId: normalizedSessionId,
      deviceFingerprint: buildForensicsDeviceFingerprint(normalizedAgent),
      source: normalizedSource,
      courseId: Number.isFinite(Number(courseId)) ? Number(courseId) : null,
    });
  } catch (err) {
    console.error('Database error (register.security_signals)', err);
  }
  return {
    user_id: normalizedUserId,
    ip: normalizedIp,
    session_id: normalizedSessionId,
    device_fingerprint: buildForensicsDeviceFingerprint(normalizedAgent),
    source: normalizedSource,
    course_id: Number.isFinite(Number(courseId)) ? Number(courseId) : null,
    security: evaluation,
  };
}

function normalizeSecurityAlertSeverity(rawSeverity) {
  const normalized = String(rawSeverity || '').trim().toLowerCase();
  if (['critical', 'high', 'medium', 'low'].includes(normalized)) {
    return normalized;
  }
  return 'medium';
}

function trimSecurityText(rawValue, maxLength = 240) {
  const text = String(rawValue || '').trim();
  if (!text) return '';
  if (text.length <= maxLength) return text;
  return `${text.slice(0, maxLength - 3)}...`;
}

async function emitSecurityAlertEvent({
  alertKey,
  severity = 'medium',
  title,
  message,
  userId = null,
  courseId = null,
  details = null,
  dedupKey = null,
}) {
  const normalizedAlertKey = String(alertKey || '').trim().toLowerCase() || 'security-alert';
  const normalizedSeverity = normalizeSecurityAlertSeverity(severity);
  const normalizedTitle = trimSecurityText(title || normalizedAlertKey, 120) || normalizedAlertKey;
  const normalizedMessage = trimSecurityText(message || normalizedTitle, 500) || normalizedTitle;
  const normalizedDedupKey = String(dedupKey || '').trim();
  const alertSignature = normalizedDedupKey
    ? `alert|${normalizedDedupKey}`
    : '';
  if (alertSignature && !shouldEmitSecurityAlert(alertSignature)) {
    return { deduped: true };
  }

  let insertedId = null;
  let createdAt = new Date().toISOString();
  const payload = details && typeof details === 'object' ? details : {};
  try {
    const row = await db.get(
      `
        INSERT INTO security_alert_events
          (
            user_id,
            course_id,
            alert_key,
            severity,
            title,
            message,
            details,
            dedup_key,
            created_at
          )
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, NOW())
        RETURNING id, created_at
      `,
      [
        Number.isFinite(Number(userId)) ? Number(userId) : null,
        Number.isFinite(Number(courseId)) ? Number(courseId) : null,
        normalizedAlertKey,
        normalizedSeverity,
        normalizedTitle,
        normalizedMessage,
        Object.keys(payload).length ? JSON.stringify(payload) : null,
        normalizedDedupKey || null,
      ]
    );
    insertedId = row && row.id ? Number(row.id) : null;
    if (row && row.created_at) {
      createdAt = toIsoStringSafe(row.created_at) || createdAt;
    }
  } catch (err) {
    console.error('Database error (security.alert.insert)', err);
  }

  pushRuntimeErrorEvent('security', normalizedAlertKey, normalizedMessage, {
    user_id: Number.isFinite(Number(userId)) ? Number(userId) : null,
    course_id: Number.isFinite(Number(courseId)) ? Number(courseId) : null,
    severity: normalizedSeverity,
    details: payload,
  });
  broadcast('security_alert', {
    id: insertedId,
    alert_key: normalizedAlertKey,
    severity: normalizedSeverity,
    title: normalizedTitle,
    message: normalizedMessage,
    created_at: createdAt,
    user_id: Number.isFinite(Number(userId)) ? Number(userId) : null,
    course_id: Number.isFinite(Number(courseId)) ? Number(courseId) : null,
  });

  return {
    id: insertedId,
    alert_key: normalizedAlertKey,
    severity: normalizedSeverity,
    title: normalizedTitle,
    message: normalizedMessage,
    created_at: createdAt,
  };
}

async function getUserRoleSnapshot(userId, fallbackRole = 'student') {
  const normalizedUserId = Number(userId);
  const fallback = normalizeRoleKey(fallbackRole || 'student');
  if (!Number.isFinite(normalizedUserId) || normalizedUserId < 1) {
    return { role_keys: [fallback], primary_role: fallback };
  }
  const [userRow, assignment] = await Promise.all([
    db.get('SELECT role FROM users WHERE id = ? LIMIT 1', [normalizedUserId]),
    getUserRoleAssignmentsForUserIds([normalizedUserId]),
  ]);
  const roleKeys = normalizeRoleList(
    (assignment && assignment.roleKeysByUser && assignment.roleKeysByUser[normalizedUserId])
      || [normalizeRoleKey((userRow && userRow.role) || fallback)]
  );
  const primaryRole = normalizeRoleKey(
    (assignment && assignment.primaryRoleByUser && assignment.primaryRoleByUser[normalizedUserId])
    || (userRow && userRow.role)
    || roleKeys[0]
    || fallback
  );
  return {
    role_keys: roleKeys.length ? roleKeys : [fallback],
    primary_role: primaryRole || fallback,
  };
}

async function recordUserRoleChangeEvent({
  userId,
  actorUserId = null,
  actorName = null,
  courseId = null,
  source = 'admin_users_roles',
  reason = null,
  beforeRoles = [],
  afterRoles = [],
  beforePrimaryRole = null,
  afterPrimaryRole = null,
  targetFullName = null,
}) {
  const normalizedUserId = Number(userId);
  if (!Number.isFinite(normalizedUserId) || normalizedUserId < 1) return null;
  const normalizedBefore = normalizeRoleListForAudit(beforeRoles);
  const normalizedAfter = normalizeRoleListForAudit(afterRoles);
  const normalizedBeforePrimary = normalizeRoleKey(beforePrimaryRole || normalizedBefore[0] || 'student');
  const normalizedAfterPrimary = normalizeRoleKey(afterPrimaryRole || normalizedAfter[0] || 'student');
  const beforeKey = `${normalizedBefore.join(',')}|${normalizedBeforePrimary}`;
  const afterKey = `${normalizedAfter.join(',')}|${normalizedAfterPrimary}`;
  if (beforeKey === afterKey) return null;

  const normalizedSource = String(source || 'admin_users_roles').trim().toLowerCase();
  const normalizedReason = trimSecurityText(reason, 500) || null;
  const normalizedTargetName = trimSecurityText(targetFullName, 180) || null;

  await db.run(
    `
      INSERT INTO user_role_change_events
        (
          user_id,
          target_full_name,
          actor_user_id,
          actor_name,
          course_id,
          source,
          before_roles,
          after_roles,
          before_primary_role,
          after_primary_role,
          reason,
          created_at
        )
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())
    `,
    [
      normalizedUserId,
      normalizedTargetName,
      Number.isFinite(Number(actorUserId)) ? Number(actorUserId) : null,
      actorName ? String(actorName).trim() : null,
      Number.isFinite(Number(courseId)) ? Number(courseId) : null,
      ['admin_users_roles', 'admin_users_role', 'teacher_request_approve', 'teacher_request_reject'].includes(normalizedSource)
        ? normalizedSource
        : 'admin_users_roles',
      JSON.stringify(normalizedBefore),
      JSON.stringify(normalizedAfter),
      normalizedBeforePrimary,
      normalizedAfterPrimary,
      normalizedReason,
    ]
  );

  const elevated = ['admin', 'deanery'].some(
    (role) => normalizedAfter.includes(role) && !normalizedBefore.includes(role)
  );
  if (elevated) {
    await emitSecurityAlertEvent({
      alertKey: 'role-elevation',
      severity: 'high',
      title: 'Privileged role elevation',
      message: `${normalizedTargetName || `User ${normalizedUserId}`} отримав(ла) підвищені права`,
      userId: normalizedUserId,
      courseId: Number.isFinite(Number(courseId)) ? Number(courseId) : null,
      details: {
        before_roles: normalizedBefore,
        after_roles: normalizedAfter,
        actor_user_id: Number.isFinite(Number(actorUserId)) ? Number(actorUserId) : null,
      },
      dedupKey: `role-elevation|${normalizedUserId}|${normalizedAfter.join(',')}`,
    });
  }

  return {
    user_id: normalizedUserId,
    before_roles: normalizedBefore,
    after_roles: normalizedAfter,
    before_primary_role: normalizedBeforePrimary,
    after_primary_role: normalizedAfterPrimary,
  };
}

async function recordAuthFailureEvent({
  attemptedName,
  userId = null,
  ip = null,
  userAgent = null,
  sessionId = null,
  courseId = null,
}) {
  const normalizedName = String(attemptedName || '').trim().replace(/\s+/g, ' ');
  const normalizedIp = normalizeForensicsIp(ip);
  const normalizedAgent = normalizeForensicsAgent(userAgent);
  const normalizedSessionId = normalizeForensicsToken(sessionId);
  const normalizedUserId = Number.isFinite(Number(userId)) ? Number(userId) : null;
  const normalizedCourseId = Number.isFinite(Number(courseId)) ? Number(courseId) : null;
  const normalizedNameKey = normalizedName.toLowerCase();
  await db.run(
    `
      INSERT INTO auth_failure_events
        (
          attempted_full_name,
          normalized_full_name,
          user_id,
          ip,
          user_agent,
          session_id,
          source,
          course_id,
          created_at
        )
      VALUES (?, ?, ?, ?, ?, ?, 'login', ?, NOW())
    `,
    [
      normalizedName || null,
      normalizedNameKey || null,
      normalizedUserId,
      normalizedIp,
      normalizedAgent,
      normalizedSessionId,
      normalizedCourseId,
    ]
  );

  if (normalizedIp && !isSecurityAdminIpAllowlisted(normalizedIp)) {
    const ipBurstRow = await db.get(
      `
        SELECT COUNT(*)::int AS count, COUNT(DISTINCT COALESCE(user_id, -id))::int AS actors_count
        FROM auth_failure_events
        WHERE ip = ?
          AND created_at::timestamptz >= NOW() - INTERVAL '10 minutes'
      `,
      [normalizedIp]
    );
    const burstCount = Number(ipBurstRow && ipBurstRow.count ? ipBurstRow.count : 0);
    if (burstCount >= 10) {
      await emitSecurityAlertEvent({
        alertKey: 'auth-failure-ip-burst',
        severity: 'high',
        title: 'Mass failed logins from one IP',
        message: `${normalizedIp}: ${burstCount} невдалих логінів за 10 хв`,
        userId: normalizedUserId,
        courseId: normalizedCourseId,
        details: {
          ip: normalizedIp,
          failures_10m: burstCount,
        },
        dedupKey: `auth-failure-ip|${normalizedIp}|${Math.floor(Date.now() / (10 * 60 * 1000))}`,
      });
    }
  }

  if (normalizedUserId) {
    const userFailureRow = await db.get(
      `
        SELECT
          COUNT(*) FILTER (WHERE created_at::timestamptz >= NOW() - INTERVAL '24 hours')::int AS failed_24h,
          COUNT(*) FILTER (WHERE created_at::timestamptz >= NOW() - INTERVAL '7 days')::int AS failed_7d
        FROM auth_failure_events
        WHERE user_id = ?
      `,
      [normalizedUserId]
    );
    const failed24h = Number(userFailureRow && userFailureRow.failed_24h ? userFailureRow.failed_24h : 0);
    if (failed24h >= 6) {
      await emitSecurityAlertEvent({
        alertKey: 'auth-failure-user-spike',
        severity: 'medium',
        title: 'User login failures spike',
        message: `${normalizedName || `User ${normalizedUserId}`}: ${failed24h} невдалих входів за 24г`,
        userId: normalizedUserId,
        courseId: normalizedCourseId,
        details: {
          failed_24h: failed24h,
          failed_7d: Number(userFailureRow && userFailureRow.failed_7d ? userFailureRow.failed_7d : 0),
        },
        dedupKey: `auth-failure-user|${normalizedUserId}|${Math.floor(Date.now() / (60 * 60 * 1000))}`,
      });
    }
    try {
      await recomputeUserSecurityCase(normalizedUserId, {
        allowAutoQuarantine: false,
        courseId: normalizedCourseId,
      });
    } catch (err) {
      console.error('Database error (security_case.auth_failure_recompute)', err);
    }
  }
}

function parseSessionPayload(rawSession) {
  if (rawSession === null || rawSession === undefined) return null;
  if (typeof rawSession === 'object') return rawSession;
  return safeJsonParse(rawSession, null);
}

function getSessionUserId(payload) {
  if (!payload || typeof payload !== 'object') return null;
  const directId = Number(payload?.user?.id);
  if (Number.isFinite(directId) && directId > 0) return directId;
  return null;
}

async function listUserSessions(userId, currentSessionId = null) {
  const normalizedUserId = Number(userId);
  if (!Number.isFinite(normalizedUserId) || normalizedUserId < 1) return [];
  const sessionUserIdExpr = "CASE WHEN (sess::jsonb -> 'user' ->> 'id') ~ '^[0-9]+$' THEN (sess::jsonb -> 'user' ->> 'id')::int ELSE NULL END";
  const rows = await db.all(
    `
      SELECT sid, sess, expire
      FROM ${sessionTableName}
      WHERE ${sessionUserIdExpr} = ?
      ORDER BY expire DESC
      LIMIT ${SECURITY_SESSION_LIST_LIMIT}
    `,
    [normalizedUserId]
  );
  return (rows || []).map((row) => {
    const payload = parseSessionPayload(row.sess);
    const user = payload && payload.user && typeof payload.user === 'object' ? payload.user : {};
    const current = String(row.sid || '') === String(currentSessionId || '');
    const lastSeenAt = payload && payload.last_seen_at ? toIsoStringSafe(payload.last_seen_at) : null;
    return {
      sid: String(row.sid || ''),
      is_current: current,
      expire_at: toIsoStringSafe(row.expire),
      created_at: payload && payload.session_created_at ? toIsoStringSafe(payload.session_created_at) : null,
      last_seen_at: lastSeenAt,
      last_seen_route: payload && payload.last_seen_route ? String(payload.last_seen_route) : null,
      ip: payload && payload.last_seen_ip ? normalizeForensicsIp(payload.last_seen_ip) : null,
      user_agent: payload && payload.last_seen_user_agent ? normalizeForensicsAgent(payload.last_seen_user_agent) : null,
      remember_me: payload && typeof payload.rememberMe !== 'undefined' ? Boolean(payload.rememberMe) : null,
      user_name: user && user.username ? String(user.username) : null,
      user_id: getSessionUserId(payload),
    };
  });
}

async function revokeUserSessions(userId, { excludeSessionId = null } = {}) {
  const normalizedUserId = Number(userId);
  if (!Number.isFinite(normalizedUserId) || normalizedUserId < 1) return 0;
  const normalizedExcludeSid = String(excludeSessionId || '').trim();
  const sessionUserIdExpr = "CASE WHEN (sess::jsonb -> 'user' ->> 'id') ~ '^[0-9]+$' THEN (sess::jsonb -> 'user' ->> 'id')::int ELSE NULL END";
  const result = normalizedExcludeSid
    ? await db.run(
        `
          DELETE FROM ${sessionTableName}
          WHERE ${sessionUserIdExpr} = ?
            AND sid <> ?
        `,
        [normalizedUserId, normalizedExcludeSid]
      )
    : await db.run(
        `
          DELETE FROM ${sessionTableName}
          WHERE ${sessionUserIdExpr} = ?
        `,
        [normalizedUserId]
      );
  return Number(result && result.changes ? result.changes : 0);
}

async function recomputeUserSecurityCase(userId, options = {}) {
  const normalizedUserId = Number(userId);
  if (!Number.isFinite(normalizedUserId) || normalizedUserId < 1) return null;

  const user = await db.get(
    `
      SELECT id, full_name, role, is_active, course_id, last_login_ip, last_user_agent, last_login_at
      FROM users
      WHERE id = ?
      LIMIT 1
    `,
    [normalizedUserId]
  );
  if (!user) return null;

  const courseId = Number.isFinite(Number(options.courseId))
    ? Number(options.courseId)
    : (Number.isFinite(Number(user.course_id)) ? Number(user.course_id) : null);
  const allowlistedIp = isSecurityAdminIpAllowlisted(user.last_login_ip);
  const userFingerprint = buildForensicsDeviceFingerprint(user.last_user_agent);

  const registrationEvent = await db.get(
    `
      SELECT ip, device_fingerprint, session_id, created_at
      FROM user_registration_events
      WHERE user_id = ?
      ORDER BY created_at DESC
      LIMIT 1
    `,
    [normalizedUserId]
  );

  const userSessionRows = await db.all(
    `
      SELECT DISTINCT session_id
      FROM site_visit_events
      WHERE user_id = ?
        AND session_id IS NOT NULL
      ORDER BY session_id ASC
      LIMIT 4
    `,
    [normalizedUserId]
  );
  const userSessionIds = (userSessionRows || [])
    .map((row) => normalizeForensicsToken(row.session_id))
    .filter(Boolean);

  const userDeviceSet = new Set();
  if (userFingerprint) userDeviceSet.add(userFingerprint);
  if (registrationEvent && registrationEvent.device_fingerprint) {
    userDeviceSet.add(String(registrationEvent.device_fingerprint));
  }

  const [failureRow, roleChangeRow, alertRow, sharedIpRow, sharedSessionRow, sharedDeviceRow, loginIpRow] = await Promise.all([
    db.get(
      `
        SELECT
          COUNT(*) FILTER (WHERE created_at::timestamptz >= NOW() - INTERVAL '24 hours')::int AS failed_24h,
          COUNT(*) FILTER (WHERE created_at::timestamptz >= NOW() - INTERVAL '7 days')::int AS failed_7d
        FROM auth_failure_events
        WHERE user_id = ?
      `,
      [normalizedUserId]
    ),
    db.get(
      `
        SELECT
          COUNT(*) FILTER (WHERE created_at::timestamptz >= NOW() - INTERVAL '30 days')::int AS changes_30d,
          COUNT(*) FILTER (
            WHERE created_at::timestamptz >= NOW() - INTERVAL '30 days'
              AND EXISTS (
                SELECT 1
                FROM jsonb_array_elements_text(after_roles) AS role_key
                WHERE role_key IN ('admin', 'deanery')
              )
          )::int AS privileged_changes_30d
        FROM user_role_change_events
        WHERE user_id = ?
      `,
      [normalizedUserId]
    ),
    db.get(
      `
        SELECT COUNT(*) FILTER (
          WHERE resolved_at IS NULL
            AND created_at::timestamptz >= NOW() - (?::int * INTERVAL '1 hour')
        )::int AS open_alerts
        FROM security_alert_events
        WHERE user_id = ?
      `,
      [SECURITY_ALERT_LOOKBACK_HOURS, normalizedUserId]
    ),
    registrationEvent && registrationEvent.ip && !isSecurityAdminIpAllowlisted(registrationEvent.ip)
      ? db.get(
          `
            SELECT COUNT(DISTINCT user_id)::int AS users_count
            FROM (
              SELECT user_id
              FROM login_history
              WHERE ip = ?
                AND user_id IS NOT NULL
              UNION ALL
              SELECT user_id
              FROM user_registration_events
              WHERE ip = ?
                AND user_id IS NOT NULL
            ) src
            WHERE user_id <> ?
          `,
          [registrationEvent.ip, registrationEvent.ip, normalizedUserId]
        )
      : Promise.resolve({ users_count: 0 }),
    userSessionIds.length
      ? db.get(
          `
            SELECT COUNT(DISTINCT user_id)::int AS users_count
            FROM site_visit_events
            WHERE session_id = ANY(?::text[])
              AND user_id IS NOT NULL
              AND user_id <> ?
          `,
          [userSessionIds, normalizedUserId]
        )
      : Promise.resolve({ users_count: 0 }),
    userDeviceSet.size
      ? db.get(
          `
            SELECT COUNT(DISTINCT user_id)::int AS users_count
            FROM user_registration_events
            WHERE device_fingerprint = ANY(?::text[])
              AND user_id IS NOT NULL
              AND user_id <> ?
          `,
          [Array.from(userDeviceSet), normalizedUserId]
        )
      : Promise.resolve({ users_count: 0 }),
    user.last_login_ip && !allowlistedIp
      ? db.get(
          `
            SELECT
              COUNT(*) FILTER (WHERE created_at::timestamptz >= NOW() - INTERVAL '30 days')::int AS total_30d,
              COUNT(*) FILTER (
                WHERE created_at::timestamptz >= NOW() - INTERVAL '30 days'
                  AND ip = ?
              )::int AS ip_hits_30d
            FROM login_history
            WHERE user_id = ?
          `,
          [user.last_login_ip, normalizedUserId]
        )
      : Promise.resolve({ total_30d: 0, ip_hits_30d: 0 }),
  ]);

  let registrationIpCluster = 0;
  let registrationDeviceCluster = 0;
  if (registrationEvent && registrationEvent.created_at) {
    const createdAtIso = toIsoStringSafe(registrationEvent.created_at);
    if (createdAtIso && registrationEvent.ip && !isSecurityAdminIpAllowlisted(registrationEvent.ip)) {
      const row = await db.get(
        `
          SELECT COUNT(DISTINCT user_id)::int AS users_count
          FROM user_registration_events
          WHERE ip = ?
            AND created_at::timestamptz BETWEEN (?::timestamptz - INTERVAL '10 minutes')
                                           AND (?::timestamptz + INTERVAL '10 minutes')
        `,
        [registrationEvent.ip, createdAtIso, createdAtIso]
      );
      registrationIpCluster = Number(row && row.users_count ? row.users_count : 0);
    }
    if (createdAtIso && registrationEvent.device_fingerprint) {
      const row = await db.get(
        `
          SELECT COUNT(DISTINCT user_id)::int AS users_count
          FROM user_registration_events
          WHERE device_fingerprint = ?
            AND created_at::timestamptz BETWEEN (?::timestamptz - INTERVAL '10 minutes')
                                           AND (?::timestamptz + INTERVAL '10 minutes')
        `,
        [registrationEvent.device_fingerprint, createdAtIso, createdAtIso]
      );
      registrationDeviceCluster = Number(row && row.users_count ? row.users_count : 0);
    }
  }

  const counters = {
    failed_24h: Number(failureRow && failureRow.failed_24h ? failureRow.failed_24h : 0),
    failed_7d: Number(failureRow && failureRow.failed_7d ? failureRow.failed_7d : 0),
    role_changes_30d: Number(roleChangeRow && roleChangeRow.changes_30d ? roleChangeRow.changes_30d : 0),
    privileged_role_changes_30d: Number(roleChangeRow && roleChangeRow.privileged_changes_30d ? roleChangeRow.privileged_changes_30d : 0),
    open_alerts_72h: Number(alertRow && alertRow.open_alerts ? alertRow.open_alerts : 0),
    shared_ip_users: Number(sharedIpRow && sharedIpRow.users_count ? sharedIpRow.users_count : 0),
    shared_session_users: Number(sharedSessionRow && sharedSessionRow.users_count ? sharedSessionRow.users_count : 0),
    shared_device_users: Number(sharedDeviceRow && sharedDeviceRow.users_count ? sharedDeviceRow.users_count : 0),
    registration_ip_cluster_10m: Number(registrationIpCluster || 0),
    registration_device_cluster_10m: Number(registrationDeviceCluster || 0),
  };

  let score = Number(options.extraScore || 0);
  const reasons = Array.isArray(options.extraReasons) ? options.extraReasons.slice(0, 8) : [];
  if (counters.shared_session_users >= 1) {
    score += 48 + Math.min(24, counters.shared_session_users * 6);
    reasons.push(`Спільна session з іншими акаунтами (${counters.shared_session_users})`);
  }
  if (counters.shared_ip_users >= 2 && !allowlistedIp) {
    score += 18 + Math.min(22, (counters.shared_ip_users - 2) * 7);
    reasons.push(`IP збігається з іншими акаунтами (${counters.shared_ip_users})`);
  }
  if (counters.shared_device_users >= 2) {
    score += 20 + Math.min(24, (counters.shared_device_users - 2) * 6);
    reasons.push(`Device fingerprint збігається (${counters.shared_device_users})`);
  }
  if (counters.failed_24h >= 5) {
    score += 22;
    reasons.push(`Багато невдалих логінів за 24г (${counters.failed_24h})`);
  }
  if (counters.failed_7d >= 12) {
    score += 12;
    reasons.push(`Підвищена кількість невдалих логінів за 7д (${counters.failed_7d})`);
  }
  if (counters.privileged_role_changes_30d >= 1) {
    score += 28;
    reasons.push(`Було підвищення до привілейованої ролі (${counters.privileged_role_changes_30d})`);
  } else if (counters.role_changes_30d >= 3) {
    score += 14;
    reasons.push(`Часті зміни ролей (${counters.role_changes_30d})`);
  }
  if (counters.registration_ip_cluster_10m >= 3) {
    score += 34;
    reasons.push(`Кластер реєстрацій з одного IP за 10 хв (${counters.registration_ip_cluster_10m})`);
  }
  if (counters.registration_device_cluster_10m >= 3) {
    score += 26;
    reasons.push(`Кластер реєстрацій з одного device за 10 хв (${counters.registration_device_cluster_10m})`);
  }
  if (!allowlistedIp) {
    const total30d = Number(loginIpRow && loginIpRow.total_30d ? loginIpRow.total_30d : 0);
    const ipHits30d = Number(loginIpRow && loginIpRow.ip_hits_30d ? loginIpRow.ip_hits_30d : 0);
    const lastLoginAt = toIsoStringSafe(user.last_login_at);
    if (total30d >= 4 && ipHits30d <= 1 && lastLoginAt) {
      const lastLoginTs = new Date(lastLoginAt).getTime();
      if (Number.isFinite(lastLoginTs) && Date.now() - lastLoginTs <= (7 * 24 * 60 * 60 * 1000)) {
        score += 10;
        reasons.push('Новий IP в останній активності');
      }
    }
  }
  if (counters.open_alerts_72h > 0) {
    score += Math.min(20, counters.open_alerts_72h * 5);
    reasons.push(`Є активні security alerts (${counters.open_alerts_72h})`);
  }
  if (allowlistedIp) {
    reasons.push('IP у allowlist адміністратора (знижено чутливість)');
  }

  const resolvedLevel = resolveSecurityCaseLevel(score);
  const existingCase = await db.get(
    `
      SELECT *
      FROM user_security_cases
      WHERE user_id = ?
      LIMIT 1
    `,
    [normalizedUserId]
  );
  const existingStatus = normalizeSecurityCaseStatus(existingCase && existingCase.status ? existingCase.status : 'open');
  const shouldReopen = existingStatus === 'closed' && resolvedLevel.key === 'high-risk';
  const nextStatus = shouldReopen ? 'open' : existingStatus;

  let autoQuarantined = existingCase && existingCase.auto_quarantined
    ? (existingCase.auto_quarantined === true || Number(existingCase.auto_quarantined) === 1)
    : false;
  if (
    options.allowAutoQuarantine
    && settingsCache.security_auto_quarantine_enabled
    && resolvedLevel.key === 'high-risk'
    && Number(user.is_active) === 1
  ) {
    await db.run('UPDATE users SET is_active = 0 WHERE id = ? AND is_active = 1', [normalizedUserId]);
    autoQuarantined = true;
    broadcast('users_updated');
    await emitSecurityAlertEvent({
      alertKey: 'auto-quarantine',
      severity: 'critical',
      title: 'Account auto-quarantined',
      message: `${String(user.full_name || `User ${normalizedUserId}`)} переведено в inactive через high-risk сигнал`,
      userId: normalizedUserId,
      courseId,
      details: {
        risk_score: Math.round(score),
        reasons: reasons.slice(0, 6),
      },
      dedupKey: `auto-quarantine|${normalizedUserId}|${Math.floor(Date.now() / (60 * 60 * 1000))}`,
    });
  }

  if (existingCase) {
    await db.run(
      `
        UPDATE user_security_cases
        SET risk_score = ?,
            risk_level = ?,
            status = ?,
            reason = ?,
            reason_details = ?,
            signal_counters = ?,
            allowlisted = ?,
            auto_quarantined = ?,
            last_risk_at = NOW(),
            last_recomputed_at = NOW(),
            updated_at = NOW(),
            closed_by = CASE WHEN ? THEN NULL ELSE closed_by END,
            closed_at = CASE WHEN ? THEN NULL ELSE closed_at END
        WHERE user_id = ?
      `,
      [
        Math.round(score),
        resolvedLevel.key,
        nextStatus,
        reasons.length ? reasons.slice(0, 6).join(' · ') : null,
        reasons.length ? JSON.stringify(reasons.slice(0, 10)) : null,
        JSON.stringify(counters),
        allowlistedIp ? 1 : 0,
        autoQuarantined ? 1 : 0,
        shouldReopen ? 1 : 0,
        shouldReopen ? 1 : 0,
        normalizedUserId,
      ]
    );
  } else {
    await db.run(
      `
        INSERT INTO user_security_cases
          (
            user_id,
            risk_score,
            risk_level,
            status,
            reason,
            reason_details,
            signal_counters,
            auto_quarantined,
            allowlisted,
            last_risk_at,
            last_recomputed_at,
            created_at,
            updated_at
          )
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW(), NOW(), NOW())
      `,
      [
        normalizedUserId,
        Math.round(score),
        resolvedLevel.key,
        resolvedLevel.key === 'high-risk' ? 'open' : 'open',
        reasons.length ? reasons.slice(0, 6).join(' · ') : null,
        reasons.length ? JSON.stringify(reasons.slice(0, 10)) : null,
        JSON.stringify(counters),
        autoQuarantined ? 1 : 0,
        allowlistedIp ? 1 : 0,
      ]
    );
  }

  const updatedCase = await db.get(
    `
      SELECT
        usc.*,
        u_confirm.full_name AS confirmed_by_name,
        u_closed.full_name AS closed_by_name
      FROM user_security_cases usc
      LEFT JOIN users u_confirm ON u_confirm.id = usc.confirmed_by
      LEFT JOIN users u_closed ON u_closed.id = usc.closed_by
      WHERE usc.user_id = ?
      LIMIT 1
    `,
    [normalizedUserId]
  );

  return {
    user_id: normalizedUserId,
    score: Math.round(score),
    level: resolvedLevel.key,
    label: resolvedLevel.label,
    reasons: reasons.slice(0, 10),
    counters,
    allowlisted: allowlistedIp,
    case: updatedCase,
  };
}

async function getUserSecurityCaseWithActors(userId) {
  const normalizedUserId = Number(userId);
  if (!Number.isFinite(normalizedUserId) || normalizedUserId < 1) return null;
  return db.get(
    `
      SELECT
        usc.*,
        u_confirm.full_name AS confirmed_by_name,
        u_closed.full_name AS closed_by_name
      FROM user_security_cases usc
      LEFT JOIN users u_confirm ON u_confirm.id = usc.confirmed_by
      LEFT JOIN users u_closed ON u_closed.id = usc.closed_by
      WHERE usc.user_id = ?
      LIMIT 1
    `,
    [normalizedUserId]
  );
}

function buildForensicsGraphPayload(targetUser, evidence = {}, matches = []) {
  const nodes = [];
  const edges = [];
  const seenNodes = new Set();
  const addNode = (id, type, label, meta = {}) => {
    const key = String(id || '').trim();
    if (!key || seenNodes.has(key)) return;
    seenNodes.add(key);
    nodes.push({
      id: key,
      type,
      label: String(label || key),
      ...meta,
    });
  };
  const addEdge = (from, to, relation) => {
    const source = String(from || '').trim();
    const target = String(to || '').trim();
    if (!source || !target || source === target) return;
    edges.push({
      from: source,
      to: target,
      relation: String(relation || 'link'),
    });
  };

  const targetNodeId = `user:${Number(targetUser && targetUser.id ? targetUser.id : 0)}`;
  addNode(targetNodeId, 'user', targetUser && targetUser.full_name ? targetUser.full_name : 'Target', { role: targetUser && targetUser.role ? targetUser.role : 'student' });

  const ips = Array.isArray(evidence.ips) ? evidence.ips : [];
  const sessions = Array.isArray(evidence.session_ids) ? evidence.session_ids : [];
  const devices = Array.isArray(evidence.device_fingerprints) ? evidence.device_fingerprints : [];
  ips.slice(0, 8).forEach((ip) => {
    const id = `ip:${ip}`;
    addNode(id, 'ip', ip);
    addEdge(targetNodeId, id, 'ip');
  });
  sessions.slice(0, 8).forEach((sessionId) => {
    const id = `session:${sessionId}`;
    addNode(id, 'session', sessionId.length > 14 ? `${sessionId.slice(0, 12)}...` : sessionId);
    addEdge(targetNodeId, id, 'session');
  });
  devices.slice(0, 8).forEach((fingerprint) => {
    const id = `device:${fingerprint}`;
    addNode(id, 'device', fingerprint.length > 26 ? `${fingerprint.slice(0, 24)}...` : fingerprint);
    addEdge(targetNodeId, id, 'device');
  });

  (Array.isArray(matches) ? matches : []).slice(0, 8).forEach((match) => {
    const userId = Number(match && match.user_id ? match.user_id : 0);
    if (!Number.isFinite(userId) || userId < 1) return;
    const matchNodeId = `user:${userId}`;
    addNode(matchNodeId, 'user', match.full_name || `User ${userId}`, {
      role: match.role || 'student',
      score: Number(match.score || 0),
    });
    addEdge(targetNodeId, matchNodeId, 'suspected-link');
    (Array.isArray(match.ip_hits) ? match.ip_hits : []).slice(0, 4).forEach((ip) => {
      const id = `ip:${ip}`;
      addNode(id, 'ip', ip);
      addEdge(matchNodeId, id, 'ip');
    });
    (Array.isArray(match.session_hits) ? match.session_hits : []).slice(0, 4).forEach((sessionId) => {
      const id = `session:${sessionId}`;
      addNode(id, 'session', sessionId.length > 14 ? `${sessionId.slice(0, 12)}...` : sessionId);
      addEdge(matchNodeId, id, 'session');
    });
  });

  return {
    nodes: nodes.slice(0, 60),
    edges: edges.slice(0, 120),
  };
}

function applyRememberMe(req, remember) {
  const ttlMs = resolveSessionTtlMs(settingsCache.session_duration_days);
  if (remember) {
    req.session.cookie.maxAge = ttlMs;
  } else {
    req.session.cookie.expires = false;
    req.session.cookie.maxAge = null;
  }
}

const ACTIVITY_POINTS_CASE =
  "CASE WHEN action_type = 'homework_create' THEN 1 " +
  "WHEN action_type = 'teamwork_task_create' THEN 2 " +
  "WHEN action_type = 'teamwork_group_create' THEN 1 " +
  "WHEN action_type = 'activity_points_adjust' THEN COALESCE((details::jsonb ->> 'delta')::numeric, 0) " +
  "ELSE 0 END";

const VISIT_DAY_OPTIONS = new Set([7, 14, 30, 60, 90]);
const VISIT_DEDUP_WINDOW_MS = 10000;
const VISIT_CLEANUP_INTERVAL_MS = 6 * 60 * 60 * 1000;
const VISIT_DEDUP_MAX_KEYS = 5000;
const VISIT_RETENTION_DAYS = SITE_VISIT_RETENTION_DAYS_DEFAULT;
const LOGIN_HISTORY_RETENTION_DAYS = LOGIN_HISTORY_RETENTION_DAYS_DEFAULT;
const ACTIVITY_LOG_RETENTION_DAYS = ACTIVITY_LOG_RETENTION_DAYS_DEFAULT;
const visitDedupCache = new Map();
let visitCleanupInFlight = false;
let visitLastCleanupAt = 0;

const parseVisitDays = (rawValue) => {
  const parsed = Number(rawValue);
  if (!Number.isFinite(parsed)) return 14;
  const normalized = Math.floor(parsed);
  return VISIT_DAY_OPTIONS.has(normalized) ? normalized : 14;
};

const parseVisitExcludeAdmin = (rawValue) => {
  if (rawValue === undefined || rawValue === null || rawValue === '') return true;
  const normalized = String(rawValue).trim().toLowerCase();
  return normalized === '1' || normalized === 'true' || normalized === 'yes' || normalized === 'on';
};

const buildVisitDayLabels = (days) => {
  const normalizedDays = parseVisitDays(days);
  const end = new Date();
  end.setHours(0, 0, 0, 0);
  const labels = [];
  for (let offset = normalizedDays - 1; offset >= 0; offset -= 1) {
    const d = new Date(end);
    d.setDate(end.getDate() - offset);
    labels.push(d.toISOString().slice(0, 10));
  }
  return labels;
};

const resolveVisitPageKey = (pathname) => {
  const normalized = String(pathname || '').trim();
  if (!normalized) return null;
  if (normalized === '/' || normalized === '/login') return 'login';
  if (normalized.startsWith('/register')) return 'register';
  if (normalized.startsWith('/schedule')) return 'schedule';
  if (normalized.startsWith('/my-day')) return 'my-day';
  if (normalized.startsWith('/teamwork')) return 'teamwork';
  if (normalized.startsWith('/profile')) return 'profile';
  if (normalized.startsWith('/admin')) return 'admin';
  if (normalized.startsWith('/deanery')) return 'deanery';
  if (normalized.startsWith('/starosta')) return 'starosta';
  if (normalized.startsWith('/teacher')) return 'teacher';
  if (normalized.startsWith('/subjects')) return 'subjects';
  if (normalized.startsWith('/journal')) return 'journal';
  return null;
};

const shouldTrackVisitRequest = (req) => {
  if (!req || req.method !== 'GET') return false;
  const pathname = String(req.path || '');
  const pageKey = resolveVisitPageKey(pathname);
  if (!pageKey) return false;
  const accept = String(req.get('accept') || '').toLowerCase();
  if (accept && !accept.includes('text/html') && !accept.includes('*/*')) {
    return false;
  }
  return true;
};

const trimVisitDedupCache = (nowMs) => {
  if (visitDedupCache.size <= VISIT_DEDUP_MAX_KEYS) return;
  const cutoff = nowMs - VISIT_DEDUP_WINDOW_MS * 8;
  for (const [key, value] of visitDedupCache.entries()) {
    if (value < cutoff) {
      visitDedupCache.delete(key);
    }
  }
  if (visitDedupCache.size <= VISIT_DEDUP_MAX_KEYS) return;
  const overflow = visitDedupCache.size - VISIT_DEDUP_MAX_KEYS;
  const keys = Array.from(visitDedupCache.keys());
  for (let i = 0; i < overflow; i += 1) {
    visitDedupCache.delete(keys[i]);
  }
};

const shouldSkipVisitDuplicate = (req, pageKey, routePath) => {
  const userId = Number(req?.session?.user?.id);
  const sessionId = req?.sessionID || '';
  const ip = req?.ip || '';
  const dedupActorKey = Number.isFinite(userId) && userId > 0
    ? `u:${userId}`
    : (sessionId ? `s:${sessionId}` : `ip:${ip}`);
  const dedupKey = `${dedupActorKey}:${pageKey}:${routePath}`;
  const nowMs = Date.now();
  const lastSeen = Number(visitDedupCache.get(dedupKey) || 0);
  visitDedupCache.set(dedupKey, nowMs);
  trimVisitDedupCache(nowMs);
  return lastSeen > 0 && (nowMs - lastSeen) < VISIT_DEDUP_WINDOW_MS;
};

const resolveVisitCourseId = (req, routePath) => {
  const isStaffRoute = routePath.startsWith('/admin')
    || routePath.startsWith('/deanery')
    || routePath.startsWith('/starosta');
  if (isStaffRoute) {
    const queryCourse = Number(req?.query?.course);
    if (Number.isFinite(queryCourse) && queryCourse > 0) {
      return queryCourse;
    }
    const selectedCourse = Number(req?.session?.adminCourse);
    if (Number.isFinite(selectedCourse) && selectedCourse > 0) {
      return selectedCourse;
    }
    if (hasSessionRole(req, 'admin')) {
      const adminCourse = Number(getAdminCourse(req));
      if (Number.isFinite(adminCourse) && adminCourse > 0) {
        return adminCourse;
      }
    }
    if (hasSessionRole(req, 'deanery') || hasSessionRole(req, 'starosta')) {
      const staffCourse = Number(getStaffCourse(req));
      if (Number.isFinite(staffCourse) && staffCourse > 0) {
        return staffCourse;
      }
    }
  }
  const sessionCourse = Number(req?.session?.user?.course_id);
  if (Number.isFinite(sessionCourse) && sessionCourse > 0) return sessionCourse;
  return null;
};

const maybeCleanupVisitEvents = async () => {
  const nowMs = Date.now();
  if (visitCleanupInFlight) return;
  if ((nowMs - visitLastCleanupAt) < VISIT_CLEANUP_INTERVAL_MS) return;
  visitCleanupInFlight = true;
  visitLastCleanupAt = nowMs;
  const visitRetentionDays = normalizeRetentionDays(settingsCache.site_visit_retention_days, VISIT_RETENTION_DAYS);
  const loginHistoryRetentionDays = normalizeRetentionDays(
    settingsCache.login_history_retention_days,
    LOGIN_HISTORY_RETENTION_DAYS
  );
  const activityLogRetentionDays = normalizeRetentionDays(
    settingsCache.activity_log_retention_days,
    ACTIVITY_LOG_RETENTION_DAYS
  );
  const securityIpRetentionDays = normalizeRetentionDays(
    settingsCache.security_ip_retention_days,
    SECURITY_IP_RETENTION_DAYS_DEFAULT
  );
  const securityUserAgentRetentionDays = normalizeRetentionDays(
    settingsCache.security_user_agent_retention_days,
    SECURITY_USER_AGENT_RETENTION_DAYS_DEFAULT
  );
  try {
    await db.run(
      "DELETE FROM site_visit_events WHERE created_at < NOW() - (?::int * INTERVAL '1 day')",
      [visitRetentionDays]
    );
  } catch (err) {
    console.error('Database error (visit.cleanup.events)', err);
  }
  try {
    await db.run(
      "DELETE FROM login_history WHERE created_at::timestamp < NOW() - (?::int * INTERVAL '1 day')",
      [loginHistoryRetentionDays]
    );
  } catch (err) {
    console.error('Database error (visit.cleanup.login_history)', err);
  }
  try {
    await db.run(
      "DELETE FROM activity_log WHERE created_at::timestamp < NOW() - (?::int * INTERVAL '1 day')",
      [activityLogRetentionDays]
    );
  } catch (err) {
    console.error('Database error (visit.cleanup.activity_log)', err);
  }
  try {
    await Promise.all([
      db.run(
        "UPDATE site_visit_events SET ip = NULL WHERE ip IS NOT NULL AND created_at < NOW() - (?::int * INTERVAL '1 day')",
        [securityIpRetentionDays]
      ),
      db.run(
        "UPDATE login_history SET ip = NULL WHERE ip IS NOT NULL AND created_at::timestamp < NOW() - (?::int * INTERVAL '1 day')",
        [securityIpRetentionDays]
      ),
      db.run(
        "UPDATE user_registration_events SET ip = NULL WHERE ip IS NOT NULL AND created_at < NOW() - (?::int * INTERVAL '1 day')",
        [securityIpRetentionDays]
      ),
      db.run(
        "UPDATE auth_failure_events SET ip = NULL WHERE ip IS NOT NULL AND created_at < NOW() - (?::int * INTERVAL '1 day')",
        [securityIpRetentionDays]
      ),
      db.run(
        "UPDATE users SET last_login_ip = NULL WHERE last_login_ip IS NOT NULL AND last_login_at < NOW() - (?::int * INTERVAL '1 day')",
        [securityIpRetentionDays]
      ),
    ]);
  } catch (err) {
    console.error('Database error (visit.cleanup.security_ip)', err);
  }
  try {
    await Promise.all([
      db.run(
        "UPDATE site_visit_events SET user_agent = NULL WHERE user_agent IS NOT NULL AND created_at < NOW() - (?::int * INTERVAL '1 day')",
        [securityUserAgentRetentionDays]
      ),
      db.run(
        "UPDATE login_history SET user_agent = NULL WHERE user_agent IS NOT NULL AND created_at::timestamp < NOW() - (?::int * INTERVAL '1 day')",
        [securityUserAgentRetentionDays]
      ),
      db.run(
        "UPDATE user_registration_events SET user_agent = NULL WHERE user_agent IS NOT NULL AND created_at < NOW() - (?::int * INTERVAL '1 day')",
        [securityUserAgentRetentionDays]
      ),
      db.run(
        "UPDATE auth_failure_events SET user_agent = NULL WHERE user_agent IS NOT NULL AND created_at < NOW() - (?::int * INTERVAL '1 day')",
        [securityUserAgentRetentionDays]
      ),
      db.run(
        "UPDATE users SET last_user_agent = NULL WHERE last_user_agent IS NOT NULL AND last_login_at < NOW() - (?::int * INTERVAL '1 day')",
        [securityUserAgentRetentionDays]
      ),
    ]);
  } catch (err) {
    console.error('Database error (visit.cleanup.security_user_agent)', err);
  } finally {
    visitCleanupInFlight = false;
  }
};

const recordSiteVisit = async (payload) => {
  if (!payload || !payload.pageKey || !payload.routePath) return;
  const userAgentRaw = String(payload.userAgent || '');
  const userAgent = userAgentRaw ? userAgentRaw.slice(0, 500) : null;
  await db.run(
    `
      INSERT INTO site_visit_events (
        user_id,
        role_key,
        course_id,
        route_path,
        page_key,
        session_id,
        ip,
        user_agent,
        created_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `,
    [
      payload.userId || null,
      payload.roleKey || null,
      payload.courseId || null,
      payload.routePath,
      payload.pageKey,
      payload.sessionId || null,
      payload.ip || null,
      userAgent,
      payload.createdAt || new Date().toISOString(),
    ]
  );
};

function handleDbError(res, err, label) {
  const message = normalizeRuntimeErrorMessage(err && err.message ? err.message : err);
  pushRuntimeErrorEvent('db', label, message);
  console.error(`Database error (${label})`, err);
  if (!res.headersSent) {
    const req = res && res.req ? res.req : null;
    const wantsJson = Boolean(req)
      && (
        String(req.get && req.get('accept') ? req.get('accept') : '').toLowerCase().includes('application/json')
        || String(req.headers && req.headers.accept ? req.headers.accept : '').toLowerCase().includes('application/json')
      );
    if (wantsJson) {
      if (process.env.DB_DEBUG === 'true') {
        return res.status(500).json({ error: `Database error (${label})`, details: message });
      }
      return res.status(500).json({ error: 'Database error' });
    }
    if (process.env.DB_DEBUG === 'true') {
      return res.status(500).send(`Database error (${label})`);
    }
    return res.status(500).send('Database error');
  }
}

function ensureUsersSchema(cb) {
  usersHasIsActive = true;
  return cb(true);
}

function getAdminCourse(req) {
  if (hasSessionRole(req, 'admin')) {
    const queryCourse = Number(req.query.course);
    if (!Number.isNaN(queryCourse) && queryCourse > 0) {
      req.session.adminCourse = queryCourse;
    }
    const sessionCourse = Number(req.session.adminCourse);
    return Number.isNaN(sessionCourse) ? 1 : sessionCourse;
  }
  const sessionCourse = Number(req?.session?.adminCourse);
  if (!Number.isNaN(sessionCourse) && sessionCourse > 0) {
    return sessionCourse;
  }
  const userCourse = Number(req?.session?.user?.course_id || 1);
  return Number.isNaN(userCourse) ? 1 : userCourse;
}

function getStaffCourse(req) {
  if (hasSessionRole(req, 'admin')) {
    return getAdminCourse(req);
  }
  const sessionCourse = Number(req?.session?.adminCourse);
  if (!Number.isNaN(sessionCourse) && sessionCourse > 0) {
    return sessionCourse;
  }
  const userCourse = Number(req?.session?.user?.course_id || 1);
  return Number.isNaN(userCourse) ? 1 : userCourse;
}

function getStaffPanelBase(req, courseId) {
  if (hasSessionRole(req, 'deanery') && !hasSessionRole(req, 'admin')) {
    return `/deanery?course=${courseId}`;
  }
  return `/admin?course=${courseId}`;
}

function normalizeAdminSettingValue(key, rawValue, fallback = DEFAULT_SETTINGS[key]) {
  if (
    key === 'allow_homework_creation'
    || key === 'allow_custom_deadlines'
    || key === 'myday_show_student_homework'
    || key === 'allow_messages'
    || key === 'security_auto_quarantine_enabled'
  ) {
    const normalized = String(rawValue).trim().toLowerCase();
    if (['1', 'true', 'on', 'yes'].includes(normalized)) return true;
    if (['0', 'false', 'off', 'no'].includes(normalized)) return false;
    return Boolean(fallback);
  }
  if (key === 'security_admin_ip_allowlist') {
    const sourceValue = rawValue === undefined || rawValue === null ? (fallback || '') : rawValue;
    return normalizeSecurityAdminIpAllowlist(sourceValue);
  }
  const parsed = Number(rawValue);
  if (!Number.isFinite(parsed) || parsed <= 0) {
    return Number(fallback || 0);
  }
  if (key === 'site_visit_retention_days') {
    return normalizeRetentionDays(parsed, DEFAULT_SETTINGS.site_visit_retention_days);
  }
  if (key === 'login_history_retention_days') {
    return normalizeRetentionDays(parsed, DEFAULT_SETTINGS.login_history_retention_days);
  }
  if (key === 'activity_log_retention_days') {
    return normalizeRetentionDays(parsed, DEFAULT_SETTINGS.activity_log_retention_days);
  }
  if (key === 'security_ip_retention_days') {
    return normalizeRetentionDays(parsed, DEFAULT_SETTINGS.security_ip_retention_days);
  }
  if (key === 'security_user_agent_retention_days') {
    return normalizeRetentionDays(parsed, DEFAULT_SETTINGS.security_user_agent_retention_days);
  }
  if (key === 'security_registration_alert_threshold') {
    return normalizeSecurityRegistrationAlertThreshold(parsed, DEFAULT_SETTINGS.security_registration_alert_threshold);
  }
  if (key === 'security_registration_alert_window_minutes') {
    return normalizeSecurityRegistrationAlertWindowMinutes(
      parsed,
      DEFAULT_SETTINGS.security_registration_alert_window_minutes
    );
  }
  return Math.round(parsed);
}

function buildSystemSettingsAuditState(source = settingsCache) {
  const snapshot = {};
  SYSTEM_SETTINGS_AUDIT_KEYS.forEach((key) => {
    snapshot[key] = normalizeAdminSettingValue(key, source ? source[key] : undefined, DEFAULT_SETTINGS[key]);
  });
  return snapshot;
}

async function persistSystemSettingsState(nextState) {
  const normalized = buildSystemSettingsAuditState(nextState || {});
  await withTransaction(async (client) => {
    for (const key of SYSTEM_SETTINGS_AUDIT_KEYS) {
      const value = normalized[key];
      await txRun(
        client,
        'INSERT INTO settings (key, value) VALUES (?, ?) ON CONFLICT (key) DO UPDATE SET value = EXCLUDED.value',
        [key, typeof value === 'boolean' ? (value ? 'true' : 'false') : String(value)]
      );
    }
  });
  await refreshSettingsCache();
  return buildSystemSettingsAuditState(settingsCache);
}

function sanitizeLegacyRolePermissions(rawPermissions = {}) {
  const allowedIds = new Set(ADMIN_SECTION_OPTIONS.map((item) => item.id));
  const nextPermissions = {};
  Object.keys(DEFAULT_ROLE_PERMISSIONS).forEach((role) => {
    const raw = rawPermissions[role];
    const list = Array.isArray(raw)
      ? raw
      : typeof raw === 'string'
        ? [raw]
        : [];
    nextPermissions[role] = list
      .map((id) => String(id))
      .filter((id) => allowedIds.has(id));
  });
  const restrictedForStaff = new Set([
    'admin-settings',
    'admin-role-access',
    'admin-users',
    'admin-students',
    'admin-import-export',
    'admin-schedule-generator',
  ]);
  ['teacher', 'student'].forEach((role) => {
    if (!nextPermissions[role]) return;
    nextPermissions[role] = nextPermissions[role].filter((id) => !restrictedForStaff.has(id));
  });
  return nextPermissions;
}

async function persistLegacyRolePermissions(nextPermissionsRaw) {
  const normalized = sanitizeLegacyRolePermissions(nextPermissionsRaw || {});
  await db.run(
    'INSERT INTO settings (key, value) VALUES (?, ?) ON CONFLICT (key) DO UPDATE SET value = EXCLUDED.value',
    ['role_permissions', JSON.stringify(normalized)]
  );
  await refreshSettingsCache();
  return sanitizeLegacyRolePermissions(settingsCache.role_permissions || normalized);
}

async function getRbacRoleStateByKey(roleKeyRaw) {
  const roleKey = String(roleKeyRaw || '').trim().toLowerCase();
  if (!roleKey) return null;
  const roleRow = await db.get(
    `
      SELECT id, key, label, description, is_system, is_active
      FROM access_roles
      WHERE key = ?
      LIMIT 1
    `,
    [roleKey]
  );
  if (!roleRow) return null;
  const [permissionRows, courseRows] = await Promise.all([
    db.all(
      `
        SELECT p.key
        FROM access_role_permissions rp
        JOIN access_permissions p ON p.id = rp.permission_id
        WHERE rp.role_id = ? AND rp.allowed = true
        ORDER BY p.key ASC
      `,
      [roleRow.id]
    ),
    db.all(
      `
        SELECT course_kind
        FROM access_role_course_access
        WHERE role_id = ? AND allowed = true
        ORDER BY course_kind ASC
      `,
      [roleRow.id]
    ),
  ]);
  return {
    key: String(roleRow.key),
    label: String(roleRow.label || ''),
    description: String(roleRow.description || ''),
    is_system: Number(roleRow.is_system) === 1 || roleRow.is_system === true,
    is_active: Number(roleRow.is_active) === 1 || roleRow.is_active === true,
    permission_keys: (permissionRows || []).map((row) => String(row.key)),
    course_kinds: (courseRows || []).map((row) => String(row.course_kind)),
  };
}

async function upsertRbacRoleState(client, state) {
  const key = String(state && state.key ? state.key : '').trim().toLowerCase();
  if (!key) {
    throw new Error('Invalid role key in snapshot');
  }
  const normalizedCourseKinds = Array.from(new Set(
    (Array.isArray(state.course_kinds) ? state.course_kinds : [])
      .map((kind) => String(kind))
      .filter((kind) => kind === 'regular' || kind === 'teacher')
  ));
  const roleCourseKinds = normalizedCourseKinds.length
    ? normalizedCourseKinds
    : (key === 'admin' ? ['regular', 'teacher'] : ['regular']);
  const requestedPermissions = Array.from(new Set(
    (Array.isArray(state.permission_keys) ? state.permission_keys : [])
      .map((permissionKey) => String(permissionKey || '').trim())
      .filter(Boolean)
  ));
  const validPermissionRows = await client.query(
    `
      SELECT key
      FROM access_permissions
      WHERE category IN ('admin_section', 'feature')
    `
  );
  const validPermissionKeys = new Set((validPermissionRows.rows || []).map((row) => String(row.key)));
  const rolePermissionKeys = requestedPermissions.filter((permissionKey) => validPermissionKeys.has(permissionKey));

  const existingRow = await client.query(
    `
      SELECT id
      FROM access_roles
      WHERE key = $1
      LIMIT 1
    `,
    [key]
  );
  let roleId = existingRow.rows && existingRow.rows[0] ? Number(existingRow.rows[0].id) : null;
  const isSystem = Boolean(state && (state.is_system === true || Number(state.is_system) === 1));
  const isActive = key === 'admin'
    ? true
    : Boolean(state && (state.is_active === true || Number(state.is_active) === 1));
  const label = String(state && state.label ? state.label : key).trim() || key;
  const description = String(state && state.description ? state.description : '').trim();

  if (Number.isFinite(roleId) && roleId > 0) {
    await client.query(
      `
        UPDATE access_roles
        SET label = $1,
            description = $2,
            is_system = $3,
            is_active = $4,
            updated_at = NOW()
        WHERE id = $5
      `,
      [label, description, isSystem, isActive, roleId]
    );
  } else {
    const inserted = await client.query(
      `
        INSERT INTO access_roles (key, label, description, is_system, is_active, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5, NOW(), NOW())
        RETURNING id
      `,
      [key, label, description, isSystem, isActive]
    );
    roleId = Number(inserted.rows[0].id);
  }

  await client.query('DELETE FROM access_role_permissions WHERE role_id = $1', [roleId]);
  if (rolePermissionKeys.length) {
    await client.query(
      `
        INSERT INTO access_role_permissions (role_id, permission_id, allowed, created_at, updated_at)
        SELECT $1, p.id, true, NOW(), NOW()
        FROM access_permissions p
        WHERE p.key = ANY($2::text[])
        ON CONFLICT (role_id, permission_id) DO NOTHING
      `,
      [roleId, rolePermissionKeys]
    );
  }

  await client.query('DELETE FROM access_role_course_access WHERE role_id = $1', [roleId]);
  await client.query(
    `
      INSERT INTO access_role_course_access (role_id, course_kind, allowed, created_at, updated_at)
      SELECT $1, kind.kind, true, NOW(), NOW()
      FROM (SELECT UNNEST($2::text[]) AS kind) kind
      ON CONFLICT (role_id, course_kind) DO NOTHING
    `,
    [roleId, roleCourseKinds]
  );
}

async function deleteRbacRoleByKey(client, roleKeyRaw) {
  const roleKey = String(roleKeyRaw || '').trim().toLowerCase();
  if (!roleKey) {
    throw new Error('Invalid role key');
  }
  const roleRow = await client.query(
    `
      SELECT id, is_system
      FROM access_roles
      WHERE key = $1
      LIMIT 1
    `,
    [roleKey]
  );
  const role = roleRow.rows && roleRow.rows[0] ? roleRow.rows[0] : null;
  if (!role) return;
  if (role.is_system === true || Number(role.is_system) === 1) {
    throw new Error('Cannot delete system role');
  }
  const usageRow = await client.query(
    `
      SELECT COUNT(*)::int AS count
      FROM user_roles
      WHERE role_id = $1
    `,
    [role.id]
  );
  if (Number(usageRow.rows[0]?.count || 0) > 0) {
    throw new Error('Role is assigned to users');
  }
  await client.query('DELETE FROM access_roles WHERE id = $1', [role.id]);
}

async function createAdminAuditEntry(req, {
  scopeKey,
  targetType,
  targetKey = null,
  summary = '',
  beforeState = null,
  afterState = null,
  operationId = null,
  courseId = null,
}) {
  const actorId = req && req.session && req.session.user ? Number(req.session.user.id) : null;
  const actorName = req && req.session && req.session.user ? String(req.session.user.username || '') : '';
  const row = await db.get(
    `
      INSERT INTO admin_change_audit
      (
        scope_key,
        target_type,
        target_key,
        summary,
        before_state,
        after_state,
        operation_id,
        created_by,
        created_by_name,
        created_at,
        course_id
      )
      VALUES (?, ?, ?, ?, ?::jsonb, ?::jsonb, ?, ?, ?, NOW(), ?)
      RETURNING id
    `,
    [
      scopeKey,
      targetType,
      targetKey || null,
      String(summary || '').trim() || null,
      beforeState == null ? null : JSON.stringify(beforeState),
      afterState == null ? null : JSON.stringify(afterState),
      operationId || null,
      Number.isFinite(actorId) ? actorId : null,
      actorName || null,
      Number.isFinite(Number(courseId)) ? Number(courseId) : null,
    ]
  );
  return row && row.id ? Number(row.id) : null;
}

async function markAdminAuditEntryRolledBack(auditId, req) {
  await db.run(
    `
      UPDATE admin_change_audit
      SET is_rolled_back = true,
          rolled_back_by = ?,
          rolled_back_at = NOW()
      WHERE id = ?
    `,
    [Number(req?.session?.user?.id || 0) || null, Number(auditId)]
  );
}

app.use((req, _res, next) => {
  if (initStatus !== 'ok') {
    return next();
  }
  if (!shouldTrackVisitRequest(req)) {
    return next();
  }
  const routePath = String(req.path || '').slice(0, 180) || '/';
  const pageKey = resolveVisitPageKey(routePath);
  if (!pageKey) {
    return next();
  }
  if (shouldSkipVisitDuplicate(req, pageKey, routePath)) {
    return next();
  }
  const userId = Number(req?.session?.user?.id);
  const roleKey = req?.session?.role ? normalizeRoleKey(req.session.role) : null;
  const courseId = resolveVisitCourseId(req, routePath);
  const payload = {
    userId: Number.isFinite(userId) && userId > 0 ? userId : null,
    roleKey,
    courseId: Number.isFinite(courseId) && courseId > 0 ? courseId : null,
    routePath,
    pageKey,
    sessionId: req.sessionID || null,
    ip: req.ip || null,
    userAgent: req.headers['user-agent'] || null,
    createdAt: new Date().toISOString(),
  };
  if (req.session && payload.userId) {
    if (!req.session.session_created_at) {
      req.session.session_created_at = payload.createdAt;
    }
    req.session.last_seen_at = payload.createdAt;
    req.session.last_seen_route = payload.routePath;
    req.session.last_seen_ip = normalizeForensicsIp(getClientIp(req));
    req.session.last_seen_user_agent = normalizeForensicsAgent(req.headers['user-agent'] || null);
  }
  recordSiteVisit(payload).catch((err) => {
    console.error('Database error (visit.insert)', err);
  });
  maybeCleanupVisitEvents().catch((err) => {
    console.error('Database error (visit.cleanup.background)', err);
  });
  return next();
});

async function getActiveSemester(courseId) {
  const cached = cacheGet(referenceCache.activeSemester, courseId);
  if (cached) return cached;
  const row = await db.get(
    `
      SELECT id, title, start_date, weeks_count, is_active, is_archived
      FROM semesters
      WHERE course_id = ?
        AND COALESCE(LOWER(TRIM(CAST(is_active AS TEXT))), '0') IN ('1', 'true', 't')
      ORDER BY id DESC
      LIMIT 1
    `,
    [courseId]
  );
  return cacheSet(referenceCache.activeSemester, courseId, row || null);
}

async function ensureCourseStudyDays(courseId) {
  const existing = await db.get('SELECT COUNT(*) AS count FROM course_study_days WHERE course_id = ?', [courseId]);
  if (existing && Number(existing.count) > 0) return;
  const now = new Date().toISOString();
  const inserts = [];
  for (let i = 1; i <= 7; i += 1) {
    const isActive = i <= 5 ? 1 : 0;
    inserts.push(
      db.run(
        `INSERT INTO course_study_days (course_id, weekday, is_active, created_at, updated_at)
         VALUES (?, ?, ?, ?, ?) ON CONFLICT(course_id, weekday) DO NOTHING`,
        [courseId, i, isActive, now, now]
      )
    );
  }
  await Promise.all(inserts);
}

async function getCourseStudyDays(courseId) {
  const cached = cacheGet(referenceCache.studyDays, courseId);
  if (cached) return cached;
  await ensureCourseStudyDays(courseId);
  const rows = await db.all(
    `SELECT d.id, d.weekday, d.is_active, s.id AS subject_id, s.name AS subject_name
     FROM course_study_days d
     LEFT JOIN course_day_subjects cds ON cds.course_study_day_id = d.id
     LEFT JOIN subjects s ON s.id = cds.subject_id
     WHERE d.course_id = ?
     ORDER BY d.weekday, cds.sort_order, s.name`,
    [courseId]
  );
  const map = new Map();
  (rows || []).forEach((row) => {
    if (!map.has(row.weekday)) {
      map.set(row.weekday, {
        weekday: row.weekday,
        label: studyDayLabels[row.weekday - 1] || String(row.weekday),
        day_name: fullWeekDays[row.weekday - 1],
        is_active: !!row.is_active,
        subjects: [],
      });
    }
    if (row.subject_id) {
      map.get(row.weekday).subjects.push({ id: row.subject_id, name: row.subject_name });
    }
  });
  const result = Array.from(map.values()).sort((a, b) => a.weekday - b.weekday);
  return cacheSet(referenceCache.studyDays, courseId, result);
}

async function getCourseWeekTimeMap(courseId, semesterId) {
  if (!courseId || !semesterId) return new Map();
  const key = `${courseId}|${semesterId}`;
  const cached = cacheGet(referenceCache.weekTime, key);
  if (cached) return cached;
  const rows = await db.all(
    'SELECT week_number, use_local_time FROM course_week_time_modes WHERE course_id = ? AND semester_id = ?',
    [courseId, semesterId]
  );
  const map = new Map();
  (rows || []).forEach((row) => {
    map.set(Number(row.week_number), row.use_local_time === true || Number(row.use_local_time) === 1);
  });
  return cacheSet(referenceCache.weekTime, key, map);
}

async function getCourseWeekTimeList(courseId, semester) {
  if (!courseId || !semester || !semester.id) return [];
  const totalWeeks = Number(semester.weeks_count || 0);
  if (!totalWeeks) return [];
  const weekMap = await getCourseWeekTimeMap(courseId, semester.id);
  return Array.from({ length: totalWeeks }, (_, idx) => ({
    week_number: idx + 1,
    use_local_time: weekMap.get(idx + 1) === true,
  }));
}

async function isCourseDayActive(courseId, dayName) {
  if (!courseId || !dayName) return false;
  const studyDays = await getCourseStudyDays(courseId);
  return (studyDays || []).some((d) => d.is_active && d.day_name === dayName);
}

async function getTeacherSubjectCatalog() {
  return db.all(
    `
      SELECT s.id, s.name, s.group_count, s.is_general, s.course_id, c.name AS course_name
      FROM subjects s
      JOIN courses c ON c.id = s.course_id
      WHERE s.visible = 1
        AND EXISTS (
          SELECT 1
          FROM semesters sem
          WHERE sem.course_id = s.course_id AND sem.is_active = 1
        )
      ORDER BY c.id, s.name
    `
  );
}

async function getTeacherSelections(userId) {
  const rows = await db.all(
    'SELECT subject_id, group_number FROM teacher_subjects WHERE user_id = ?',
    [userId]
  );
  const map = new Map();
  (rows || []).forEach((row) => {
    map.set(Number(row.subject_id), row.group_number === null ? null : Number(row.group_number));
  });
  return map;
}

async function saveTeacherSubjects(userId, body, options = {}) {
  const catalog = await getTeacherSubjectCatalog();
  const selections = [];
  let hasAny = false;
  for (const subject of catalog) {
    const selected = body[`subject_${subject.id}`];
    if (!selected) {
      continue;
    }
    hasAny = true;
    const isGeneral = subject.is_general === true || Number(subject.is_general) === 1;
    if (isGeneral) {
      selections.push({ subject_id: subject.id, group_number: null });
      continue;
    }
    const groupVal = body[`group_${subject.id}`];
    const groupNum = Number(groupVal);
    if (!groupVal || Number.isNaN(groupNum) || groupNum < 1 || groupNum > Number(subject.group_count || 1)) {
      return { ok: false, error: 'Select%20group' };
    }
    selections.push({ subject_id: subject.id, group_number: groupNum });
  }
  if (!hasAny) {
    return { ok: false, error: 'Select%20subject' };
  }
  await db.run('DELETE FROM teacher_subjects WHERE user_id = ?', [userId]);
  for (const item of selections) {
    await db.run(
      'INSERT INTO teacher_subjects (user_id, subject_id, group_number) VALUES (?, ?, ?)',
      [userId, item.subject_id, item.group_number]
    );
  }
  const existing = await db.get('SELECT status FROM teacher_requests WHERE user_id = ?', [userId]);
  let nextStatus = existing ? String(existing.status || 'pending') : 'pending';
  if (nextStatus === 'rejected') {
    nextStatus = 'pending';
  }
  if (existing) {
    if (nextStatus !== 'approved' || options.allowPendingReset) {
      await db.run(
        'UPDATE teacher_requests SET status = ?, updated_at = NOW() WHERE user_id = ?',
        [nextStatus, userId]
      );
    } else {
      await db.run('UPDATE teacher_requests SET updated_at = NOW() WHERE user_id = ?', [userId]);
    }
  } else {
    await db.run(
      'INSERT INTO teacher_requests (user_id, status) VALUES (?, ?)',
      [userId, nextStatus]
    );
  }
  return { ok: true, status: nextStatus, selections };
}

function broadcast(type, payload) {
  const message = JSON.stringify({ type, payload });
  wss.clients.forEach((client) => {
    if (client.readyState === 1) {
      client.send(message);
    }
  });
}

function sortSchedule(schedule, sortKey) {
  if (!sortKey) return schedule;
  const copy = [...schedule];
  if (sortKey === 'day') {
    const order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
    copy.sort(
      (a, b) =>
        order.indexOf(a.day_of_week) - order.indexOf(b.day_of_week) || a.class_number - b.class_number
    );
  } else if (sortKey === 'time') {
    copy.sort((a, b) => a.class_number - b.class_number);
  } else if (sortKey === 'group') {
    copy.sort((a, b) => a.group_number - b.group_number || a.day_of_week.localeCompare(b.day_of_week));
  }
  return copy;
}

function sortHomework(homework, sortKey) {
  const normalized = (Array.isArray(homework) ? homework : []).map((item) => (
    item && item.file_name
      ? { ...item, file_name: normalizeUploadedOriginalName(item.file_name) }
      : item
  ));
  if (!sortKey) return normalized;
  const copy = [...normalized];
  if (sortKey === 'created') {
    copy.sort((a, b) => (a.created_at < b.created_at ? 1 : -1));
  } else if (sortKey === 'subject') {
    copy.sort((a, b) => a.subject.localeCompare(b.subject));
  }
  return copy;
}

app.get('/', (req, res) => {
  res.render('login', { error: req.query.error === '1' });
});

app.get('/login', (req, res) => {
  res.render('login', { error: req.query.error === '1' });
});

app.get('/_health', (req, res) => {
  const dbStatus = initStatus === 'ok' ? 'ok' : (initStatus === 'error' ? 'fail' : 'starting');
  const sessionStatus = sessionHealthState.ok ? 'ok' : 'fail';
  const status = dbStatus === 'fail' || sessionStatus === 'fail'
    ? 'degraded'
    : (dbStatus === 'starting' ? 'starting' : 'ok');
  const strictMode = String(req.query.strict || '') === '1';
  const httpStatus = strictMode && status !== 'ok' ? 503 : 200;
  res.status(httpStatus).json({
    status,
    healthy: status === 'ok',
    db: {
      initStatus,
      status: dbStatus,
      error: initError ? String(initError.message || initError) : null,
    },
    session: {
      ok: sessionHealthState.ok,
      status: sessionStatus,
      table: sessionHealthState.table,
      checks: sessionHealthState.checks,
      failures: sessionHealthState.failures,
      probe_interval_seconds: sessionHealthProbeIntervalSeconds,
      last_checked_at: sessionHealthState.lastCheckedAt,
      last_ok_at: sessionHealthState.lastOkAt,
      last_error_at: sessionHealthState.lastErrorAt,
      last_error: sessionHealthState.lastError,
      last_duration_ms: sessionHealthState.lastDurationMs,
    },
  });
});

app.get('/__version', (req, res) => {
  res.json({
    version: appVersion,
    buildStamp,
    node: process.version,
  });
});

app.post('/_bootstrap', async (req, res) => {
  const token = process.env.BOOTSTRAP_TOKEN;
  const provided = req.get('x-bootstrap-token') || req.query.token || '';
  if (!token || provided !== token) {
    return res.status(403).json({ ok: false, error: 'Forbidden' });
  }
  try {
    await ensureDbReady();
    return res.json({ ok: true, initStatus });
  } catch (err) {
    return res.status(500).json({ ok: false, error: String(err.message || err) });
  }
});

app.post('/login', authLimiter, async (req, res) => {
  const { full_name, password, remember_me } = req.body;
  if (!full_name || !password) {
    return res.redirect('/login?error=1');
  }
  try {
    await ensureDbReady();
  } catch (err) {
    console.error('DB init failed', err);
    return res.redirect('/login?error=1');
  }
  ensureUsersSchema(() => {
    const normalizedName = full_name.trim().replace(/\s+/g, ' ');
    const activeClause = usersHasIsActive ? ' AND is_active = 1' : '';
    db.get(
      `SELECT id, full_name, role, password_hash, schedule_group, course_id, language FROM users WHERE LOWER(full_name) = LOWER(?)${activeClause}`,
      [normalizedName],
      (err, user) => {
        const validHash = user && user.password_hash ? bcrypt.compareSync(password, user.password_hash) : false;
        if (err || !user || !validHash) {
          recordAuthFailureEvent({
            attemptedName: normalizedName,
            userId: user && user.id ? Number(user.id) : null,
            ip: getClientIp(req),
            userAgent: req.headers['user-agent'] || null,
            sessionId: req.sessionID || null,
            courseId: user && Number.isFinite(Number(user.course_id)) ? Number(user.course_id) : null,
          }).catch((failureErr) => {
            console.error('Database error (login.auth_failure)', failureErr);
          });
          return res.redirect('/login?error=1');
        }
        const role = normalizeRoleKey(user.role);
        if (role !== user.role) {
          db.run('UPDATE users SET role = ? WHERE id = ?', [role, user.id]);
        }
        const loginAt = new Date().toISOString();
        const loginIp = normalizeForensicsIp(getClientIp(req));
        const loginUserAgent = normalizeForensicsAgent(req.headers['user-agent'] || null);
        db.run(
          'UPDATE users SET last_login_ip = ?, last_user_agent = ?, last_login_at = ? WHERE id = ?',
          [loginIp, loginUserAgent, loginAt, user.id]
        );
        db.run(
          'INSERT INTO login_history (user_id, full_name, ip, user_agent, created_at, course_id) VALUES (?, ?, ?, ?, ?, ?)',
          [user.id, user.full_name, loginIp, loginUserAgent, loginAt, user.course_id || 1]
        );
        req.session.user = {
          id: user.id,
          username: user.full_name,
          schedule_group: user.schedule_group,
          course_id: user.course_id || 1,
          language: user.language || getPreferredLang(req),
        };
        req.session.role = role;
        const remember = isRememberRequested(remember_me);
        req.session.rememberMe = remember;
        applyRememberMe(req, remember);
        req.session.session_created_at = req.session.session_created_at || loginAt;
        req.session.last_seen_at = loginAt;
        req.session.last_seen_route = '/login';
        req.session.last_seen_ip = loginIp;
        req.session.last_seen_user_agent = loginUserAgent;

        req.session.save(() => {
          if (role === 'admin') {
            return res.redirect('/admin');
          }
          return res.redirect('/schedule');
        });
      }
    );
  });
});

app.get('/register', (req, res) => {
  res.render('register', { error: req.query.error || '' });
});

app.post('/register', registerLimiter, async (req, res) => {
  const { full_name, password, confirm_password, agree, remember_me } = req.body;
  if (!full_name || !password || !confirm_password || !agree) {
    return res.redirect('/register?error=Missing%20fields');
  }
  if (password !== confirm_password) {
    return res.redirect('/register?error=Passwords%20do%20not%20match');
  }

  try {
    await ensureDbReady();
    const normalizedName = full_name.trim().replace(/\s+/g, ' ');
    const existing = await db.get('SELECT id FROM users WHERE LOWER(full_name) = LOWER(?)', [normalizedName]);
    if (existing) {
      return res.redirect('/register?error=User%20already%20exists');
    }
    const hash = await bcrypt.hash(password, 10);
    const preferredLang = getPreferredLang(req);
    const row = await db.get(
      'INSERT INTO users (full_name, role, password_hash, is_active, schedule_group, course_id, language) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id',
      [normalizedName, 'student', hash, 1, 'A', null, preferredLang]
    );
    if (!row || !row.id) {
      return res.redirect('/register?error=Database%20error');
    }
    let registrationSignals = null;
    try {
      registrationSignals = await recordUserRegistrationEvent({
        userId: row.id,
        fullName: normalizedName,
        ip: getClientIp(req),
        userAgent: req.headers['user-agent'] || null,
        sessionId: req.sessionID || null,
        source: 'register_form',
        courseId: null,
      });
    } catch (eventErr) {
      console.error('Database error (register.registration_event)', eventErr);
    }
    try {
      const signalRisk = registrationSignals && registrationSignals.security && registrationSignals.security.risk
        ? registrationSignals.security.risk
        : null;
      const securityCase = await recomputeUserSecurityCase(row.id, {
        allowAutoQuarantine: true,
        courseId: null,
        extraScore: Number(signalRisk && signalRisk.score ? signalRisk.score : 0),
        extraReasons: Array.isArray(signalRisk && signalRisk.reasons ? signalRisk.reasons : [])
          ? signalRisk.reasons
          : [],
      });
      const isQuarantined = securityCase
        && securityCase.case
        && (securityCase.case.auto_quarantined === true || Number(securityCase.case.auto_quarantined) === 1);
      if (isQuarantined) {
        logAction(db, req, 'register_quarantined', { user_id: row.id, full_name: normalizedName });
        req.session.pendingUserId = null;
        req.session.rememberMe = false;
        return res.redirect('/login?error=Account%20pending%20review');
      }
    } catch (securityErr) {
      console.error('Database error (register.security_case)', securityErr);
    }
    req.session.pendingUserId = row.id;
    req.session.rememberMe = isRememberRequested(remember_me);
    logAction(db, req, 'register_user', { user_id: row.id, full_name: normalizedName });
    broadcast('users_updated');
    return res.redirect('/register/course');
  } catch (err) {
    console.error('Register failed', err);
    return res.redirect('/register?error=Database%20error');
  }
});

app.get('/register/course', (req, res) => {
  if (!req.session.pendingUserId) {
    return res.redirect('/register');
  }
  ensureDbReady().catch((err) => {
    console.error('DB init failed', err);
  });
  (async () => {
    try {
      const courses = await getCoursesCached();
      return res.render('register-course', { courses, error: req.query.error || '' });
    } catch (err) {
      return res.status(500).send('Database error');
    }
  })();
});

app.post('/register/course', registerLimiter, (req, res) => {
  const userId = req.session.pendingUserId;
  if (!userId) {
    return res.redirect('/register');
  }
  const courseId = Number(req.body.course_id);
  if (Number.isNaN(courseId)) {
    return res.redirect('/register/course?error=Select%20course');
  }
  db.get('SELECT id, is_teacher_course FROM courses WHERE id = ?', [courseId], (err, course) => {
    if (err || !course) {
      return res.redirect('/register/course?error=Invalid%20course');
    }
    db.run('UPDATE users SET course_id = ? WHERE id = ?', [courseId, userId], (updErr) => {
      if (updErr) {
        return res.redirect('/register/course?error=Database%20error');
      }
      db.run(
        'UPDATE user_registration_events SET course_id = COALESCE(course_id, ?) WHERE user_id = ?',
        [courseId, userId],
        (eventErr) => {
          if (eventErr) {
            console.error('Database error (register.course.registration_event)', eventErr);
          }
        }
      );
      if (course.is_teacher_course === true || Number(course.is_teacher_course) === 1) {
        return res.redirect('/register/teacher-subjects');
      }
      return res.redirect('/register/subjects');
    });
  });
});

app.get('/register/subjects', (req, res) => {
  if (!req.session.pendingUserId) {
    return res.redirect('/register');
  }
  ensureDbReady().catch((err) => {
    console.error('DB init failed', err);
  });
  db.get('SELECT course_id FROM users WHERE id = ?', [req.session.pendingUserId], (uErr, user) => {
    if (uErr || !user || !user.course_id) {
      return res.redirect('/register/course');
    }
    db.get('SELECT is_teacher_course FROM courses WHERE id = ?', [user.course_id], (cErr, course) => {
      if (!cErr && course && (course.is_teacher_course === true || Number(course.is_teacher_course) === 1)) {
        return res.redirect('/register/teacher-subjects');
      }
    (async () => {
      try {
        const subjects = await getSubjectsCached(user.course_id, { visibleOnly: true });
        const isRequired = (s) => s && (s.is_required === true || s.is_required === 1 || s.is_required === '1');
        const requiredAuto = (subjects || []).filter((s) => isRequired(s) && Number(s.group_count) === 1);
        await Promise.all(
          requiredAuto.map((s) =>
            db.run(
              `INSERT INTO student_groups (student_id, subject_id, group_number)
               VALUES (?, ?, 1)
               ON CONFLICT(student_id, subject_id) DO NOTHING`,
              [req.session.pendingUserId, s.id]
            )
          )
        );
        const optoutRows = await db.all(
          'SELECT subject_id FROM user_subject_optouts WHERE user_id = ?',
          [req.session.pendingUserId]
        );
        const optouts = (optoutRows || []).map((r) => r.subject_id);
        res.render('register-subjects', { subjects, optouts, error: req.query.error || '' });
      } catch (err) {
        res.status(500).send('Database error');
      }
    })();
    });
  });
});

app.post('/register/subjects', registerLimiter, (req, res) => {
  const userId = req.session.pendingUserId;
  if (!userId) {
    return res.redirect('/register');
  }

  db.get('SELECT course_id FROM users WHERE id = ?', [userId], (uErr, userRow) => {
    if (uErr || !userRow || !userRow.course_id) {
      return res.redirect('/register/course');
    }
    db.all(
      'SELECT id, group_count, default_group, is_required FROM subjects WHERE course_id = ? AND visible = 1',
      [userRow.course_id],
      (err, subjects) => {
      if (err) {
        return res.status(500).send('Database error');
      }
      let hasMissingRequired = false;
      const stmt = db.prepare(
        `
          INSERT INTO student_groups (student_id, subject_id, group_number)
          VALUES (?, ?, ?)
          ON CONFLICT(student_id, subject_id)
          DO UPDATE SET group_number = excluded.group_number
        `
      );
      const deleteStmt = db.prepare('DELETE FROM student_groups WHERE student_id = ? AND subject_id = ?');
      const optoutStmt = db.prepare(
        `INSERT INTO user_subject_optouts (user_id, subject_id) VALUES (?, ?)
         ON CONFLICT(user_id, subject_id) DO NOTHING`
      );
      const optoutDeleteStmt = db.prepare('DELETE FROM user_subject_optouts WHERE user_id = ? AND subject_id = ?');
      const isRequired = (s) => s && (s.is_required === true || s.is_required === 1 || s.is_required === '1');
      subjects.forEach((s) => {
        const value = req.body[`subject_${s.id}`];
        const requiredFlag = isRequired(s);
        const optout = req.body[`optout_${s.id}`] === '1' || req.body[`optout_${s.id}`] === 'on';
        if (requiredFlag) {
          optoutDeleteStmt.run(userId, s.id);
          if (Number(s.group_count) === 1) {
            stmt.run(userId, s.id, 1);
            return;
          }
          if (!value) {
            hasMissingRequired = true;
            return;
          }
          const groupNum = Number(value);
          if (groupNum >= 1 && groupNum <= s.group_count) {
            stmt.run(userId, s.id, groupNum);
          } else {
            hasMissingRequired = true;
          }
          return;
        }
        if (optout) {
          deleteStmt.run(userId, s.id);
          optoutStmt.run(userId, s.id);
          return;
        }
        optoutDeleteStmt.run(userId, s.id);
        if (!value) {
          if (Number(s.group_count) === 1) {
            stmt.run(userId, s.id, 1);
            return;
          }
          return;
        }
        const groupNum = Number(value);
        if (groupNum >= 1 && groupNum <= s.group_count) {
          stmt.run(userId, s.id, groupNum);
        } else {
          hasMissingRequired = true;
        }
      });
      stmt.finalize(() => {
        deleteStmt.finalize();
        optoutStmt.finalize();
        optoutDeleteStmt.finalize();
        if (hasMissingRequired) {
          return res.redirect('/register/subjects?error=Select%20group');
        }
        db.get('SELECT id, full_name, role, schedule_group, course_id, language FROM users WHERE id = ?', [userId], (uErr2, user) => {
          if (uErr2 || !user) {
            return res.redirect('/login');
          }
          req.session.user = {
            id: user.id,
            username: user.full_name,
            schedule_group: user.schedule_group,
            course_id: user.course_id || 1,
            language: user.language || getPreferredLang(req),
          };
          req.session.role = user.role;
          applyRememberMe(req, Boolean(req.session.rememberMe));
          req.session.pendingUserId = null;
          req.session.rememberMe = null;
          logAction(db, req, 'register_subjects', { user_id: user.id });
          broadcast('users_updated');
          return req.session.save(() => res.redirect('/schedule?welcome=1'));
        });
      });
    });
  });
});

app.get('/register/teacher-subjects', (req, res) => {
  if (!req.session.pendingUserId) {
    return res.redirect('/register');
  }
  ensureDbReady().catch((err) => {
    console.error('DB init failed', err);
  });
  db.get('SELECT id, course_id FROM users WHERE id = ?', [req.session.pendingUserId], (uErr, user) => {
    if (uErr || !user || !user.course_id) {
      return res.redirect('/register/course');
    }
    db.get('SELECT is_teacher_course FROM courses WHERE id = ?', [user.course_id], async (cErr, course) => {
      if (cErr || !course) {
        return res.redirect('/register/course');
      }
      if (!(course.is_teacher_course === true || Number(course.is_teacher_course) === 1)) {
        return res.redirect('/register/subjects');
      }
      try {
        const subjects = await getTeacherSubjectCatalog();
        const selections = await getTeacherSelections(user.id);
        return res.render('register-teacher-subjects', {
          subjects,
          selections,
          error: req.query.error || '',
          isProfileEdit: false,
        });
      } catch (err) {
        return res.status(500).send('Database error');
      }
    });
  });
});

app.post('/register/teacher-subjects', registerLimiter, async (req, res) => {
  const userId = req.session.pendingUserId;
  if (!userId) {
    return res.redirect('/register');
  }
  try {
    const userRow = await db.get('SELECT id, full_name, role, schedule_group, course_id, language FROM users WHERE id = ?', [userId]);
    if (!userRow || !userRow.course_id) {
      return res.redirect('/register/course');
    }
    const course = await db.get('SELECT is_teacher_course FROM courses WHERE id = ?', [userRow.course_id]);
    if (!course || !(course.is_teacher_course === true || Number(course.is_teacher_course) === 1)) {
      return res.redirect('/register/subjects');
    }
    const result = await saveTeacherSubjects(userId, req.body);
    if (!result.ok) {
      return res.redirect(`/register/teacher-subjects?error=${result.error || 'Select%20subject'}`);
    }
    req.session.user = {
      id: userRow.id,
      username: userRow.full_name,
      schedule_group: userRow.schedule_group,
      course_id: userRow.course_id || 1,
      language: userRow.language || getPreferredLang(req),
    };
    req.session.role = userRow.role || 'student';
    applyRememberMe(req, Boolean(req.session.rememberMe));
    req.session.pendingUserId = null;
    req.session.rememberMe = null;
    logAction(db, req, 'register_teacher_subjects', { user_id: userRow.id });
    broadcast('users_updated');
    return req.session.save(() => res.redirect('/teacher/pending'));
  } catch (err) {
    console.error('Register teacher subjects failed', err);
    return res.redirect('/register/teacher-subjects?error=Database%20error');
  }
});

app.get('/teacher/subjects', requireLogin, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'teacher.subjects.init');
  }
  const { id: userId, course_id: courseId } = req.session.user;
  try {
    const course = await db.get('SELECT is_teacher_course FROM courses WHERE id = ?', [courseId]);
    if (!course || !(course.is_teacher_course === true || Number(course.is_teacher_course) === 1)) {
      return res.redirect('/schedule');
    }
    const subjects = await getTeacherSubjectCatalog();
    const selections = await getTeacherSelections(userId);
    return res.render('register-teacher-subjects', {
      subjects,
      selections,
      error: req.query.error || '',
      isProfileEdit: true,
    });
  } catch (err) {
    return handleDbError(res, err, 'teacher.subjects');
  }
});

app.post('/teacher/subjects', requireLogin, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'teacher.subjects.save.init');
  }
  const { id: userId, course_id: courseId } = req.session.user;
  try {
    const course = await db.get('SELECT is_teacher_course FROM courses WHERE id = ?', [courseId]);
    if (!course || !(course.is_teacher_course === true || Number(course.is_teacher_course) === 1)) {
      return res.redirect('/schedule');
    }
    const result = await saveTeacherSubjects(userId, req.body);
    if (!result.ok) {
      return res.redirect(`/teacher/subjects?error=${result.error || 'Select%20subject'}`);
    }
    logAction(db, req, 'teacher_subjects_update', { user_id: userId });
    broadcast('users_updated');
    return res.redirect('/profile?ok=Subjects%20updated');
  } catch (err) {
    console.error('Failed to save teacher subjects', err);
    return res.redirect('/teacher/subjects?error=Database%20error');
  }
});

app.get('/teacher/pending', requireLogin, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'teacher.pending.init');
  }
  try {
    const { id: userId, course_id: courseId } = req.session.user;
    const course = await db.get('SELECT is_teacher_course FROM courses WHERE id = ?', [courseId]);
    if (!course || !(course.is_teacher_course === true || Number(course.is_teacher_course) === 1)) {
      return res.redirect('/schedule');
    }
    const request = await db.get('SELECT status FROM teacher_requests WHERE user_id = ?', [userId]);
    if (request && request.status === 'approved') {
      req.session.role = 'teacher';
      return res.redirect('/schedule');
    }
    return res.render('teacher-pending', {
      status: request ? request.status : 'pending',
    });
  } catch (err) {
    return handleDbError(res, err, 'teacher.pending');
  }
});

app.get('/profile', requireLogin, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'profile.init');
  }
  const { id, role, username } = req.session.user;
  try {
    const user = await db.get('SELECT id, full_name, course_id, language FROM users WHERE id = ?', [id]);
    if (!user) {
      return res.status(500).send('Database error');
    }
    let teacherStatus = null;
    let teacherCourse = false;
    if (user.course_id) {
      teacherCourse = await isTeacherCourse(user.course_id);
      if (teacherCourse) {
        const tr = await db.get('SELECT status FROM teacher_requests WHERE user_id = ?', [id]);
        teacherStatus = tr ? tr.status : null;
      }
    }
    const activeSemester = await getActiveSemester(user.course_id || 1);
    const pointsRow = await db.get(
      `
        SELECT COALESCE(SUM(${ACTIVITY_POINTS_CASE}), 0) AS points
        FROM activity_log
        WHERE user_id = ?${activeSemester ? ' AND semester_id = ?' : ''}
      `,
      activeSemester ? [id, activeSemester.id] : [id]
    );
    const activityPoints = pointsRow ? Number(pointsRow.points || 0) : 0;
    const analyticsParams = activeSemester ? [id, user.course_id || 1, activeSemester.id] : [id, user.course_id || 1];
    const [
      homeworkCreatedRow,
      teamworkCreatedRow,
      teamworkJoinedRow,
    ] = await Promise.all([
      db.get(
        `SELECT COUNT(*) AS count
         FROM homework
         WHERE created_by_id = ? AND course_id = ?${activeSemester ? ' AND semester_id = ?' : ''}`,
        analyticsParams
      ),
      db.get(
        `SELECT COUNT(*) AS count
         FROM teamwork_tasks
         WHERE created_by = ? AND course_id = ?${activeSemester ? ' AND semester_id = ?' : ''}`,
        analyticsParams
      ),
      db.get(
        `SELECT COUNT(*) AS count
         FROM teamwork_members m
         JOIN teamwork_tasks t ON t.id = m.task_id
         WHERE m.user_id = ? AND t.course_id = ?${activeSemester ? ' AND t.semester_id = ?' : ''}`,
        analyticsParams
      ),
    ]);
    const profileStats = {
      homeworkCreated: Number(homeworkCreatedRow?.count || 0),
      teamworkCreated: Number(teamworkCreatedRow?.count || 0),
      teamworkJoined: Number(teamworkJoinedRow?.count || 0),
    };
    res.render('profile', {
      user,
      activityPoints,
      profileStats,
      teacherStatus,
      teacherCourse,
      error: req.query.error || '',
      success: req.query.ok || '',
      role,
      username,
    });
  } catch (err) {
    return handleDbError(res, err, 'profile');
  }
});

app.post('/profile', requireLogin, (req, res) => {
  const { full_name, password, confirm_password, language } = req.body;
  const { id } = req.session.user;
  if (!full_name) {
    return res.redirect('/profile?error=Full%20name%20required');
  }
  if ((password || confirm_password) && password !== confirm_password) {
    return res.redirect('/profile?error=Passwords%20do%20not%20match');
  }

  const updates = [];
  const params = [];
  updates.push('full_name = ?');
  params.push(full_name.trim());

  if (password) {
    const hash = bcrypt.hashSync(password, 10);
    updates.push('password_hash = ?');
    params.push(hash);
  }

  if (language && ['uk', 'en'].includes(language)) {
    updates.push('language = ?');
    params.push(language);
  }

  params.push(id);
  db.run(`UPDATE users SET ${updates.join(', ')} WHERE id = ?`, params, (err) => {
    if (err) {
      return res.redirect('/profile?error=Name%20already%20exists');
    }
    req.session.user.username = full_name.trim();
    if (language && ['uk', 'en'].includes(language)) {
      req.session.user.language = language;
      req.session.lang = language;
    }
    logAction(db, req, 'update_profile', { user_id: id });
    broadcast('users_updated');
    return res.redirect('/profile?ok=Profile%20updated');
  });
});

app.post('/profile/reset-subjects', requireLogin, async (req, res) => {
  const { id } = req.session.user;
  try {
    await db.run('DELETE FROM student_groups WHERE student_id = ?', [id]);
    await db.run('DELETE FROM user_subject_optouts WHERE user_id = ?', [id]);
    req.session.pendingUserId = id;
    logAction(db, req, 'reset_subjects', { user_id: id });
    broadcast('users_updated');
    return req.session.save(() => res.redirect('/register/subjects'));
  } catch (err) {
    console.error('Failed to reset subjects', err);
    return res.redirect('/profile?error=Database%20error');
  }
});

async function getMyDayReviewSubjects({ userId, courseId, roleKeys = [] }) {
  const normalizedRoles = normalizeRoleList(roleKeys);
  const hasFullAccess = normalizedRoles.some((roleKey) => roleKey === 'admin' || roleKey === 'deanery');
  if (hasFullAccess) {
    const rows = await db.all(
      `
        SELECT s.id AS subject_id, s.name AS subject_name, s.group_count
        FROM subjects s
        WHERE s.course_id = ? AND s.visible = 1
        ORDER BY s.name ASC
      `,
      [courseId]
    );
    return (rows || []).map((row) => {
      const groupCount = Math.max(1, Number(row.group_count || 1));
      return {
        subject_id: Number(row.subject_id),
        subject_name: row.subject_name || 'Предмет',
        has_all_groups: true,
        group_numbers: Array.from({ length: groupCount }, (_v, index) => index + 1),
      };
    });
  }

  if (!normalizedRoles.includes('teacher')) {
    return [];
  }

  const rows = await db.all(
    `
      SELECT ts.subject_id, ts.group_number, s.name AS subject_name, s.group_count
      FROM teacher_subjects ts
      JOIN subjects s ON s.id = ts.subject_id
      WHERE ts.user_id = ?
        AND s.course_id = ?
        AND s.visible = 1
      ORDER BY s.name ASC
    `,
    [userId, courseId]
  );
  if (!rows || !rows.length) {
    return [];
  }
  const bySubject = new Map();
  (rows || []).forEach((row) => {
    const subjectId = Number(row.subject_id || 0);
    if (!Number.isFinite(subjectId) || subjectId < 1) return;
    if (!bySubject.has(subjectId)) {
      bySubject.set(subjectId, {
        subject_id: subjectId,
        subject_name: row.subject_name || 'Предмет',
        group_count: Math.max(1, Number(row.group_count || 1)),
        has_all_groups: false,
        group_numbers_set: new Set(),
      });
    }
    const item = bySubject.get(subjectId);
    if (row.group_number === null || typeof row.group_number === 'undefined') {
      item.has_all_groups = true;
      return;
    }
    const groupNumber = Number(row.group_number);
    if (Number.isInteger(groupNumber) && groupNumber > 0) {
      item.group_numbers_set.add(groupNumber);
    }
  });
  return Array.from(bySubject.values()).map((item) => {
    const groupNumbers = item.has_all_groups
      ? Array.from({ length: item.group_count }, (_v, index) => index + 1)
      : Array.from(item.group_numbers_set).sort((a, b) => a - b);
    return {
      subject_id: item.subject_id,
      subject_name: item.subject_name,
      has_all_groups: item.has_all_groups,
      group_numbers: groupNumbers,
    };
  });
}

async function buildMyDayReviewQueue({
  userId,
  courseId,
  semesterId,
  roleKeys = [],
  now = new Date(),
}) {
  const subjectOptions = await getMyDayReviewSubjects({ userId, courseId, roleKeys });
  const emptyResult = {
    enabled: true,
    overdue_threshold_hours: REVIEW_QUEUE_OVERDUE_HOURS,
    counts: { overdue: 0, new: 0, no_comment: 0 },
    total: 0,
    items: [],
    truncated: false,
    templates: REVIEW_QUEUE_FEEDBACK_TEMPLATES,
  };
  if (!subjectOptions.length) {
    return emptyResult;
  }

  const priorityByType = {
    overdue: 0,
    new: 1,
    no_comment: 2,
  };
  const nowMs = now.getTime();
  const byCellKey = new Map();

  for (const subject of subjectOptions) {
    const subjectId = Number(subject.subject_id || 0);
    if (!Number.isFinite(subjectId) || subjectId < 1) continue;
    const allowedGroups = Array.isArray(subject.group_numbers)
      ? subject.group_numbers.filter((value) => Number.isInteger(Number(value)) && Number(value) > 0).map((value) => Number(value))
      : [];
    const groupFilterSet = subject.has_all_groups || !allowedGroups.length ? null : new Set(allowedGroups);
    const matrix = await buildJournalMatrix({
      subjectId,
      courseId,
      semesterId,
      actorUserId: userId,
      groupFilterSet,
    });
    const columns = Array.isArray(matrix?.columns) ? matrix.columns : [];
    const rows = Array.isArray(matrix?.rows) ? matrix.rows : [];
    rows.forEach((row) => {
      const student = row?.student || {};
      const studentId = Number(student.id || 0);
      if (!Number.isFinite(studentId) || studentId < 1) return;
      const studentName = String(student.full_name || '').trim() || 'Студент';
      const studentGroup = Number(student.group_number || 0);
      const cells = Array.isArray(row?.cells) ? row.cells : [];
      cells.forEach((cell, index) => {
        const column = columns[index] || null;
        if (!column) return;
        const columnId = Number(column.id || 0);
        if (!Number.isFinite(columnId) || columnId < 1) return;
        if (Number(column.is_locked || 0) === 1) return;
        if (!Number(column.source_homework_id || 0)) return;
        const submission = cell?.submission || null;
        const submittedAt = submission && submission.submitted_at ? String(submission.submitted_at) : '';
        if (!submittedAt) return;

        const parsedSubmittedAt = new Date(submittedAt);
        const submittedAtMs = parsedSubmittedAt.getTime();
        const hasValidSubmittedAt = Number.isFinite(submittedAtMs);
        const hasScore = Number.isFinite(Number(cell?.score));
        const hasComment = Boolean(String(cell?.teacher_comment || '').trim());
        if (hasScore && hasComment) return;

        let queueType = 'new';
        if (!hasScore) {
          const ageHours = hasValidSubmittedAt ? ((nowMs - submittedAtMs) / (60 * 60 * 1000)) : 0;
          queueType = ageHours >= REVIEW_QUEUE_OVERDUE_HOURS ? 'overdue' : 'new';
        } else if (!hasComment) {
          queueType = 'no_comment';
        }

        const dueDate = toDateOnly(column.custom_due_date || column.class_date);
        const queueKey = `${columnId}|${studentId}`;
        const reviewHref = `/journal?subject_id=${encodeURIComponent(String(subjectId))}&open_column_id=${encodeURIComponent(String(columnId))}&open_student_id=${encodeURIComponent(String(studentId))}`;
        const item = {
          queue_key: queueKey,
          queue_type: queueType,
          subject_id: subjectId,
          subject_name: subject.subject_name || 'Предмет',
          student_id: studentId,
          student_name: studentName,
          student_group: Number.isInteger(studentGroup) && studentGroup > 0 ? studentGroup : null,
          column_id: columnId,
          column_title: String(column.title || 'Колонка'),
          max_points: Number(column.max_points || 0),
          score: hasScore ? Number(cell.score) : null,
          teacher_comment: String(cell.teacher_comment || ''),
          submission_status: String(cell.status || 'missing'),
          submitted_at: submittedAt,
          submitted_at_ts: hasValidSubmittedAt ? submittedAtMs : Number.MAX_SAFE_INTEGER,
          due_date: dueDate || null,
          review_href: reviewHref,
        };
        const existing = byCellKey.get(queueKey);
        if (!existing) {
          byCellKey.set(queueKey, item);
          return;
        }
        const currentPriority = Number(priorityByType[item.queue_type] ?? 99);
        const existingPriority = Number(priorityByType[existing.queue_type] ?? 99);
        if (currentPriority < existingPriority) {
          byCellKey.set(queueKey, item);
          return;
        }
        if (currentPriority === existingPriority && item.submitted_at_ts < existing.submitted_at_ts) {
          byCellKey.set(queueKey, item);
        }
      });
    });
  }

  const allItems = Array.from(byCellKey.values()).sort((a, b) => {
    const priorityA = Number(priorityByType[a.queue_type] ?? 99);
    const priorityB = Number(priorityByType[b.queue_type] ?? 99);
    if (priorityA !== priorityB) return priorityA - priorityB;
    if (a.submitted_at_ts !== b.submitted_at_ts) return a.submitted_at_ts - b.submitted_at_ts;
    const subjectCompare = String(a.subject_name || '').localeCompare(String(b.subject_name || ''));
    if (subjectCompare !== 0) return subjectCompare;
    return String(a.student_name || '').localeCompare(String(b.student_name || ''));
  });

  const counts = { overdue: 0, new: 0, no_comment: 0 };
  allItems.forEach((item) => {
    if (Object.prototype.hasOwnProperty.call(counts, item.queue_type)) {
      counts[item.queue_type] += 1;
    }
  });

  const limitedItems = allItems.slice(0, REVIEW_QUEUE_ITEM_LIMIT).map((item) => {
    const normalized = { ...item };
    delete normalized.submitted_at_ts;
    return normalized;
  });
  return {
    enabled: true,
    overdue_threshold_hours: REVIEW_QUEUE_OVERDUE_HOURS,
    counts,
    total: allItems.length,
    items: limitedItems,
    truncated: allItems.length > REVIEW_QUEUE_ITEM_LIMIT,
    templates: REVIEW_QUEUE_FEEDBACK_TEMPLATES,
  };
}

async function buildAdminHomeworkReviewSla({
  userId,
  courseId,
  semesterId = null,
  roleKeys = [],
  now = new Date(),
}) {
  const subjectOptions = await getMyDayReviewSubjects({
    userId,
    courseId,
    roleKeys,
  });
  const subjectIds = Array.from(
    new Set(
      (subjectOptions || [])
        .map((item) => Number(item?.subject_id || 0))
        .filter((id) => Number.isFinite(id) && id > 0)
    )
  );
  const emptyResult = {
    enabled: true,
    threshold_hours: REVIEW_QUEUE_OVERDUE_HOURS,
    submissions_total: 0,
    ungraded_total: 0,
    overdue_ungraded_total: 0,
    subjects_at_risk: 0,
    subjects_with_ungraded: 0,
    max_wait_hours: 0,
    by_subject: [],
  };
  if (!subjectIds.length) {
    return emptyResult;
  }

  const placeholders = subjectIds.map(() => '?').join(',');
  const params = [now.toISOString(), REVIEW_QUEUE_OVERDUE_HOURS, courseId];
  const semesterClause = semesterId
    ? 'AND (h.semester_id = ? OR h.semester_id IS NULL)'
    : 'AND h.semester_id IS NULL';
  if (semesterId) {
    params.push(semesterId);
  }
  params.push(...subjectIds);

  const rows = await db.all(
    `
      SELECT
        h.subject_id,
        COALESCE(s.name, 'Предмет') AS subject_name,
        COUNT(*)::int AS submissions_total,
        COUNT(*) FILTER (WHERE jg.id IS NULL)::int AS ungraded_total,
        COUNT(*) FILTER (
          WHERE jg.id IS NULL
            AND hs.submitted_at <= (?::timestamptz - (? * INTERVAL '1 hour'))
        )::int AS overdue_ungraded_total,
        MIN(hs.submitted_at) FILTER (WHERE jg.id IS NULL) AS oldest_ungraded_at
      FROM homework_submissions hs
      JOIN homework h ON h.id = hs.homework_id
      JOIN subjects s ON s.id = h.subject_id
      LEFT JOIN journal_columns jc
        ON jc.source_homework_id = h.id
       AND COALESCE(jc.is_archived, 0) = 0
      LEFT JOIN journal_grades jg
        ON jg.column_id = jc.id
       AND jg.student_id = hs.student_id
       AND jg.deleted_at IS NULL
      WHERE h.course_id = ?
        ${semesterClause}
        AND COALESCE(h.is_teacher_homework, 0) = 1
        AND h.subject_id IN (${placeholders})
      GROUP BY h.subject_id, s.name
      ORDER BY overdue_ungraded_total DESC, ungraded_total DESC, subject_name ASC
    `,
    params
  );

  const nowMs = now.getTime();
  const bySubject = (rows || []).map((row) => {
    const oldestUngradedAt = row.oldest_ungraded_at ? String(row.oldest_ungraded_at) : null;
    const oldestMs = oldestUngradedAt ? new Date(oldestUngradedAt).getTime() : Number.NaN;
    const waitHours = Number.isFinite(oldestMs)
      ? Math.max(0, Math.floor((nowMs - oldestMs) / (60 * 60 * 1000)))
      : 0;
    return {
      subject_id: Number(row.subject_id || 0),
      subject_name: String(row.subject_name || 'Предмет'),
      submissions_total: Number(row.submissions_total || 0),
      ungraded_total: Number(row.ungraded_total || 0),
      overdue_ungraded_total: Number(row.overdue_ungraded_total || 0),
      oldest_ungraded_at: oldestUngradedAt,
      oldest_wait_hours: waitHours,
    };
  });

  const summary = bySubject.reduce((acc, row) => {
    acc.submissions_total += Number(row.submissions_total || 0);
    acc.ungraded_total += Number(row.ungraded_total || 0);
    acc.overdue_ungraded_total += Number(row.overdue_ungraded_total || 0);
    if (Number(row.overdue_ungraded_total || 0) > 0) {
      acc.subjects_at_risk += 1;
    }
    if (Number(row.ungraded_total || 0) > 0) {
      acc.subjects_with_ungraded += 1;
    }
    acc.max_wait_hours = Math.max(acc.max_wait_hours, Number(row.oldest_wait_hours || 0));
    return acc;
  }, {
    submissions_total: 0,
    ungraded_total: 0,
    overdue_ungraded_total: 0,
    subjects_at_risk: 0,
    subjects_with_ungraded: 0,
    max_wait_hours: 0,
  });

  return {
    enabled: true,
    threshold_hours: REVIEW_QUEUE_OVERDUE_HOURS,
    submissions_total: summary.submissions_total,
    ungraded_total: summary.ungraded_total,
    overdue_ungraded_total: summary.overdue_ungraded_total,
    subjects_at_risk: summary.subjects_at_risk,
    subjects_with_ungraded: summary.subjects_with_ungraded,
    max_wait_hours: summary.max_wait_hours,
    by_subject: bySubject
      .filter((item) => Number(item.ungraded_total || 0) > 0 || Number(item.overdue_ungraded_total || 0) > 0)
      .slice(0, HOMEWORK_REVIEW_SLA_SUBJECT_LIMIT),
  };
}

const normalizeDataQualitySeverity = (value) => {
  const normalized = String(value || '').trim().toLowerCase();
  if (normalized === 'critical') return 'critical';
  if (normalized === 'warning') return 'warning';
  return 'info';
};

const parseDbIntegerArray = (value) => {
  if (Array.isArray(value)) {
    return value
      .map((item) => Number(item))
      .filter((item) => Number.isInteger(item) && item > 0);
  }
  if (typeof value === 'string') {
    const trimmed = value.trim();
    if (!trimmed) return [];
    const body = trimmed.startsWith('{') && trimmed.endsWith('}')
      ? trimmed.slice(1, -1)
      : trimmed;
    if (!body) return [];
    return body
      .split(',')
      .map((item) => Number(String(item).replace(/^"+|"+$/g, '').trim()))
      .filter((item) => Number.isInteger(item) && item > 0);
  }
  return [];
};

const isDbSchemaCompatibilityError = (err) => {
  const code = String(err && err.code ? err.code : '').trim().toUpperCase();
  if (
    code === '42P01' // undefined_table
    || code === '42703' // undefined_column
    || code === '42P10' // invalid_column_reference (e.g. ON CONFLICT without matching unique index)
    || code === '42883' // undefined_function/operator (often bool vs int comparisons)
    || code === '42804' // datatype_mismatch
    || code === '22P02' // invalid_text_representation
  ) {
    return true;
  }
  // Treat SQLSTATE class 42/22 as schema/data-shape compatibility issues for legacy DB variants.
  if (code.startsWith('42') || code.startsWith('22')) {
    return true;
  }
  const message = String(err && err.message ? err.message : err || '').toLowerCase();
  if (!message) return false;
  return (
    message.includes('does not exist')
    || message.includes('no such table')
    || message.includes('no such column')
    || message.includes('undefined table')
    || message.includes('undefined column')
    || message.includes('operator does not exist')
    || message.includes('cannot cast type')
    || message.includes('invalid input syntax for type')
  );
};

const isDataQualityCompatibilityError = (err) => isDbSchemaCompatibilityError(err);

const buildJournalEmptyAttendanceContext = () => ({
  date: formatLocalDate(new Date()),
  class_number: 1,
  class_options: getAttendanceClassOptions(),
  statuses: ATTENDANCE_STATUS_OPTIONS.map((status) => ATTENDANCE_STATUS_META[status]),
  rows: [],
  summary: {
    present: 0,
    late: 0,
    absent: 0,
    excused: 0,
    unset: 0,
    marked_total: 0,
    students_total: 0,
  },
  student_summary: null,
  reason_max_length: ATTENDANCE_REASON_MAX_LENGTH,
  quick_current_slot: {
    available: false,
    class_date: formatLocalDate(new Date()),
    class_number: null,
    day_of_week: null,
    start: '',
    end: '',
    label: '',
    group_numbers: [],
    is_selected: false,
  },
});

const buildJournalEmptyStateViewModel = ({
  req,
  subjects = [],
  teacherJournalMode = false,
  canManageAllSubjects = false,
  compatibilityMessage = '',
} = {}) => ({
  username: req.session.user.username,
  role: req.session.role,
  subjects,
  selectedSubject: null,
  columns: [],
  journalRows: [],
  gradingSettings: { ...DEFAULT_SUBJECT_GRADING_SETTINGS },
  attendanceContext: buildJournalEmptyAttendanceContext(),
  canEditJournal: false,
  canEditAttendance: false,
  teacherJournalMode: Boolean(teacherJournalMode),
  attendanceQuickAutoOpen: false,
  canManageAllSubjects: Boolean(canManageAllSubjects),
  subjectClosure: null,
  canCloseSubject: false,
  selectedSemester: null,
  undoGrade: null,
  gradingTypeMeta: JOURNAL_SCORING_TYPE_META,
  compatibilityMessage: String(compatibilityMessage || ''),
});

const renderViewToResponse = (res, view, payload) => new Promise((resolve, reject) => {
  res.render(view, payload, (err, html) => {
    if (err) {
      err.isViewRenderError = true;
      err.viewName = view;
      return reject(err);
    }
    if (!res.headersSent) {
      res.send(html);
    }
    return resolve();
  });
});

const sendJournalPlainFallback = (res) => {
  if (res.headersSent) return;
  return res
    .status(200)
    .type('html')
    .send(
      '<!doctype html><html lang="uk"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Журнал</title></head><body style="font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif;padding:24px;line-height:1.45"><h1 style="margin:0 0 8px">Журнал у режимі сумісності</h1><p style="margin:0 0 16px">Сторінка тимчасово спрощена через несумісну структуру БД. Оновіть міграції та перезавантажте сервіс.</p><p style="margin:0"><a href="/journal">Оновити</a></p></body></html>'
    );
};

const buildDataQualityCheck = ({
  key,
  title,
  severity = 'warning',
  description = '',
  count = 0,
  examples = [],
  subjectIds = [],
}) => {
  const normalizedCount = Math.max(0, Number.isFinite(Number(count)) ? Math.round(Number(count)) : 0);
  const uniqueSubjectIds = Array.from(
    new Set(
      (Array.isArray(subjectIds) ? subjectIds : [])
        .map((id) => Number(id))
        .filter((id) => Number.isInteger(id) && id > 0)
    )
  );
  return {
    key: String(key || '').trim() || 'unknown',
    title: String(title || '').trim() || 'Check',
    severity: normalizeDataQualitySeverity(severity),
    description: String(description || '').trim(),
    count: normalizedCount,
    status: normalizedCount > 0 ? 'issue' : 'ok',
    subject_ids: uniqueSubjectIds,
    examples: (Array.isArray(examples) ? examples : [])
      .map((item) => String(item || '').trim())
      .filter(Boolean)
      .slice(0, 6),
  };
};

async function buildAdminDataQualityDiagnostics({
  courseId,
  semesterId = null,
}) {
  const normalizedCourseId = Number(courseId || 0);
  const normalizedSemesterId = Number(semesterId || 0);
  const hasSemester = Number.isInteger(normalizedSemesterId) && normalizedSemesterId > 0;
  const result = {
    generated_at: new Date().toISOString(),
    course_id: Number.isInteger(normalizedCourseId) && normalizedCourseId > 0 ? normalizedCourseId : null,
    semester_id: hasSemester ? normalizedSemesterId : null,
    available: true,
    summary: {
      checks_total: 0,
      checks_with_issues: 0,
      total_issues: 0,
      affected_subjects: 0,
      severity_rows: {
        critical: 0,
        warning: 0,
        info: 0,
      },
      severity_checks: {
        critical: 0,
        warning: 0,
        info: 0,
      },
    },
    items: [],
  };
  if (!Number.isInteger(normalizedCourseId) || normalizedCourseId < 1) {
    return result;
  }

  const homeworkSemesterClause = hasSemester
    ? 'AND (h.semester_id = ? OR h.semester_id IS NULL)'
    : 'AND h.semester_id IS NULL';
  const homeworkBaseParams = hasSemester
    ? [normalizedCourseId, normalizedSemesterId]
    : [normalizedCourseId];

  const journalSemesterClause = hasSemester
    ? 'AND (jc.semester_id = ? OR jc.semester_id IS NULL)'
    : 'AND jc.semester_id IS NULL';
  const journalBaseParams = hasSemester
    ? [normalizedCourseId, normalizedSemesterId]
    : [normalizedCourseId];

  const gradingSemesterClause = hasSemester
    ? 'AND (sgs.semester_id = ? OR sgs.semester_id IS NULL)'
    : 'AND sgs.semester_id IS NULL';
  const gradingBaseParams = hasSemester
    ? [normalizedCourseId, normalizedSemesterId]
    : [normalizedCourseId];

  let diagnosticsRows = null;
  let compatibilityFallbacks = 0;
  const fallbackMessages = [];
  const withCompatibilityFallback = async (queryPromise, fallbackValue) => {
    try {
      return await queryPromise;
    } catch (err) {
      compatibilityFallbacks += 1;
      const rawMessage = String(err && err.message ? err.message : err || '').trim();
      if (rawMessage) {
        fallbackMessages.push(rawMessage.slice(0, 180));
      } else if (isDataQualityCompatibilityError(err)) {
        fallbackMessages.push('schema compatibility');
      } else {
        fallbackMessages.push('query failed');
      }
      return fallbackValue;
    }
  };
  diagnosticsRows = await Promise.all([
      withCompatibilityFallback(db.get(
        `
          SELECT
            COUNT(*)::int AS count,
            COALESCE(
              ARRAY_AGG(DISTINCT h.subject_id) FILTER (WHERE h.subject_id IS NOT NULL),
              ARRAY[]::int[]
            ) AS subject_ids
          FROM homework h
          LEFT JOIN journal_columns jc ON jc.source_homework_id = h.id
          WHERE h.course_id = ?
            ${homeworkSemesterClause}
            AND COALESCE(h.is_teacher_homework, 0) = 1
            AND COALESCE(h.status, 'published') = 'published'
            AND jc.id IS NULL
        `,
        homeworkBaseParams
      ), { count: 0, subject_ids: [] }),
      withCompatibilityFallback(db.all(
        `
          SELECT
            h.id AS homework_id,
            h.subject_id,
            COALESCE(s.name, 'Предмет') AS subject_name,
            COALESCE(h.group_number, 0)::int AS group_number,
            COALESCE(
              NULLIF(TRIM(COALESCE(h.class_date, '')), ''),
              NULLIF(TRIM(COALESCE(h.custom_due_date, '')), ''),
              '—'
            ) AS due_label,
            LEFT(TRIM(COALESCE(h.description, '')), 80) AS description_preview
          FROM homework h
          LEFT JOIN subjects s ON s.id = h.subject_id
          LEFT JOIN journal_columns jc ON jc.source_homework_id = h.id
          WHERE h.course_id = ?
            ${homeworkSemesterClause}
            AND COALESCE(h.is_teacher_homework, 0) = 1
            AND COALESCE(h.status, 'published') = 'published'
            AND jc.id IS NULL
          ORDER BY h.created_at DESC
          LIMIT 8
        `,
        homeworkBaseParams
      ), []),
      withCompatibilityFallback(db.all(
        `
          WITH grouped AS (
            SELECT
              h.subject_id,
              COALESCE(s.name, 'Предмет') AS subject_name,
              COALESCE(h.group_number, 0)::int AS group_number,
              COALESCE(
                NULLIF(TRIM(COALESCE(h.class_date, '')), ''),
                NULLIF(TRIM(COALESCE(h.custom_due_date, '')), ''),
                '—'
              ) AS due_label,
              COALESCE(h.class_number, 0)::int AS class_number,
              COUNT(*)::int AS duplicates
            FROM homework h
            LEFT JOIN subjects s ON s.id = h.subject_id
            WHERE h.course_id = ?
              ${homeworkSemesterClause}
              AND COALESCE(h.is_teacher_homework, 0) = 1
              AND COALESCE(h.status, 'published') = 'published'
            GROUP BY
              h.subject_id,
              s.name,
              COALESCE(h.group_number, 0),
              COALESCE(
                NULLIF(TRIM(COALESCE(h.class_date, '')), ''),
                NULLIF(TRIM(COALESCE(h.custom_due_date, '')), ''),
                '—'
              ),
              COALESCE(h.class_number, 0),
              LOWER(REGEXP_REPLACE(TRIM(COALESCE(h.description, '')), '\\s+', ' ', 'g')),
              COALESCE(h.is_control, 0),
              COALESCE(h.is_credit, 0),
              COALESCE(h.is_custom_deadline, 0)
            HAVING COUNT(*) > 1
          )
          SELECT
            grouped.*,
            COUNT(*) OVER()::int AS groups_total,
            COALESCE(SUM(grouped.duplicates - 1) OVER(), 0)::int AS extra_total
          FROM grouped
          ORDER BY grouped.duplicates DESC, grouped.subject_name ASC
          LIMIT 8
        `,
        homeworkBaseParams
      ), []),
      withCompatibilityFallback(db.get(
        `
          SELECT
            COUNT(*)::int AS count,
            COALESCE(
              ARRAY_AGG(DISTINCT jc.subject_id) FILTER (WHERE jc.subject_id IS NOT NULL),
              ARRAY[]::int[]
            ) AS subject_ids
          FROM journal_columns jc
          WHERE jc.course_id = ?
            ${journalSemesterClause}
            AND COALESCE(jc.source_type, 'manual') = 'homework'
            AND jc.source_homework_id IS NULL
            AND COALESCE(jc.is_archived, 0) = 0
        `,
        journalBaseParams
      ), { count: 0, subject_ids: [] }),
      withCompatibilityFallback(db.all(
        `
          SELECT
            jc.id,
            jc.subject_id,
            COALESCE(s.name, 'Предмет') AS subject_name,
            COALESCE(jc.title, 'Колонка') AS title
          FROM journal_columns jc
          LEFT JOIN subjects s ON s.id = jc.subject_id
          WHERE jc.course_id = ?
            ${journalSemesterClause}
            AND COALESCE(jc.source_type, 'manual') = 'homework'
            AND jc.source_homework_id IS NULL
            AND COALESCE(jc.is_archived, 0) = 0
          ORDER BY jc.updated_at DESC, jc.id DESC
          LIMIT 8
        `,
        journalBaseParams
      ), []),
      withCompatibilityFallback(db.all(
        `
          WITH grouped AS (
            SELECT
              jc.subject_id,
              COALESCE(s.name, 'Предмет') AS subject_name,
              LOWER(TRIM(COALESCE(jc.title, ''))) AS title_key,
              COALESCE(jc.column_type, 'custom') AS column_type,
              COALESCE(jc.max_points, 0)::numeric(8, 2) AS max_points,
              COALESCE(jc.include_in_final, 1)::int AS include_in_final,
              COUNT(*)::int AS duplicates
            FROM journal_columns jc
            LEFT JOIN subjects s ON s.id = jc.subject_id
            WHERE jc.course_id = ?
              ${journalSemesterClause}
              AND COALESCE(jc.is_archived, 0) = 0
              AND COALESCE(jc.source_type, 'manual') = 'manual'
            GROUP BY
              jc.subject_id,
              s.name,
              LOWER(TRIM(COALESCE(jc.title, ''))),
              COALESCE(jc.column_type, 'custom'),
              COALESCE(jc.max_points, 0)::numeric(8, 2),
              COALESCE(jc.include_in_final, 1)::int,
              COALESCE(jc.is_credit, 0)
            HAVING COUNT(*) > 1
          )
          SELECT
            grouped.*,
            COUNT(*) OVER()::int AS groups_total,
            COALESCE(SUM(grouped.duplicates - 1) OVER(), 0)::int AS extra_total
          FROM grouped
          ORDER BY grouped.duplicates DESC, grouped.subject_name ASC
          LIMIT 8
        `,
        journalBaseParams
      ), []),
      withCompatibilityFallback(db.all(
        `
          SELECT
            sg.subject_id,
            COALESCE(s.name, 'Предмет') AS subject_name,
            COALESCE(s.group_count, 1)::int AS max_group,
            sg.group_number::int AS group_number,
            COUNT(*)::int AS rows_count,
            COUNT(*) OVER()::int AS groups_total,
            COALESCE(SUM(COUNT(*)) OVER(), 0)::int AS affected_rows_total
          FROM student_groups sg
          JOIN subjects s ON s.id = sg.subject_id
          JOIN users u ON u.id = sg.student_id
          WHERE s.course_id = ?
            AND u.course_id = ?
            AND (sg.group_number < 1 OR sg.group_number > COALESCE(s.group_count, 1))
          GROUP BY sg.subject_id, s.name, COALESCE(s.group_count, 1), sg.group_number
          ORDER BY rows_count DESC, subject_name ASC
          LIMIT 8
        `,
        [normalizedCourseId, normalizedCourseId]
      ), []),
      withCompatibilityFallback(db.all(
        `
          SELECT
            ts.subject_id,
            COALESCE(s.name, 'Предмет') AS subject_name,
            COALESCE(s.group_count, 1)::int AS max_group,
            ts.group_number::int AS group_number,
            COUNT(*)::int AS rows_count,
            COUNT(*) OVER()::int AS groups_total,
            COALESCE(SUM(COUNT(*)) OVER(), 0)::int AS affected_rows_total
          FROM teacher_subjects ts
          JOIN subjects s ON s.id = ts.subject_id
          JOIN users u ON u.id = ts.user_id
          WHERE s.course_id = ?
            AND u.course_id = ?
            AND ts.group_number IS NOT NULL
            AND (ts.group_number < 1 OR ts.group_number > COALESCE(s.group_count, 1))
          GROUP BY ts.subject_id, s.name, COALESCE(s.group_count, 1), ts.group_number
          ORDER BY rows_count DESC, subject_name ASC
          LIMIT 8
        `,
        [normalizedCourseId, normalizedCourseId]
      ), []),
      withCompatibilityFallback(db.all(
        `
          SELECT
            sgs.subject_id,
            COALESCE(s.name, 'Предмет') AS subject_name,
            ROUND((
              (CASE WHEN COALESCE(sgs.homework_enabled, 1) = 1 THEN COALESCE(sgs.homework_weight_points, 0) ELSE 0 END) +
              (CASE WHEN COALESCE(sgs.seminar_enabled, 1) = 1 THEN COALESCE(sgs.seminar_weight_points, 0) ELSE 0 END) +
              (CASE WHEN COALESCE(sgs.exam_enabled, 1) = 1 THEN COALESCE(sgs.exam_weight_points, 0) ELSE 0 END) +
              (CASE WHEN COALESCE(sgs.credit_enabled, 1) = 1 THEN COALESCE(sgs.credit_weight_points, 0) ELSE 0 END) +
              (CASE WHEN COALESCE(sgs.custom_enabled, 1) = 1 THEN COALESCE(sgs.custom_weight_points, 0) ELSE 0 END)
            )::numeric, 2) AS active_weight_sum,
            COUNT(*) OVER()::int AS rows_total
          FROM subject_grading_settings sgs
          JOIN subjects s ON s.id = sgs.subject_id
          WHERE sgs.course_id = ?
            ${gradingSemesterClause}
            AND ABS((
              (CASE WHEN COALESCE(sgs.homework_enabled, 1) = 1 THEN COALESCE(sgs.homework_weight_points, 0) ELSE 0 END) +
              (CASE WHEN COALESCE(sgs.seminar_enabled, 1) = 1 THEN COALESCE(sgs.seminar_weight_points, 0) ELSE 0 END) +
              (CASE WHEN COALESCE(sgs.exam_enabled, 1) = 1 THEN COALESCE(sgs.exam_weight_points, 0) ELSE 0 END) +
              (CASE WHEN COALESCE(sgs.credit_enabled, 1) = 1 THEN COALESCE(sgs.credit_weight_points, 0) ELSE 0 END) +
              (CASE WHEN COALESCE(sgs.custom_enabled, 1) = 1 THEN COALESCE(sgs.custom_weight_points, 0) ELSE 0 END)
            ) - 100) > 0.01
          ORDER BY ABS((
              (CASE WHEN COALESCE(sgs.homework_enabled, 1) = 1 THEN COALESCE(sgs.homework_weight_points, 0) ELSE 0 END) +
              (CASE WHEN COALESCE(sgs.seminar_enabled, 1) = 1 THEN COALESCE(sgs.seminar_weight_points, 0) ELSE 0 END) +
              (CASE WHEN COALESCE(sgs.exam_enabled, 1) = 1 THEN COALESCE(sgs.exam_weight_points, 0) ELSE 0 END) +
              (CASE WHEN COALESCE(sgs.credit_enabled, 1) = 1 THEN COALESCE(sgs.credit_weight_points, 0) ELSE 0 END) +
              (CASE WHEN COALESCE(sgs.custom_enabled, 1) = 1 THEN COALESCE(sgs.custom_weight_points, 0) ELSE 0 END)
            ) - 100) DESC,
            subject_name ASC
          LIMIT 8
        `,
        gradingBaseParams
      ), []),
    ]);

  const [
    missingJournalCountRow,
    missingJournalRows,
    duplicateTeacherHomeworkRows,
    orphanHomeworkColumnCountRow,
    orphanHomeworkColumnRows,
    duplicateManualColumnsRows,
    invalidStudentGroupRows,
    invalidTeacherGroupRows,
    gradingWeightMismatchRows,
  ] = diagnosticsRows;

  const items = [];
  items.push(buildDataQualityCheck({
    key: 'teacher_homework_without_journal_column',
    title: 'Викладацьке ДЗ без колонки журналу',
    severity: 'critical',
    description: 'ДЗ створене, але автоматична колонка журналу відсутня.',
    count: Number(missingJournalCountRow?.count || 0),
    subjectIds: parseDbIntegerArray(missingJournalCountRow?.subject_ids),
    examples: (missingJournalRows || []).map((row) => {
      const groupLabel = Number(row.group_number || 0) > 0 ? `група ${row.group_number}` : 'всі групи';
      const dueLabel = row.due_label ? String(row.due_label) : '—';
      return `${row.subject_name || 'Предмет'} · ${groupLabel} · ${dueLabel} · #${Number(row.homework_id || 0)}`;
    }),
  }));

  items.push(buildDataQualityCheck({
    key: 'duplicate_teacher_homework',
    title: 'Дублі викладацьких ДЗ',
    severity: 'warning',
    description: 'Підозра на подвійне створення однакових завдань.',
    count: Number(duplicateTeacherHomeworkRows && duplicateTeacherHomeworkRows[0]
      ? duplicateTeacherHomeworkRows[0].extra_total
      : 0),
    subjectIds: Array.from(
      new Set(
        (duplicateTeacherHomeworkRows || [])
          .map((row) => Number(row.subject_id || 0))
          .filter((id) => Number.isInteger(id) && id > 0)
      )
    ),
    examples: (duplicateTeacherHomeworkRows || []).map((row) => {
      const groupLabel = Number(row.group_number || 0) > 0 ? `група ${row.group_number}` : 'всі групи';
      const classLabel = Number(row.class_number || 0) > 0 ? `пара ${row.class_number}` : 'без пари';
      return `${row.subject_name || 'Предмет'} · ${groupLabel} · ${row.due_label || '—'} · ${classLabel} · x${Number(row.duplicates || 0)}`;
    }),
  }));

  items.push(buildDataQualityCheck({
    key: 'orphan_homework_journal_columns',
    title: 'Колонки типу homework без source_homework_id',
    severity: 'critical',
    description: 'Колонка журналу не прив’язана до первинного ДЗ.',
    count: Number(orphanHomeworkColumnCountRow?.count || 0),
    subjectIds: parseDbIntegerArray(orphanHomeworkColumnCountRow?.subject_ids),
    examples: (orphanHomeworkColumnRows || []).map((row) => (
      `${row.subject_name || 'Предмет'} · ${row.title || 'Колонка'} · #${Number(row.id || 0)}`
    )),
  }));

  items.push(buildDataQualityCheck({
    key: 'duplicate_manual_journal_columns',
    title: 'Дублі ручних колонок журналу',
    severity: 'warning',
    description: 'У межах предмета знайдено однакові ручні колонки.',
    count: Number(duplicateManualColumnsRows && duplicateManualColumnsRows[0]
      ? duplicateManualColumnsRows[0].extra_total
      : 0),
    subjectIds: Array.from(
      new Set(
        (duplicateManualColumnsRows || [])
          .map((row) => Number(row.subject_id || 0))
          .filter((id) => Number.isInteger(id) && id > 0)
      )
    ),
    examples: (duplicateManualColumnsRows || []).map((row) => {
      const title = String(row.title_key || '').trim() || 'без назви';
      return `${row.subject_name || 'Предмет'} · ${title} · ${row.column_type || 'custom'} · x${Number(row.duplicates || 0)}`;
    }),
  }));

  items.push(buildDataQualityCheck({
    key: 'invalid_student_group_numbers',
    title: 'Некоректні групи студентів',
    severity: 'warning',
    description: 'group_number виходить за діапазон предмета.',
    count: Number(invalidStudentGroupRows && invalidStudentGroupRows[0]
      ? invalidStudentGroupRows[0].affected_rows_total
      : 0),
    subjectIds: Array.from(
      new Set(
        (invalidStudentGroupRows || [])
          .map((row) => Number(row.subject_id || 0))
          .filter((id) => Number.isInteger(id) && id > 0)
      )
    ),
    examples: (invalidStudentGroupRows || []).map((row) => (
      `${row.subject_name || 'Предмет'} · group ${Number(row.group_number || 0)} / max ${Number(row.max_group || 1)} · студентів ${Number(row.rows_count || 0)}`
    )),
  }));

  items.push(buildDataQualityCheck({
    key: 'invalid_teacher_subject_groups',
    title: 'Некоректні групи у зв’язках викладач-предмет',
    severity: 'warning',
    description: 'У teacher_subjects записано group_number поза межами предмета.',
    count: Number(invalidTeacherGroupRows && invalidTeacherGroupRows[0]
      ? invalidTeacherGroupRows[0].affected_rows_total
      : 0),
    subjectIds: Array.from(
      new Set(
        (invalidTeacherGroupRows || [])
          .map((row) => Number(row.subject_id || 0))
          .filter((id) => Number.isInteger(id) && id > 0)
      )
    ),
    examples: (invalidTeacherGroupRows || []).map((row) => (
      `${row.subject_name || 'Предмет'} · group ${Number(row.group_number || 0)} / max ${Number(row.max_group || 1)} · зв’язків ${Number(row.rows_count || 0)}`
    )),
  }));

  items.push(buildDataQualityCheck({
    key: 'grading_weights_not_100',
    title: 'Вага оцінювання не дорівнює 100',
    severity: 'warning',
    description: 'Сума активних внесків у фінал має бути рівно 100.',
    count: Number(gradingWeightMismatchRows && gradingWeightMismatchRows[0]
      ? gradingWeightMismatchRows[0].rows_total
      : 0),
    subjectIds: Array.from(
      new Set(
        (gradingWeightMismatchRows || [])
          .map((row) => Number(row.subject_id || 0))
          .filter((id) => Number.isInteger(id) && id > 0)
      )
    ),
    examples: (gradingWeightMismatchRows || []).map((row) => (
      `${row.subject_name || 'Предмет'} · активна сума ${Number(row.active_weight_sum || 0)} / 100`
    )),
  }));

  if (compatibilityFallbacks > 0) {
    const fallbackExamples = Array.from(
      new Set([
        `Пропущено перевірок: ${compatibilityFallbacks}`,
        ...fallbackMessages.slice(0, 3),
      ].filter(Boolean))
    );
    items.push(buildDataQualityCheck({
      key: 'partial_schema_compatibility',
      title: 'Частина перевірок недоступна',
      severity: 'info',
      description: 'Деякі діагностичні запити пропущено, показано частковий результат.',
      count: 0,
      examples: fallbackExamples,
    }));
  }

  const severityRows = { critical: 0, warning: 0, info: 0 };
  const severityChecks = { critical: 0, warning: 0, info: 0 };
  const affectedSubjectSet = new Set();
  let checksWithIssues = 0;
  let totalIssues = 0;

  items.forEach((item) => {
    if (Number(item.count || 0) <= 0) return;
    checksWithIssues += 1;
    totalIssues += Number(item.count || 0);
    severityRows[item.severity] += Number(item.count || 0);
    severityChecks[item.severity] += 1;
    (item.subject_ids || []).forEach((subjectId) => {
      affectedSubjectSet.add(subjectId);
    });
  });

  result.items = items;
  result.summary = {
    checks_total: items.length,
    checks_with_issues: checksWithIssues,
    total_issues: totalIssues,
    affected_subjects: affectedSubjectSet.size,
    severity_rows: severityRows,
    severity_checks: severityChecks,
  };
  return result;
}

async function buildCoursePulseAnalytics({
  courseId,
  semesterId = null,
  now = new Date(),
}) {
  const safeCourseId = Number(courseId || 0);
  const safeSemesterId = Number(semesterId || 0);
  const hasSemester = Number.isInteger(safeSemesterId) && safeSemesterId > 0;
  const today = formatLocalDate(now);
  const recentDate = formatLocalDate(addDays(now, -30));
  const previousDate = formatLocalDate(addDays(now, -60));
  const recentIso = new Date(`${recentDate}T00:00:00.000Z`).toISOString();
  const previousIso = new Date(`${previousDate}T00:00:00.000Z`).toISOString();
  const summary = {
    students_total: 0,
    students_at_risk: 0,
    high_risk_students: 0,
    risk_students_share: 0,
    overdue_homework_total: 0,
    sla_submissions_total: 0,
    sla_ungraded_total: 0,
    sla_overdue_ungraded_total: 0,
    sla_overdue_share: 0,
    attendance_absent_share: 0,
    attendance_late_share: 0,
  };
  const emptyResult = {
    generated_at: new Date().toISOString(),
    course_id: Number.isFinite(safeCourseId) && safeCourseId > 0 ? safeCourseId : null,
    semester_id: hasSemester ? safeSemesterId : null,
    summary,
    subjects: [],
  };
  if (!Number.isFinite(safeCourseId) || safeCourseId < 1) {
    return emptyResult;
  }

  const homeworkSemesterClause = hasSemester
    ? 'AND (h.semester_id = ? OR h.semester_id IS NULL)'
    : 'AND h.semester_id IS NULL';
  const journalSemesterClause = hasSemester
    ? 'AND (jc.semester_id = ? OR jc.semester_id IS NULL)'
    : 'AND jc.semester_id IS NULL';
  const attendanceSemesterClause = hasSemester
    ? 'AND (ar.semester_id = ? OR ar.semester_id IS NULL)'
    : 'AND ar.semester_id IS NULL';

  const [
    studentsRow,
    riskRow,
    homeworkSlaRow,
    attendanceRow,
    trendRows,
    overdueBySubjectRows,
    slaBySubjectRows,
  ] = await Promise.all([
    db.get(
      `
        SELECT COUNT(*)::int AS count
        FROM users
        WHERE course_id = ?
          AND is_active = 1
          AND LOWER(COALESCE(role, 'student')) = 'student'
      `,
      [safeCourseId]
    ),
    db.get(
      `
        WITH overdue AS (
          SELECT
            sg.student_id,
            COUNT(*)::int AS overdue_count
          FROM student_groups sg
          JOIN homework h
            ON h.subject_id = sg.subject_id
           AND (h.group_number = sg.group_number OR h.group_number IS NULL)
          WHERE h.course_id = ?
            ${homeworkSemesterClause}
            AND COALESCE(h.is_teacher_homework, 0) = 1
            AND COALESCE(h.status, 'published') = 'published'
            AND COALESCE(NULLIF(TRIM(COALESCE(h.custom_due_date, '')), ''), NULLIF(TRIM(COALESCE(h.class_date, '')), '')) < ?
            AND NOT EXISTS (
              SELECT 1
              FROM homework_submissions hs
              WHERE hs.homework_id = h.id
                AND hs.student_id = sg.student_id
            )
          GROUP BY sg.student_id
        )
        SELECT
          COUNT(*) FILTER (WHERE overdue_count >= 1)::int AS any_risk_students,
          COUNT(*) FILTER (WHERE overdue_count >= 2)::int AS high_risk_students,
          COALESCE(SUM(overdue_count), 0)::int AS overdue_total
        FROM overdue
      `,
      hasSemester ? [safeCourseId, safeSemesterId, today] : [safeCourseId, today]
    ),
    db.get(
      `
        SELECT
          COUNT(*)::int AS submissions_total,
          COUNT(*) FILTER (WHERE jg.id IS NULL)::int AS ungraded_total,
          COUNT(*) FILTER (
            WHERE jg.id IS NULL
              AND hs.submitted_at <= (?::timestamptz - (48 * INTERVAL '1 hour'))
          )::int AS overdue_ungraded_total
        FROM homework_submissions hs
        JOIN homework h ON h.id = hs.homework_id
        LEFT JOIN journal_columns jc
          ON jc.source_homework_id = h.id
         AND COALESCE(jc.is_archived, 0) = 0
        LEFT JOIN journal_grades jg
          ON jg.column_id = jc.id
         AND jg.student_id = hs.student_id
         AND jg.deleted_at IS NULL
        WHERE h.course_id = ?
          ${homeworkSemesterClause}
          AND COALESCE(h.is_teacher_homework, 0) = 1
      `,
      hasSemester ? [now.toISOString(), safeCourseId, safeSemesterId] : [now.toISOString(), safeCourseId]
    ),
    db.get(
      `
        SELECT
          COUNT(*) FILTER (WHERE ar.status = 'absent')::int AS absent_count,
          COUNT(*) FILTER (WHERE ar.status = 'late')::int AS late_count,
          COUNT(*)::int AS total_records
        FROM attendance_records ar
        JOIN users u ON u.id = ar.student_id
        WHERE ar.course_id = ?
          ${attendanceSemesterClause}
          AND ar.class_date >= ?
          AND u.course_id = ?
      `,
      hasSemester
        ? [safeCourseId, safeSemesterId, recentDate, safeCourseId]
        : [safeCourseId, recentDate, safeCourseId]
    ),
    db.all(
      `
        SELECT
          jc.subject_id,
          COALESCE(s.name, 'Предмет') AS subject_name,
          AVG(CASE WHEN jg.graded_at >= ? THEN (jg.score / NULLIF(jc.max_points, 0)) END) AS recent_ratio,
          AVG(CASE WHEN jg.graded_at >= ? AND jg.graded_at < ? THEN (jg.score / NULLIF(jc.max_points, 0)) END) AS previous_ratio,
          COUNT(*) FILTER (WHERE jg.graded_at >= ?)::int AS recent_count,
          COUNT(*) FILTER (WHERE jg.graded_at >= ? AND jg.graded_at < ?)::int AS previous_count
        FROM journal_grades jg
        JOIN journal_columns jc ON jc.id = jg.column_id
        LEFT JOIN subjects s ON s.id = jc.subject_id
        WHERE jc.course_id = ?
          ${journalSemesterClause}
          AND COALESCE(jc.is_archived, 0) = 0
          AND jg.deleted_at IS NULL
        GROUP BY jc.subject_id, s.name
        HAVING
          COUNT(*) FILTER (WHERE jg.graded_at >= ?) > 0
          OR COUNT(*) FILTER (WHERE jg.graded_at >= ? AND jg.graded_at < ?) > 0
        ORDER BY subject_name ASC
      `,
      hasSemester
        ? [
            recentIso,
            previousIso,
            recentIso,
            recentIso,
            previousIso,
            recentIso,
            safeCourseId,
            safeSemesterId,
            recentIso,
            previousIso,
            recentIso,
          ]
        : [
            recentIso,
            previousIso,
            recentIso,
            recentIso,
            previousIso,
            recentIso,
            safeCourseId,
            recentIso,
            previousIso,
            recentIso,
          ]
    ),
    db.all(
      `
        SELECT
          h.subject_id,
          COALESCE(s.name, 'Предмет') AS subject_name,
          COUNT(*)::int AS overdue_homework_total,
          COUNT(DISTINCT sg.student_id)::int AS at_risk_students
        FROM student_groups sg
        JOIN homework h
          ON h.subject_id = sg.subject_id
         AND (h.group_number = sg.group_number OR h.group_number IS NULL)
        LEFT JOIN subjects s ON s.id = h.subject_id
        WHERE h.course_id = ?
          ${homeworkSemesterClause}
          AND COALESCE(h.is_teacher_homework, 0) = 1
          AND COALESCE(h.status, 'published') = 'published'
          AND COALESCE(NULLIF(TRIM(COALESCE(h.custom_due_date, '')), ''), NULLIF(TRIM(COALESCE(h.class_date, '')), '')) < ?
          AND NOT EXISTS (
            SELECT 1
            FROM homework_submissions hs
            WHERE hs.homework_id = h.id
              AND hs.student_id = sg.student_id
          )
        GROUP BY h.subject_id, s.name
        ORDER BY overdue_homework_total DESC, subject_name ASC
      `,
      hasSemester ? [safeCourseId, safeSemesterId, today] : [safeCourseId, today]
    ),
    db.all(
      `
        SELECT
          h.subject_id,
          COALESCE(s.name, 'Предмет') AS subject_name,
          COUNT(*) FILTER (
            WHERE jg.id IS NULL
              AND hs.submitted_at <= (?::timestamptz - (48 * INTERVAL '1 hour'))
          )::int AS sla_overdue_ungraded
        FROM homework_submissions hs
        JOIN homework h ON h.id = hs.homework_id
        LEFT JOIN subjects s ON s.id = h.subject_id
        LEFT JOIN journal_columns jc
          ON jc.source_homework_id = h.id
         AND COALESCE(jc.is_archived, 0) = 0
        LEFT JOIN journal_grades jg
          ON jg.column_id = jc.id
         AND jg.student_id = hs.student_id
         AND jg.deleted_at IS NULL
        WHERE h.course_id = ?
          ${homeworkSemesterClause}
          AND COALESCE(h.is_teacher_homework, 0) = 1
        GROUP BY h.subject_id, s.name
        ORDER BY sla_overdue_ungraded DESC, subject_name ASC
      `,
      hasSemester ? [now.toISOString(), safeCourseId, safeSemesterId] : [now.toISOString(), safeCourseId]
    ),
  ]);

  const studentsTotal = Number(studentsRow?.count || 0);
  const studentsAtRisk = Number(riskRow?.any_risk_students || 0);
  const highRiskStudents = Number(riskRow?.high_risk_students || 0);
  const overdueHomeworkTotal = Number(riskRow?.overdue_total || 0);
  const submissionsTotal = Number(homeworkSlaRow?.submissions_total || 0);
  const ungradedTotal = Number(homeworkSlaRow?.ungraded_total || 0);
  const overdueUngradedTotal = Number(homeworkSlaRow?.overdue_ungraded_total || 0);
  const attendanceTotal = Number(attendanceRow?.total_records || 0);
  const attendanceAbsent = Number(attendanceRow?.absent_count || 0);
  const attendanceLate = Number(attendanceRow?.late_count || 0);

  const riskStudentsShare = studentsTotal > 0 ? Math.round((studentsAtRisk / studentsTotal) * 100) : 0;
  const slaOverdueShare = submissionsTotal > 0 ? Math.round((overdueUngradedTotal / submissionsTotal) * 100) : 0;
  const attendanceAbsentShare = attendanceTotal > 0 ? Math.round((attendanceAbsent / attendanceTotal) * 100) : 0;
  const attendanceLateShare = attendanceTotal > 0 ? Math.round((attendanceLate / attendanceTotal) * 100) : 0;

  const bySubject = new Map();
  (trendRows || []).forEach((row) => {
    const subjectId = Number(row.subject_id || 0);
    if (!Number.isFinite(subjectId) || subjectId < 1) return;
    const recentRatio = Number(row.recent_ratio);
    const previousRatio = Number(row.previous_ratio);
    const recentPercent = Number.isFinite(recentRatio) ? Math.round(recentRatio * 100) : null;
    const previousPercent = Number.isFinite(previousRatio) ? Math.round(previousRatio * 100) : null;
    bySubject.set(subjectId, {
      subject_id: subjectId,
      subject_name: String(row.subject_name || 'Предмет'),
      recent_score_percent: recentPercent,
      previous_score_percent: previousPercent,
      delta_score_percent: (
        recentPercent === null || previousPercent === null
          ? null
          : (recentPercent - previousPercent)
      ),
      recent_grade_events: Number(row.recent_count || 0),
      previous_grade_events: Number(row.previous_count || 0),
      overdue_homework_total: 0,
      at_risk_students: 0,
      sla_overdue_ungraded: 0,
    });
  });
  (overdueBySubjectRows || []).forEach((row) => {
    const subjectId = Number(row.subject_id || 0);
    if (!Number.isFinite(subjectId) || subjectId < 1) return;
    if (!bySubject.has(subjectId)) {
      bySubject.set(subjectId, {
        subject_id: subjectId,
        subject_name: String(row.subject_name || 'Предмет'),
        recent_score_percent: null,
        previous_score_percent: null,
        delta_score_percent: null,
        recent_grade_events: 0,
        previous_grade_events: 0,
        overdue_homework_total: 0,
        at_risk_students: 0,
        sla_overdue_ungraded: 0,
      });
    }
    const target = bySubject.get(subjectId);
    target.overdue_homework_total = Number(row.overdue_homework_total || 0);
    target.at_risk_students = Number(row.at_risk_students || 0);
  });
  (slaBySubjectRows || []).forEach((row) => {
    const subjectId = Number(row.subject_id || 0);
    if (!Number.isFinite(subjectId) || subjectId < 1) return;
    if (!bySubject.has(subjectId)) {
      bySubject.set(subjectId, {
        subject_id: subjectId,
        subject_name: String(row.subject_name || 'Предмет'),
        recent_score_percent: null,
        previous_score_percent: null,
        delta_score_percent: null,
        recent_grade_events: 0,
        previous_grade_events: 0,
        overdue_homework_total: 0,
        at_risk_students: 0,
        sla_overdue_ungraded: 0,
      });
    }
    const target = bySubject.get(subjectId);
    target.sla_overdue_ungraded = Number(row.sla_overdue_ungraded || 0);
  });

  const subjects = Array.from(bySubject.values())
    .sort((a, b) => {
      const severityA = (Number(a.at_risk_students || 0) * 100)
        + (Number(a.sla_overdue_ungraded || 0) * 10)
        + Number(a.overdue_homework_total || 0)
        + (Number(a.delta_score_percent || 0) < 0 ? Math.abs(Number(a.delta_score_percent || 0)) : 0);
      const severityB = (Number(b.at_risk_students || 0) * 100)
        + (Number(b.sla_overdue_ungraded || 0) * 10)
        + Number(b.overdue_homework_total || 0)
        + (Number(b.delta_score_percent || 0) < 0 ? Math.abs(Number(b.delta_score_percent || 0)) : 0);
      if (severityA !== severityB) return severityB - severityA;
      return String(a.subject_name || '').localeCompare(String(b.subject_name || ''));
    })
    .slice(0, 10);

  return {
    generated_at: new Date().toISOString(),
    course_id: safeCourseId,
    semester_id: hasSemester ? safeSemesterId : null,
    summary: {
      students_total: studentsTotal,
      students_at_risk: studentsAtRisk,
      high_risk_students: highRiskStudents,
      risk_students_share: riskStudentsShare,
      overdue_homework_total: overdueHomeworkTotal,
      sla_submissions_total: submissionsTotal,
      sla_ungraded_total: ungradedTotal,
      sla_overdue_ungraded_total: overdueUngradedTotal,
      sla_overdue_share: slaOverdueShare,
      attendance_absent_share: attendanceAbsentShare,
      attendance_late_share: attendanceLateShare,
    },
    subjects,
  };
}

async function buildMyDayData(user, role = 'student', roleList = []) {
  const courseId = Number(user.course_id || 1);
  const activeSemester = await getActiveSemester(courseId);
  const now = new Date();
  const todayStr = formatLocalDate(now);
  const tomorrowStr = formatLocalDate(addDays(now, 1));
  const dayName = getDayNameFromDate(todayStr);
  const weekNumber = getAcademicWeekForSemester(now, activeSemester);
  const nowIso = new Date().toISOString();
  const normalizedRoleList = normalizeRoleList([role, ...(Array.isArray(roleList) ? roleList : [])]);
  const normalizedRole = normalizedRoleList[0] || String(role || '').toLowerCase() || 'student';
  const isStaffRole = normalizedRoleList.some((roleKey) => ['teacher', 'admin', 'deanery'].includes(roleKey));

  const windowEndShort = formatLocalDate(addDays(now, 7));
  const deadlinesWindowEnd = formatLocalDate(addDays(now, 14));
  const deadlinesWindowStart = formatLocalDate(addDays(now, -7));

  const studentGroups = await db.all(
    `
      SELECT sg.subject_id, sg.group_number, s.name AS subject_name
      FROM student_groups sg
      JOIN subjects s ON s.id = sg.subject_id
      WHERE sg.student_id = ? AND s.course_id = ? AND s.visible = 1
    `,
    [user.id, courseId]
  );

  let workloadTargets = (studentGroups || []).map((row) => ({
    subject_id: Number(row.subject_id),
    group_number: Number(row.group_number),
    subject_name: row.subject_name,
  }));

  if (!workloadTargets.length && isStaffRole) {
    const teacherTargets = await db.all(
      `
        SELECT ts.subject_id, ts.group_number, s.name AS subject_name
        FROM teacher_subjects ts
        JOIN subjects s ON s.id = ts.subject_id
        WHERE ts.user_id = ? AND s.course_id = ? AND s.visible = 1
      `,
      [user.id, courseId]
    );
    workloadTargets = (teacherTargets || []).map((row) => ({
      subject_id: Number(row.subject_id),
      group_number: row.group_number === null ? null : Number(row.group_number),
      subject_name: row.subject_name,
    }));
  }

  const targetMap = new Map();
  workloadTargets.forEach((target) => {
    const subjectId = Number(target.subject_id);
    if (!Number.isFinite(subjectId) || subjectId < 1) return;
    const groupNumber = target.group_number === null ? null : Number(target.group_number || 0);
    const normalizedGroup = Number.isFinite(groupNumber) && groupNumber > 0 ? groupNumber : null;
    const key = `${subjectId}|${normalizedGroup === null ? 'all' : normalizedGroup}`;
    if (!targetMap.has(key)) {
      targetMap.set(key, {
        subject_id: subjectId,
        group_number: normalizedGroup,
        subject_name: target.subject_name || '',
      });
    }
  });
  workloadTargets = Array.from(targetMap.values());
  const studentHasOwnSubjects = Boolean((studentGroups || []).length);
  const whatIfSubjectMap = new Map();
  (studentGroups || []).forEach((row) => {
    const subjectId = Number(row.subject_id || 0);
    if (!Number.isFinite(subjectId) || subjectId < 1) return;
    if (!whatIfSubjectMap.has(subjectId)) {
      whatIfSubjectMap.set(subjectId, {
        subject_id: subjectId,
        subject_name: row.subject_name || 'Предмет',
      });
    }
  });
  const whatIfSubjects = Array.from(whatIfSubjectMap.values()).sort((a, b) => (
    String(a.subject_name || '').localeCompare(String(b.subject_name || ''))
  ));

  const buildScope = (alias) => {
    const chunks = [];
    const params = [];
    workloadTargets.forEach((target) => {
      if (target.group_number === null) {
        chunks.push(`${alias}.subject_id = ?`);
        params.push(target.subject_id);
      } else {
        chunks.push(`(${alias}.subject_id = ? AND ${alias}.group_number = ?)`);
        params.push(target.subject_id, target.group_number);
      }
    });
    return { clause: chunks.length ? chunks.join(' OR ') : '1=0', params };
  };

  const parseDateOnly = (rawValue) => {
    if (!rawValue) return null;
    const date = new Date(rawValue);
    if (Number.isNaN(date.getTime())) return null;
    return formatLocalDate(date);
  };

  const loadClassesForDate = async (dateValue) => {
    const targetDayName = getDayNameFromDate(dateValue);
    if (!targetDayName || !workloadTargets.length) {
      return [];
    }
    const dateAsDate = new Date(`${dateValue}T12:00:00`);
    const weekForDate = getAcademicWeekForSemester(dateAsDate, activeSemester);
    const scope = buildScope('se');
    const params = [weekForDate, courseId, targetDayName];
    if (activeSemester) {
      params.push(activeSemester.id);
    }
    params.push(...scope.params);
    const semesterClause = activeSemester
      ? 'AND (se.semester_id = ? OR se.semester_id IS NULL)'
      : 'AND se.semester_id IS NULL';
    const rows = await db.all(
      `
        SELECT se.*, s.name AS subject_name
        FROM schedule_entries se
        JOIN subjects s ON s.id = se.subject_id
        WHERE se.week_number = ?
          AND se.course_id = ?
          AND se.day_of_week = ?
          ${semesterClause}
          AND s.visible = 1
          AND (${scope.clause})
        ORDER BY se.class_number ASC
      `,
      params
    );
    return (rows || []).map((row) => {
      const slot = bellSchedule[row.class_number] || {};
      return {
        id: Number(row.id),
        subject_id: Number(row.subject_id),
        subject_name: row.subject_name,
        lesson_type: row.lesson_type || null,
        class_number: Number(row.class_number),
        group_number: row.group_number === null ? null : Number(row.group_number),
        day_of_week: row.day_of_week,
        class_date: dateValue,
        day_context: dateValue === todayStr ? 'today' : 'tomorrow',
        start: slot.start || '',
        end: slot.end || '',
      };
    });
  };

  const classesToday = await loadClassesForDate(todayStr);
  const classesTomorrow = await loadClassesForDate(tomorrowStr);

  let currentClass = null;
  let nextClass = null;
  const nowMs = now.getTime();
  classesToday.forEach((cls) => {
    if (!cls.start || !cls.end) return;
    const startAt = new Date(`${todayStr}T${cls.start}:00`);
    const endAt = new Date(`${todayStr}T${cls.end}:00`);
    const startMs = startAt.getTime();
    const endMs = endAt.getTime();
    if (nowMs >= startMs && nowMs <= endMs) {
      currentClass = { ...cls, startAt: startAt.toISOString(), endAt: endAt.toISOString() };
    } else if (nowMs < startMs && !nextClass) {
      nextClass = { ...cls, startAt: startAt.toISOString(), endAt: endAt.toISOString() };
    }
  });

  const nextClasses = [...classesToday, ...classesTomorrow]
    .map((cls) => {
      if (!cls.start) return null;
      const startAt = new Date(`${cls.class_date}T${cls.start}:00`);
      return { ...cls, startAt: startAt.toISOString() };
    })
    .filter(Boolean)
    .filter((cls) => new Date(cls.startAt).getTime() >= nowMs)
    .sort((a, b) => new Date(a.startAt).getTime() - new Date(b.startAt).getTime())
    .slice(0, 6);

  const canSubmitHomework = studentHasOwnSubjects;
  const includeStudentHomeworkInMyDay = Boolean(settingsCache.myday_show_student_homework);
  let homeworkItems = [];
  if (workloadTargets.length) {
    const scope = buildScope('h');
    const params = [user.id, user.id, courseId];
    if (activeSemester) {
      params.push(activeSemester.id);
    }
    params.push(nowIso, ...scope.params);
    const semesterClause = activeSemester
      ? 'AND (h.semester_id = ? OR h.semester_id IS NULL)'
      : 'AND h.semester_id IS NULL';
    const studentHomeworkVisibilityClause = includeStudentHomeworkInMyDay
      ? ''
      : 'AND COALESCE(h.is_teacher_homework, 0) = 1';
    const rows = await db.all(
      `
        SELECT
          h.id,
          h.description,
          h.custom_due_date,
          h.class_date,
          h.subject_id,
          h.group_number,
          h.created_by,
          h.created_at,
          h.is_control,
          h.is_credit,
          h.is_teacher_homework,
          h.meeting_url,
          subj.name AS subject_name,
          hc.id AS completion_id,
          hs.id AS submission_id,
          hs.submitted_at
        FROM homework h
        JOIN subjects subj ON subj.id = h.subject_id
        LEFT JOIN homework_completions hc ON hc.homework_id = h.id AND hc.user_id = ?
        LEFT JOIN homework_submissions hs ON hs.homework_id = h.id AND hs.student_id = ?
        WHERE h.course_id = ?
          ${semesterClause}
          ${studentHomeworkVisibilityClause}
          AND COALESCE(h.status, 'published') = 'published'
          AND (h.scheduled_at IS NULL OR h.scheduled_at <= ?)
          AND (h.custom_due_date IS NOT NULL OR h.class_date IS NOT NULL)
          AND (${scope.clause})
        ORDER BY COALESCE(h.custom_due_date, h.class_date) ASC, h.created_at DESC
      `,
      params
    );

    homeworkItems = (rows || []).map((row) => {
      const deadline = row.custom_due_date || row.class_date || null;
      const submittedDate = parseDateOnly(row.submitted_at);
      let submissionStatus = 'pending';
      if (row.submission_id) {
        const isLate = Boolean(deadline && submittedDate && submittedDate > deadline);
        submissionStatus = isLate ? 'submitted_late' : 'submitted_on_time';
      } else if (deadline && deadline < todayStr) {
        submissionStatus = 'overdue';
      }
      return {
        id: Number(row.id),
        type: 'homework',
        description: row.description || 'Завдання',
        subject_id: Number(row.subject_id),
        subject_name: row.subject_name,
        group_number: row.group_number === null ? null : Number(row.group_number),
        deadline_date: deadline,
        created_by: row.created_by,
        created_at: row.created_at,
        is_control: Number(row.is_control || 0) === 1,
        is_credit: Number(row.is_credit || 0) === 1,
        is_teacher_homework: Number(row.is_teacher_homework || 0) === 1,
        meeting_url: row.meeting_url || null,
        completed: Boolean(row.completion_id),
        submission_id: row.submission_id ? Number(row.submission_id) : null,
        submitted_at: row.submitted_at || null,
        submitted_date: submittedDate,
        submission_status: submissionStatus,
        can_submit: canSubmitHomework,
      };
    });
  }

  let teamworkDeadlines = [];
  const subjectIds = Array.from(new Set(workloadTargets.map((row) => Number(row.subject_id)).filter(Boolean)));
  if (subjectIds.length) {
    const placeholders = subjectIds.map(() => '?').join(',');
    const params = [courseId];
    if (activeSemester) {
      params.push(activeSemester.id);
    }
    params.push(todayStr, deadlinesWindowEnd, ...subjectIds);
    const semesterClause = activeSemester
      ? 'AND (t.semester_id = ? OR t.semester_id IS NULL)'
      : 'AND t.semester_id IS NULL';
    const rows = await db.all(
      `
        SELECT t.id, t.title, t.due_date, t.subject_id, s.name AS subject_name
        FROM teamwork_tasks t
        JOIN subjects s ON s.id = t.subject_id
        WHERE t.course_id = ?
          ${semesterClause}
          AND t.due_date IS NOT NULL
          AND t.due_date >= ?
          AND t.due_date <= ?
          AND t.subject_id IN (${placeholders})
        ORDER BY t.due_date ASC, t.created_at DESC
      `,
      params
    );
    teamworkDeadlines = (rows || []).map((row) => ({
      id: Number(row.id),
      type: 'teamwork',
      description: row.title || 'Командна задача',
      subject_id: Number(row.subject_id),
      subject_name: row.subject_name,
      deadline_date: row.due_date,
      submission_status: row.due_date < todayStr ? 'overdue' : 'pending',
      can_submit: false,
    }));
  }

  const deadlines = [...homeworkItems, ...teamworkDeadlines]
    .filter((item) => item.deadline_date && item.deadline_date >= deadlinesWindowStart && item.deadline_date <= deadlinesWindowEnd)
    .sort((a, b) => String(a.deadline_date || '').localeCompare(String(b.deadline_date || '')));

  const actionableDeadlines = deadlines.filter((item) => item.submission_status !== 'submitted_on_time');
  const deadlinesFocus = (actionableDeadlines.length ? actionableDeadlines : deadlines).slice(0, 3);

  const upcomingItems = homeworkItems.filter((item) => {
    if (!item.deadline_date) return false;
    return item.deadline_date >= todayStr && item.deadline_date <= deadlinesWindowEnd;
  });

  let topPriorities = [];
  if (upcomingItems.length) {
    const earliest = upcomingItems.find((item) => item.submission_status !== 'submitted_on_time') || upcomingItems[0];
    const subjectCounts = {};
    upcomingItems.forEach((item) => {
      if (item.submission_status === 'submitted_on_time') return;
      const key = String(item.subject_id);
      subjectCounts[key] = (subjectCounts[key] || 0) + 1;
    });
    let topSubjectId = null;
    let topCount = 0;
    Object.entries(subjectCounts).forEach(([key, count]) => {
      if (count > topCount) {
        topCount = count;
        topSubjectId = Number(key);
      }
    });
    topPriorities.push({ type: 'earliest', ...earliest });
    if (topSubjectId && topSubjectId !== earliest.subject_id) {
      const topSubjectItem = upcomingItems.find((item) => item.subject_id === topSubjectId);
      if (topSubjectItem) {
        topPriorities.push({ type: 'workload', ...topSubjectItem });
      }
    }
  }

  let reminders = [];
  if (activeSemester) {
    const rows = await db.all(
      `
        SELECT id, title, note, remind_date, remind_time, is_done, created_at
        FROM personal_reminders
        WHERE user_id = ?
          AND course_id = ?
          AND semester_id = ?
          AND remind_date >= ?
          AND remind_date <= ?
        ORDER BY remind_date ASC, remind_time ASC NULLS LAST, created_at DESC
      `,
      [user.id, courseId, activeSemester.id, todayStr, windowEndShort]
    );
    reminders = (rows || []).map((row) => ({
      id: row.id,
      title: row.title,
      note: row.note,
      remind_date: row.remind_date,
      remind_time: row.remind_time,
      is_done: Boolean(row.is_done),
    }));
  }

  let reviewQueue = {
    enabled: false,
    overdue_threshold_hours: REVIEW_QUEUE_OVERDUE_HOURS,
    counts: { overdue: 0, new: 0, no_comment: 0 },
    total: 0,
    items: [],
    truncated: false,
    templates: REVIEW_QUEUE_FEEDBACK_TEMPLATES,
  };
  if (isStaffRole) {
    reviewQueue = await buildMyDayReviewQueue({
      userId: Number(user.id),
      courseId,
      semesterId: activeSemester ? Number(activeSemester.id) : null,
      roleKeys: normalizedRoleList,
      now,
    });
  }

  const submittedOnTimeCount = homeworkItems.filter((item) => item.submission_status === 'submitted_on_time').length;
  const submittedLateCount = homeworkItems.filter((item) => item.submission_status === 'submitted_late').length;
  const overdueCount = homeworkItems.filter((item) => item.submission_status === 'overdue').length;
  const dueSoonCount = homeworkItems.filter((item) => (
    item.submission_status === 'pending' && item.deadline_date && item.deadline_date >= todayStr && item.deadline_date <= tomorrowStr
  )).length;
  const submittedTotalCount = submittedOnTimeCount + submittedLateCount;
  const onTimeRatio = submittedTotalCount ? submittedOnTimeCount / submittedTotalCount : 0;
  const onTimeShare = submittedTotalCount ? Math.round((submittedOnTimeCount / submittedTotalCount) * 100) : null;
  const openReminders = reminders.filter((item) => !item.is_done).length;

  const riskySubjectMap = new Map();
  homeworkItems.forEach((item) => {
    if (item.submission_status !== 'overdue' && item.submission_status !== 'pending') return;
    const key = String(item.subject_id);
    const nextCount = Number(riskySubjectMap.get(key) || 0) + 1;
    riskySubjectMap.set(key, nextCount);
  });
  const riskySubjectCount = riskySubjectMap.size;
  const riskiestSubject = topPriorities.find((item) => item.type === 'workload') || topPriorities[0] || null;

  let gradeRows = [];
  if (studentHasOwnSubjects && subjectIds.length) {
    const placeholders = subjectIds.map(() => '?').join(',');
    const params = [user.id, courseId];
    if (activeSemester) {
      params.push(activeSemester.id);
    }
    params.push(...subjectIds);
    const semesterClause = activeSemester
      ? 'AND (jc.semester_id = ? OR jc.semester_id IS NULL)'
      : 'AND jc.semester_id IS NULL';
    gradeRows = await db.all(
      `
        SELECT
          jc.column_type,
          jc.max_points,
          CASE
            WHEN jgm.status = 'adjusted' AND jgm.moderated_score IS NOT NULL THEN jgm.moderated_score
            ELSE jg.score
          END AS score,
          jg.graded_at
        FROM journal_columns jc
        JOIN journal_grades jg ON jg.column_id = jc.id
        LEFT JOIN journal_grade_moderations jgm
          ON jgm.column_id = jg.column_id
         AND jgm.student_id = jg.student_id
        WHERE jg.student_id = ?
          AND jc.course_id = ?
          ${semesterClause}
          AND jc.is_archived = 0
          AND jg.deleted_at IS NULL
          AND jc.subject_id IN (${placeholders})
      `,
      params
    );
  }
  let competencySignalRows = [];
  if (studentHasOwnSubjects && subjectIds.length) {
    const placeholders = subjectIds.map(() => '?').join(',');
    const params = [user.id, courseId];
    if (activeSemester) {
      params.push(activeSemester.id);
    }
    params.push(...subjectIds);
    const semesterClause = activeSemester
      ? 'AND (ce.semester_id = ? OR ce.semester_id IS NULL)'
      : 'AND ce.semester_id IS NULL';
    competencySignalRows = await db.all(
      `
        SELECT ce.competency_key, ce.score, ce.created_at
        FROM competency_evaluations ce
        WHERE ce.student_id = ?
          AND (ce.course_id = ? OR ce.course_id IS NULL)
          ${semesterClause}
          AND ce.subject_id IN (${placeholders})
        ORDER BY ce.created_at DESC
        LIMIT 1200
      `,
      params
    );
  } else if (isStaffRole && workloadTargets.length) {
    const scopeChunks = [];
    const scopeParams = [];
    workloadTargets.forEach((target) => {
      const subjectId = Number(target.subject_id || 0);
      if (!Number.isFinite(subjectId) || subjectId < 1) return;
      if (target.group_number === null) {
        scopeChunks.push('(ce.subject_id = ?)');
        scopeParams.push(subjectId);
        return;
      }
      const groupNumber = Number(target.group_number || 0);
      if (!Number.isInteger(groupNumber) || groupNumber < 1) return;
      scopeChunks.push('(ce.subject_id = ? AND sg.group_number = ?)');
      scopeParams.push(subjectId, groupNumber);
    });
    if (scopeChunks.length) {
      const params = [courseId];
      if (activeSemester) {
        params.push(activeSemester.id);
      }
      params.push(...scopeParams);
      const semesterClause = activeSemester
        ? 'AND (ce.semester_id = ? OR ce.semester_id IS NULL)'
        : 'AND ce.semester_id IS NULL';
      competencySignalRows = await db.all(
        `
          SELECT ce.competency_key, ce.score, ce.created_at
          FROM competency_evaluations ce
          JOIN student_groups sg
            ON sg.student_id = ce.student_id
           AND sg.subject_id = ce.subject_id
          WHERE (ce.course_id = ? OR ce.course_id IS NULL)
            ${semesterClause}
            AND (${scopeChunks.join(' OR ')})
          ORDER BY ce.created_at DESC
          LIMIT 2400
        `,
        params
      );
    }
  }

  const feedbackSince = addDays(now, -14).getTime();
  const feedbackCount = (gradeRows || []).filter((row) => {
    const gradedAt = row.graded_at ? new Date(row.graded_at).getTime() : Number.NaN;
    return Number.isFinite(gradedAt) && gradedAt >= feedbackSince;
  }).length;

  let progressDashboard = {
    enabled: false,
    admission_target: STUDENT_RISK_ADMISSION_TARGET,
    subjects_total: 0,
    at_risk_count: 0,
    high_risk_count: 0,
    medium_risk_count: 0,
    overall_on_time_share: onTimeShare,
    subjects: [],
  };
  if (studentHasOwnSubjects && whatIfSubjects.length) {
    const admissionTarget = STUDENT_RISK_ADMISSION_TARGET;
    const forecastRows = await Promise.all(
      whatIfSubjects.map(async (subject) => {
        const subjectId = Number(subject.subject_id || 0);
        if (!Number.isFinite(subjectId) || subjectId < 1) return null;
        try {
          const forecast = await buildMyDayWhatIfForecast({
            userId: Number(user.id),
            courseId,
            semesterId: activeSemester ? Number(activeSemester.id) : null,
            subjectId,
            targetScores: [admissionTarget, 75, 90],
          });
          if (!forecast) return null;
          return {
            subject_id: subjectId,
            subject_name: subject.subject_name || forecast.subject?.name || 'Предмет',
            forecast,
          };
        } catch (err) {
          return null;
        }
      })
    );
    const subjectItems = (forecastRows || [])
      .filter(Boolean)
      .map((row) => {
        const subjectId = Number(row.subject_id || 0);
        const forecast = row.forecast || {};
        const subjectHomework = (homeworkItems || []).filter((item) => Number(item.subject_id || 0) === subjectId);
        const submittedOnTime = subjectHomework.filter((item) => item.submission_status === 'submitted_on_time').length;
        const submittedLate = subjectHomework.filter((item) => item.submission_status === 'submitted_late').length;
        const submittedTotal = submittedOnTime + submittedLate;
        const onTimeShareBySubject = submittedTotal ? Math.round((submittedOnTime / submittedTotal) * 100) : null;
        const overdueBySubject = subjectHomework.filter((item) => item.submission_status === 'overdue').length;
        const dueSoonBySubject = subjectHomework.filter((item) => (
          item.submission_status === 'pending'
          && item.deadline_date
          && item.deadline_date >= todayStr
          && item.deadline_date <= tomorrowStr
        )).length;
        const currentFinalScore = Math.max(0, Math.min(100, Number(forecast.current_final_score || 0)));
        const maxReachableFinalScore = Math.max(currentFinalScore, Math.min(100, Number(forecast.max_reachable_final_score || 0)));
        const remainingColumnsCount = Math.max(0, Number(forecast.remaining_columns_count || 0));

        let riskLevel = 'low';
        let riskReason = 'Стабільний прогрес по предмету.';
        if (maxReachableFinalScore < admissionTarget) {
          riskLevel = 'high';
          riskReason = `Навіть максимальний сценарій дає < ${admissionTarget}. Потрібен план із викладачем.`;
        } else if (currentFinalScore < admissionTarget && overdueBySubject > 0) {
          riskLevel = 'high';
          riskReason = 'Фінал нижче цілі та є прострочені задачі.';
        } else if (
          currentFinalScore < admissionTarget
          || overdueBySubject > 0
          || (onTimeShareBySubject !== null && onTimeShareBySubject < STUDENT_RISK_ON_TIME_WARNING_PERCENT)
        ) {
          riskLevel = 'medium';
          riskReason = 'Потрібно стабілізувати темп здач і добрати бали.';
        }

        const riskScore = riskLevel === 'high' ? 2 : riskLevel === 'medium' ? 1 : 0;
        const gapToTarget = Math.max(0, Math.round((admissionTarget - currentFinalScore) * 100) / 100);
        return {
          subject_id: subjectId,
          subject_name: row.subject_name,
          current_final_score: Math.round(currentFinalScore * 100) / 100,
          max_reachable_final_score: Math.round(maxReachableFinalScore * 100) / 100,
          remaining_columns_count: remainingColumnsCount,
          overdue_count: overdueBySubject,
          due_soon_count: dueSoonBySubject,
          submitted_total: submittedTotal,
          on_time_share: onTimeShareBySubject,
          target_gap: gapToTarget,
          risk_level: riskLevel,
          risk_score: riskScore,
          risk_reason: riskReason,
          review_href: `/journal?subject_id=${encodeURIComponent(String(subjectId))}`,
        };
      })
      .sort((a, b) => {
        if (a.risk_score !== b.risk_score) return b.risk_score - a.risk_score;
        if (a.max_reachable_final_score !== b.max_reachable_final_score) {
          return a.max_reachable_final_score - b.max_reachable_final_score;
        }
        return String(a.subject_name || '').localeCompare(String(b.subject_name || ''));
      });

    const highRiskCount = subjectItems.filter((item) => item.risk_level === 'high').length;
    const mediumRiskCount = subjectItems.filter((item) => item.risk_level === 'medium').length;
    progressDashboard = {
      enabled: true,
      admission_target: admissionTarget,
      subjects_total: subjectItems.length,
      at_risk_count: highRiskCount + mediumRiskCount,
      high_risk_count: highRiskCount,
      medium_risk_count: mediumRiskCount,
      overall_on_time_share: onTimeShare,
      subjects: subjectItems,
    };
  }

  const clamp01 = (value) => Math.max(0, Math.min(1, Number(value) || 0));
  const hasGradeSignals = Array.isArray(gradeRows) && gradeRows.length > 0;
  const heuristicFallback = hasGradeSignals ? 0.52 : 0;
  const avg = (values, fallback = 0.52) => {
    if (!Array.isArray(values) || !values.length) return fallback;
    return values.reduce((acc, item) => acc + item, 0) / values.length;
  };
  const pickTypeBuckets = (rows, predicate = () => true) => {
    const buckets = { homework: [], seminar: [], exam: [], credit: [], custom: [] };
    (rows || []).forEach((row) => {
      if (!predicate(row)) return;
      const type = String(row.column_type || 'custom');
      if (!Object.prototype.hasOwnProperty.call(buckets, type)) return;
      const score = Number(row.score);
      const maxPoints = Number(row.max_points);
      if (!Number.isFinite(score) || !Number.isFinite(maxPoints) || maxPoints <= 0) return;
      buckets[type].push(clamp01(score / maxPoints));
    });
    return buckets;
  };

  const recentSince = addDays(now, -21).getTime();
  const previousSince = addDays(now, -42).getTime();
  const baseBuckets = pickTypeBuckets(gradeRows);
  const recentBuckets = pickTypeBuckets(gradeRows, (row) => {
    const gradedAt = row.graded_at ? new Date(row.graded_at).getTime() : Number.NaN;
    return Number.isFinite(gradedAt) && gradedAt >= recentSince;
  });
  const previousBuckets = pickTypeBuckets(gradeRows, (row) => {
    const gradedAt = row.graded_at ? new Date(row.graded_at).getTime() : Number.NaN;
    return Number.isFinite(gradedAt) && gradedAt >= previousSince && gradedAt < recentSince;
  });

  const weightVector = (buckets) => ({
    homework: avg(buckets.homework, heuristicFallback),
    seminar: avg(buckets.seminar, heuristicFallback),
    exam: avg(buckets.exam, heuristicFallback),
    credit: avg(buckets.credit, heuristicFallback),
    custom: avg(buckets.custom, heuristicFallback),
  });

  const baseVector = weightVector(baseBuckets);
  const recentVector = weightVector(recentBuckets);
  const previousVector = weightVector(previousBuckets);
  const selfOrgSignal = onTimeShare === null ? heuristicFallback : clamp01(onTimeShare / 100);
  const competencyHeuristic = {
    leadership: (vector) => (vector.custom * 0.45) + (vector.seminar * 0.35) + (vector.exam * 0.2),
    negotiation: (vector) => (vector.seminar * 0.45) + (vector.custom * 0.35) + (vector.exam * 0.2),
    communication: (vector) => (vector.seminar * 0.55) + (vector.custom * 0.25) + (vector.homework * 0.2),
    analysis: (vector) => (vector.exam * 0.55) + (vector.homework * 0.3) + (vector.custom * 0.15),
    teamwork: (vector) => (vector.seminar * 0.45) + (vector.credit * 0.3) + (vector.custom * 0.25),
    self_organization: (vector) => (vector.homework * 0.45) + (vector.credit * 0.25) + (selfOrgSignal * 0.3),
    critical_thinking: (vector) => (vector.exam * 0.45) + (vector.analysis * 0.35) + (vector.seminar * 0.2),
    resilience: (vector) => (selfOrgSignal * 0.45) + (vector.credit * 0.25) + (vector.homework * 0.3),
  };
  const baseWithDerived = {
    ...baseVector,
    analysis: (baseVector.exam * 0.55) + (baseVector.homework * 0.3) + (baseVector.custom * 0.15),
  };
  const recentWithDerived = {
    ...recentVector,
    analysis: (recentVector.exam * 0.55) + (recentVector.homework * 0.3) + (recentVector.custom * 0.15),
  };
  const previousWithDerived = {
    ...previousVector,
    analysis: (previousVector.exam * 0.55) + (previousVector.homework * 0.3) + (previousVector.custom * 0.15),
  };
  const buildHeuristicProfile = () => {
    const competencies = COMPETENCY_DEFINITIONS.map((definition) => {
      const compute = competencyHeuristic[definition.key] || ((vector) => (
        (vector.homework + vector.seminar + vector.exam + vector.credit + vector.custom) / 5
      ));
      const scoreRaw = clamp01(compute(baseWithDerived));
      const recentRaw = clamp01(compute(recentWithDerived));
      const previousRaw = clamp01(compute(previousWithDerived));
      const delta = Math.round((recentRaw - previousRaw) * 100);
      return {
        key: definition.key,
        label: definition.label,
        score: Math.round(scoreRaw * 100),
        delta,
        trend: delta >= 3 ? 'up' : (delta <= -3 ? 'down' : 'steady'),
        has_data: hasGradeSignals,
      };
    });
    const sortedByScore = [...competencies].sort((a, b) => b.score - a.score);
    const sortedByDelta = [...competencies].sort((a, b) => b.delta - a.delta);
    const strongest = sortedByScore[0] || null;
    const weakest = sortedByScore[sortedByScore.length - 1] || null;
    const fastestGrowth = sortedByDelta[0] || null;
    const average = competencies.length
      ? Math.round(competencies.reduce((sum, item) => sum + item.score, 0) / competencies.length)
      : 0;
    return {
      competencies,
      strongest,
      weakest,
      fastest_growth: fastestGrowth,
      average,
      populated_count: hasGradeSignals ? competencies.length : 0,
    };
  };
  const competencyProfile = buildCompetencyProfileFromSignalRows({
    signalRows: competencySignalRows,
    includeEmpty: true,
    now,
  });
  const competencies = Array.isArray(competencyProfile.competencies)
    ? competencyProfile.competencies
    : [];
  const strongestCompetency = competencyProfile.strongest || null;
  const weakestCompetency = competencyProfile.weakest || null;
  const fastestGrowingCompetency = competencyProfile.fastest_growth || null;
  const competencyAverage = Number.isFinite(Number(competencyProfile.average))
    ? Number(competencyProfile.average)
    : 0;
  const competencyTotalMarks = Number.isFinite(Number(competencyProfile.total_marks))
    ? Number(competencyProfile.total_marks)
    : 0;

  const activitySummary = {
    tracked_homework_total: homeworkItems.length,
    submitted_on_time: submittedOnTimeCount,
    submitted_late: submittedLateCount,
    overdue: overdueCount,
    due_soon: dueSoonCount,
    on_time_share: onTimeShare,
    risky_subjects: riskySubjectCount,
    recent_feedback: feedbackCount,
    open_reminders: openReminders,
  };

  const inboxItems = [];
  if (overdueCount > 0) {
    inboxItems.push({
      kind: 'risk',
      title: `Прострочено: ${overdueCount}`,
      meta: 'Закрий прострочки, щоб не втратити темп',
      action_href: '/my-day#deadlinesBlock',
      action_label: 'До дедлайнів',
    });
  }
  if (dueSoonCount > 0) {
    inboxItems.push({
      kind: 'focus',
      title: `На 48 год: ${dueSoonCount}`,
      meta: 'Найближчі завдання потребують уваги',
      action_href: '/my-day#deadlinesBlock',
      action_label: 'Відкрити',
    });
  }
  if (feedbackCount > 0) {
    inboxItems.push({
      kind: 'update',
      title: `Новий фідбек: ${feedbackCount}`,
      meta: 'Оновлені оцінки за 14 днів',
      action_href: '/journal',
      action_label: 'До журналу',
    });
  }
  if (nextClass) {
    inboxItems.push({
      kind: 'class',
      title: `Найближча пара: ${nextClass.subject_name}`,
      meta: `${nextClass.start} - ${nextClass.end}`,
      action_href: '/schedule',
      action_label: 'Розклад',
    });
  }
  if (openReminders > 0) {
    inboxItems.push({
      kind: 'reminder',
      title: `Активні нагадування: ${openReminders}`,
      meta: 'Не забудь перевірити особистий список',
      action_href: '/my-day#inboxBlock',
      action_label: 'Перевірити',
    });
  }
  if (!inboxItems.length) {
    inboxItems.push({
      kind: 'ok',
      title: 'Стабільний темп',
      meta: 'Критичних сигналів зараз немає',
      action_href: '/schedule',
      action_label: 'Розклад',
    });
  }

  let brief = {
    tone: 'calm',
    title: 'Твій день під контролем',
    message: 'Система не бачить критичних ризиків. Тримай темп і закривай задачі в дедлайн.',
    action_label: 'Відкрити розклад',
    action_href: '/schedule',
    reasons: ['Критичних прострочок немає', 'Темп здач стабільний'],
  };

  if (!studentHasOwnSubjects && isStaffRole) {
    brief = {
      tone: 'focus',
      title: 'Оперативний зріз по дисциплінах',
      message: `У фокусі ${workloadTargets.length || 0} предметів, найближчих подій: ${deadlinesFocus.length}.`,
      action_label: 'Відкрити розклад',
      action_href: '/schedule',
      reasons: [
        `Пари на сьогодні/завтра: ${classesToday.length + classesTomorrow.length}`,
        `Актуальні дедлайни: ${deadlinesFocus.length}`,
      ],
    };
  } else if (overdueCount > 0) {
    const subjectHint = riskiestSubject && riskiestSubject.subject_name
      ? `Почни з ${riskiestSubject.subject_name}.`
      : 'Почни з найближчого простроченого завдання.';
    brief = {
      tone: 'risk',
      title: 'Є ризик по дедлайнах',
      message: `Маєш ${overdueCount} прострочених завдань. ${subjectHint}`,
      action_label: 'Закрити дедлайни',
      action_href: '/my-day#deadlinesBlock',
      reasons: [
        `Прострочені задачі: ${overdueCount}`,
        `Предметів у ризику: ${riskySubjectCount}`,
      ],
    };
  } else if (dueSoonCount > 0) {
    brief = {
      tone: 'focus',
      title: 'Фокус на найближчі 48 год',
      message: `Попереду ${dueSoonCount} задач до завтра. Закрий їх зараз, щоб зберегти темп.`,
      action_label: 'Перейти до здачі',
      action_href: '/my-day#deadlinesBlock',
      reasons: [
        `Задачі до завтра: ${dueSoonCount}`,
        `Вчасні здачі: ${onTimeShare === null ? '-' : `${onTimeShare}%`}`,
      ],
    };
  } else if (fastestGrowingCompetency && fastestGrowingCompetency.delta >= 1) {
    brief = {
      tone: 'growth',
      title: 'Помітний прогрес за останній період',
      message: `Прокачується ${fastestGrowingCompetency.label} (+${fastestGrowingCompetency.delta}). Тримай цей фокус.`,
      action_label: 'Переглянути прогрес',
      action_href: '/my-day#competencyBlock',
      reasons: [
        `Сильна сторона: ${strongestCompetency ? strongestCompetency.label : 'н/д'}`,
        `Відміток компетентностей: ${competencyTotalMarks}`,
      ],
    };
  } else if (nextClass) {
    brief = {
      tone: 'calm',
      title: 'Робочий ритм збережено',
      message: `Наступна пара: ${nextClass.subject_name} о ${nextClass.start}. Підготуй матеріали заздалегідь.`,
      action_label: 'До розкладу',
      action_href: '/schedule',
      reasons: [
        `Критичних прострочок: ${overdueCount}`,
        `Ближчі дедлайни: ${deadlinesFocus.length}`,
      ],
    };
  }

  if (strongestCompetency && Number(strongestCompetency.count || 0) > 0 && brief.tone !== 'risk') {
    brief.message = `${brief.message} Додатково: ${strongestCompetency.label} зараз серед найсильніших напрямів.`;
  }

  const defaultWhatIfSubjectId = (
    (riskiestSubject && Number.isFinite(Number(riskiestSubject.subject_id)) && Number(riskiestSubject.subject_id) > 0)
      ? Number(riskiestSubject.subject_id)
      : null
  ) || (whatIfSubjects[0] ? Number(whatIfSubjects[0].subject_id) : null);

  return {
    today: todayStr,
    tomorrow: tomorrowStr,
    day_name: dayName,
    week_number: weekNumber,
    classes_today: classesToday,
    classes_tomorrow: classesTomorrow,
    current_class: currentClass,
    next_class: nextClass,
    next_classes: nextClasses,
    deadlines,
    deadline_focus: deadlinesFocus,
    top_priorities: topPriorities,
    reminders,
    reminders_window_end: windowEndShort,
    activity_summary: activitySummary,
    inbox_items: inboxItems,
    competencies,
    competency_average: competencyAverage,
    competency_total_marks: competencyTotalMarks,
    competency_strongest: strongestCompetency,
    competency_weakest: weakestCompetency,
    competency_fastest_growth: fastestGrowingCompetency,
    progress_dashboard: progressDashboard,
    what_if_subjects: whatIfSubjects,
    what_if_default_subject_id: defaultWhatIfSubjectId,
    review_queue: reviewQueue,
    brief,
    scope_count: workloadTargets.length,
    role: normalizedRole,
  };
}

async function buildMyDayWhatIfForecast({
  userId,
  courseId,
  semesterId,
  subjectId,
  targetScores = [60, 75, 90],
}) {
  const subjectRow = await db.get(
    `
      SELECT s.id, s.name
      FROM student_groups sg
      JOIN subjects s ON s.id = sg.subject_id
      WHERE sg.student_id = ?
        AND s.course_id = ?
        AND s.visible = 1
        AND sg.subject_id = ?
      LIMIT 1
    `,
    [userId, courseId, subjectId]
  );
  if (!subjectRow) return null;

  const gradingSettings = await ensureSubjectGradingSettings(subjectId, courseId, semesterId, userId);
  await syncJournalColumnsFromHomework(subjectId, courseId, semesterId, gradingSettings, userId);
  const columns = await getJournalColumns(subjectId, courseId, semesterId);

  const gradeByColumnId = new Map();
  if (columns.length) {
    const columnIds = columns.map((column) => Number(column.id)).filter((id) => Number.isFinite(id) && id > 0);
    if (columnIds.length) {
      const rows = await db.all(
        `
          SELECT
            jg.column_id,
            CASE
              WHEN jgm.status = 'adjusted' AND jgm.moderated_score IS NOT NULL THEN jgm.moderated_score
              ELSE jg.score
            END AS score
          FROM journal_grades jg
          LEFT JOIN journal_grade_moderations jgm
            ON jgm.column_id = jg.column_id
           AND jgm.student_id = jg.student_id
          WHERE jg.student_id = ?
            AND jg.column_id IN (${columnIds.map(() => '?').join(',')})
            AND jg.deleted_at IS NULL
        `,
        [userId, ...columnIds]
      );
      (rows || []).forEach((row) => {
        const columnId = Number(row.column_id);
        const score = Number(row.score);
        if (!Number.isFinite(columnId) || columnId < 1 || !Number.isFinite(score)) return;
        gradeByColumnId.set(columnId, score);
      });
    }
  }

  const round2 = (value) => Math.round(Number(value || 0) * 100) / 100;
  const clamp01 = (value) => Math.max(0, Math.min(1, Number(value || 0)));
  const typeRows = [];
  let currentFinal = 0;
  let maxPossibleFinal = 0;
  let remainingWeightedPotential = 0;
  let remainingRawMaxTotal = 0;
  let remainingColumnsCount = 0;

  JOURNAL_SCORING_TYPES.forEach((type) => {
    const includedColumns = columns.filter((column) => (
      normalizeColumnType(column.column_type) === type
      && column.include_in_final
      && getGradingTypeEnabled(gradingSettings, type)
    ));
    if (!includedColumns.length) return;

    const typeWeight = getGradingTypeWeightPoints(gradingSettings, type);
    const rawMax = includedColumns.reduce((sum, column) => (
      sum + parsePositiveDecimal(column.max_points, 0)
    ), 0);
    if (!(rawMax > 0)) return;

    let rawEarned = 0;
    let remainingRawMax = 0;
    let completedColumns = 0;
    let remainingColumns = 0;
    includedColumns.forEach((column) => {
      const maxPoints = parsePositiveDecimal(column.max_points, 0);
      const score = gradeByColumnId.get(Number(column.id));
      if (Number.isFinite(score)) {
        rawEarned += Math.max(0, Math.min(maxPoints, score));
        completedColumns += 1;
      } else {
        remainingRawMax += maxPoints;
        remainingColumns += 1;
      }
    });

    const ratio = clamp01(rawEarned / rawMax);
    const currentContribution = typeWeight > 0 ? ratio * typeWeight : 0;
    const typeMaxContribution = typeWeight > 0 ? typeWeight : 0;
    const typeRemainingPotential = typeWeight > 0
      ? (remainingRawMax / rawMax) * typeWeight
      : 0;

    currentFinal += currentContribution;
    maxPossibleFinal += typeMaxContribution;
    remainingWeightedPotential += typeRemainingPotential;
    remainingRawMaxTotal += remainingRawMax;
    remainingColumnsCount += remainingColumns;

    typeRows.push({
      type,
      label: JOURNAL_SCORING_TYPE_META[type]?.label || type,
      completed_columns: completedColumns,
      remaining_columns: remainingColumns,
      raw_earned: round2(rawEarned),
      raw_max: round2(rawMax),
      remaining_raw_max: round2(remainingRawMax),
      current_contribution: round2(currentContribution),
      max_contribution: round2(typeMaxContribution),
      remaining_potential: round2(typeRemainingPotential),
    });
  });

  const normalizedCurrentFinal = round2(Math.min(100, currentFinal));
  const normalizedMaxReachable = round2(Math.min(100, normalizedCurrentFinal + remainingWeightedPotential));
  const uniqueTargets = Array.from(
    new Set((Array.isArray(targetScores) ? targetScores : [60, 75, 90])
      .map((value) => Number(value))
      .filter((value) => Number.isFinite(value) && value >= 0 && value <= 100))
  ).sort((a, b) => a - b);
  const targets = uniqueTargets.map((targetValue) => {
    const target = round2(targetValue);
    const needed = round2(Math.max(0, target - normalizedCurrentFinal));
    if (needed <= 0) {
      return {
        target,
        reachable: true,
        needed_points: 0,
        required_avg_percent: 0,
        required_raw_points: 0,
      };
    }
    if (!(remainingWeightedPotential > 0) || needed > remainingWeightedPotential) {
      return {
        target,
        reachable: false,
        needed_points: needed,
        required_avg_percent: null,
        required_raw_points: null,
      };
    }
    const requiredRatio = needed / remainingWeightedPotential;
    const requiredAvgPercent = round2(requiredRatio * 100);
    const requiredRawPoints = round2(requiredRatio * remainingRawMaxTotal);
    return {
      target,
      reachable: true,
      needed_points: needed,
      required_avg_percent: requiredAvgPercent,
      required_raw_points: requiredRawPoints,
    };
  });

  return {
    subject: {
      id: Number(subjectRow.id),
      name: subjectRow.name || 'Предмет',
    },
    current_final_score: normalizedCurrentFinal,
    max_reachable_final_score: normalizedMaxReachable,
    remaining_columns_count: remainingColumnsCount,
    remaining_raw_max: round2(remainingRawMaxTotal),
    remaining_weighted_potential: round2(remainingWeightedPotential),
    targets,
    types: typeRows,
  };
}

app.get('/my-day', requireLogin, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'myday.init');
  }
  try {
    const myDay = await buildMyDayData(req.session.user, req.session.role, req.session.roles || []);
    return res.render('my-day', {
      username: req.session.user.username,
      role: req.session.role,
      viewAs: req.session.viewAs || null,
      myDay,
      okMessage: String(req.query.ok || ''),
      errMessage: String(req.query.err || ''),
    });
  } catch (err) {
    return handleDbError(res, err, 'myday');
  }
});

app.get('/api/my-day', requireLogin, readLimiter, async (req, res) => {
  try {
    const myDay = await buildMyDayData(req.session.user, req.session.role, req.session.roles || []);
    return res.json(myDay);
  } catch (err) {
    return res.status(500).json({ error: 'Database error' });
  }
});

app.get('/api/my-day/progress-risk', requireLogin, readLimiter, async (req, res) => {
  try {
    const myDay = await buildMyDayData(req.session.user, req.session.role, req.session.roles || []);
    return res.json(myDay.progress_dashboard || {
      enabled: false,
      subjects: [],
      at_risk_count: 0,
      high_risk_count: 0,
      medium_risk_count: 0,
      subjects_total: 0,
      admission_target: STUDENT_RISK_ADMISSION_TARGET,
    });
  } catch (err) {
    return res.status(500).json({ error: 'Database error' });
  }
});

app.get('/api/my-day/what-if', requireLogin, readLimiter, async (req, res) => {
  const subjectId = Number(req.query.subject_id);
  if (!Number.isFinite(subjectId) || subjectId < 1) {
    return res.status(400).json({ error: 'Invalid subject' });
  }
  const target = Number(req.query.target);
  const targets = Number.isFinite(target) ? [target] : [60, 75, 90];
  try {
    const userId = Number(req.session.user.id);
    const courseId = Number(req.session.user.course_id || 1);
    const activeSemester = await getActiveSemester(courseId);
    const forecast = await buildMyDayWhatIfForecast({
      userId,
      courseId,
      semesterId: activeSemester ? Number(activeSemester.id) : null,
      subjectId,
      targetScores: targets,
    });
    if (!forecast) {
      return res.status(403).json({ error: 'Forbidden' });
    }
    return res.json(forecast);
  } catch (err) {
    return res.status(500).json({ error: 'Database error' });
  }
});

app.get('/api/reminders', requireLogin, readLimiter, async (req, res) => {
  const { from, to, status } = req.query;
  if (from && !isValidDateString(String(from))) {
    return res.status(400).json({ error: 'Invalid from date' });
  }
  if (to && !isValidDateString(String(to))) {
    return res.status(400).json({ error: 'Invalid to date' });
  }
  const filterStatus = status === 'all' || status === 'done' ? status : 'open';
  try {
    const { id: userId, course_id: courseId } = req.session.user;
    const activeSemester = await getActiveSemester(courseId || 1);
    if (!activeSemester) {
      return res.status(400).json({ error: 'No active semester' });
    }
    const clauses = ['user_id = ?', 'course_id = ?', 'semester_id = ?'];
    const params = [userId, courseId || 1, activeSemester.id];
    if (from) {
      clauses.push('remind_date >= ?');
      params.push(String(from));
    }
    if (to) {
      clauses.push('remind_date <= ?');
      params.push(String(to));
    }
    if (filterStatus !== 'all') {
      clauses.push('is_done = ?');
      params.push(filterStatus === 'done' ? 1 : 0);
    }
    const rows = await db.all(
      `
        SELECT id, title, note, remind_date, remind_time, is_done
        FROM personal_reminders
        WHERE ${clauses.join(' AND ')}
        ORDER BY remind_date ASC, remind_time ASC NULLS LAST, created_at DESC
      `,
      params
    );
    return res.json({ reminders: rows || [] });
  } catch (err) {
    return res.status(500).json({ error: 'Database error' });
  }
});

app.post('/api/reminders', requireLogin, writeLimiter, async (req, res) => {
  const title = typeof req.body.title === 'string' ? req.body.title.trim() : '';
  const note = typeof req.body.note === 'string' ? req.body.note.trim() : '';
  const remindDate = typeof req.body.remind_date === 'string' ? req.body.remind_date.trim() : '';
  const remindTime = typeof req.body.remind_time === 'string' ? req.body.remind_time.trim() : '';
  if (!title) {
    return res.status(400).json({ error: 'Title required' });
  }
  if (title.length > 160) {
    return res.status(400).json({ error: 'Title too long' });
  }
  if (!isValidDateString(remindDate)) {
    return res.status(400).json({ error: 'Invalid date' });
  }
  if (remindTime && !isValidTimeString(remindTime)) {
    return res.status(400).json({ error: 'Invalid time' });
  }
  if (note.length > 500) {
    return res.status(400).json({ error: 'Note too long' });
  }
  try {
    const { id: userId, course_id: courseId } = req.session.user;
    const activeSemester = await getActiveSemester(courseId || 1);
    if (!activeSemester) {
      return res.status(400).json({ error: 'No active semester' });
    }
    const nowIso = new Date().toISOString();
    const row = await db.get(
      `
        INSERT INTO personal_reminders
          (user_id, title, note, remind_date, remind_time, is_done, created_at, updated_at, course_id, semester_id)
        VALUES (?, ?, ?, ?, ?, 0, ?, ?, ?, ?)
        RETURNING id, title, note, remind_date, remind_time, is_done
      `,
      [
        userId,
        title,
        note || null,
        remindDate,
        remindTime || null,
        nowIso,
        nowIso,
        courseId || 1,
        activeSemester.id,
      ]
    );
    if (!row) {
      return res.status(500).json({ error: 'Database error' });
    }
    return res.json({ reminder: row });
  } catch (err) {
    return res.status(500).json({ error: 'Database error' });
  }
});

app.patch('/api/reminders/:id', requireLogin, writeLimiter, async (req, res) => {
  const reminderId = Number(req.params.id);
  if (Number.isNaN(reminderId)) {
    return res.status(400).json({ error: 'Invalid reminder' });
  }
  const updates = [];
  const params = [];
  if (typeof req.body.title === 'string') {
    const title = req.body.title.trim();
    if (!title) {
      return res.status(400).json({ error: 'Title required' });
    }
    if (title.length > 160) {
      return res.status(400).json({ error: 'Title too long' });
    }
    updates.push('title = ?');
    params.push(title);
  }
  if (typeof req.body.note === 'string') {
    const note = req.body.note.trim();
    if (note.length > 500) {
      return res.status(400).json({ error: 'Note too long' });
    }
    updates.push('note = ?');
    params.push(note || null);
  }
  if (typeof req.body.remind_date === 'string') {
    const remindDate = req.body.remind_date.trim();
    if (!isValidDateString(remindDate)) {
      return res.status(400).json({ error: 'Invalid date' });
    }
    updates.push('remind_date = ?');
    params.push(remindDate);
  }
  if (typeof req.body.remind_time === 'string') {
    const remindTime = req.body.remind_time.trim();
    if (remindTime && !isValidTimeString(remindTime)) {
      return res.status(400).json({ error: 'Invalid time' });
    }
    updates.push('remind_time = ?');
    params.push(remindTime || null);
  }
  if (typeof req.body.is_done !== 'undefined') {
    const done = req.body.is_done === true || req.body.is_done === 'true' || req.body.is_done === 1 || req.body.is_done === '1';
    updates.push('is_done = ?');
    params.push(done ? 1 : 0);
  }
  if (!updates.length) {
    return res.status(400).json({ error: 'No changes' });
  }
  try {
    const { id: userId, course_id: courseId } = req.session.user;
    const activeSemester = await getActiveSemester(courseId || 1);
    if (!activeSemester) {
      return res.status(400).json({ error: 'No active semester' });
    }
    updates.push('updated_at = ?');
    params.push(new Date().toISOString());
    params.push(reminderId, userId, courseId || 1, activeSemester.id);
    const row = await db.get(
      `
        UPDATE personal_reminders
        SET ${updates.join(', ')}
        WHERE id = ? AND user_id = ? AND course_id = ? AND semester_id = ?
        RETURNING id, title, note, remind_date, remind_time, is_done
      `,
      params
    );
    if (!row) {
      return res.status(404).json({ error: 'Not found' });
    }
    return res.json({ reminder: row });
  } catch (err) {
    return res.status(500).json({ error: 'Database error' });
  }
});

app.delete('/api/reminders/:id', requireLogin, writeLimiter, async (req, res) => {
  const reminderId = Number(req.params.id);
  if (Number.isNaN(reminderId)) {
    return res.status(400).json({ error: 'Invalid reminder' });
  }
  try {
    const { id: userId, course_id: courseId } = req.session.user;
    const activeSemester = await getActiveSemester(courseId || 1);
    if (!activeSemester) {
      return res.status(400).json({ error: 'No active semester' });
    }
    const result = await db.run(
      'DELETE FROM personal_reminders WHERE id = ? AND user_id = ? AND course_id = ? AND semester_id = ?',
      [reminderId, userId, courseId || 1, activeSemester.id]
    );
    if (!result || !result.changes) {
      return res.status(404).json({ error: 'Not found' });
    }
    return res.json({ ok: true });
  } catch (err) {
    return res.status(500).json({ error: 'Database error' });
  }
});

app.post('/api/homework/:id/complete', requireLogin, writeLimiter, async (req, res) => {
  const homeworkId = Number(req.params.id);
  if (Number.isNaN(homeworkId)) {
    return res.status(400).json({ error: 'Invalid homework' });
  }
  const { id: userId, course_id: courseId } = req.session.user;
  const activeSemester = await getActiveSemester(courseId || 1);
  const nowIso = new Date().toISOString();
  try {
    const homework = await db.get(
      `SELECT id, subject_id, group_number
       FROM homework
       WHERE id = ? AND course_id = ?${activeSemester ? ' AND semester_id = ?' : ''}
         AND COALESCE(status, 'published') = 'published'
         AND (scheduled_at IS NULL OR scheduled_at <= ?)`,
      activeSemester ? [homeworkId, courseId || 1, activeSemester.id, nowIso] : [homeworkId, courseId || 1, nowIso]
    );
    if (!homework) {
      return res.status(404).json({ error: 'Not found' });
    }
    const access = await db.get(
      'SELECT 1 FROM student_groups WHERE student_id = ? AND subject_id = ? AND group_number = ?',
      [userId, homework.subject_id, homework.group_number]
    );
    if (!access) {
      return res.status(403).json({ error: 'Forbidden' });
    }
    const existing = await db.get(
      'SELECT id FROM homework_completions WHERE homework_id = ? AND user_id = ?',
      [homeworkId, userId]
    );
    if (existing) {
      await db.run('DELETE FROM homework_completions WHERE id = ?', [existing.id]);
      return res.json({ completed: false });
    }
    await db.run(
      'INSERT INTO homework_completions (user_id, homework_id, done_at) VALUES (?, ?, ?)',
      [userId, homeworkId, new Date().toISOString()]
    );
    return res.json({ completed: true });
  } catch (err) {
    return res.status(500).json({ error: 'Database error' });
  }
});

app.post('/homework/:id/submit', requireLogin, uploadLimiter, upload.single('submission_attachment'), async (req, res) => {
  const homeworkId = Number(req.params.id);
  const requestedRedirect = typeof req.body.redirect_to === 'string' ? String(req.body.redirect_to).trim() : '';
  const redirectBase = requestedRedirect.startsWith('/my-day') ? '/my-day' : '/schedule';
  const redirectWith = (kind, message) => `${redirectBase}?${kind}=${encodeURIComponent(String(message || ''))}`;
  if (!Number.isFinite(homeworkId) || homeworkId < 1) {
    if (req.file) fs.unlink(req.file.path, () => {});
    return res.redirect(redirectWith('err', 'Invalid homework'));
  }

  const userId = Number(req.session.user.id);
  const courseId = Number(req.session.user.course_id || 1);
  const activeSemester = await getActiveSemester(courseId);
  const nowIso = new Date().toISOString();
  const submissionText = String(req.body.submission_text || '').trim();
  const rawLinkUrl = String(req.body.link_url || '').trim();
  const linkUrl = normalizeExternalUrl(rawLinkUrl);
  const filePath = req.file ? `/uploads/${req.file.filename}` : null;
  const fileName = req.file ? req.file.originalname : null;

  if (submissionText.length > 4000) {
    if (req.file) fs.unlink(req.file.path, () => {});
    return res.redirect(redirectWith('err', 'Submission text is too long'));
  }
  if (rawLinkUrl && !linkUrl) {
    if (req.file) fs.unlink(req.file.path, () => {});
    return res.redirect(redirectWith('err', 'Invalid link URL'));
  }
  if (!submissionText && !linkUrl && !req.file) {
    if (req.file) fs.unlink(req.file.path, () => {});
    return res.redirect(redirectWith('err', 'Add text, link or file'));
  }

  try {
    const homework = await db.get(
      `
        SELECT id, subject_id, group_number, course_id, semester_id
        FROM homework
        WHERE id = ?
          AND course_id = ?
          AND COALESCE(status, 'published') = 'published'
          AND (scheduled_at IS NULL OR scheduled_at <= ?)
          ${activeSemester ? 'AND (semester_id = ? OR semester_id IS NULL)' : 'AND semester_id IS NULL'}
        LIMIT 1
      `,
      activeSemester ? [homeworkId, courseId, nowIso, activeSemester.id] : [homeworkId, courseId, nowIso]
    );
    if (!homework) {
      if (req.file) fs.unlink(req.file.path, () => {});
      return res.redirect(redirectWith('err', 'Homework not found'));
    }

    const studentAccess = await db.get(
      `
        SELECT 1
        FROM student_groups
        WHERE student_id = ? AND subject_id = ? AND group_number = ?
        LIMIT 1
      `,
      [userId, homework.subject_id, homework.group_number]
    );
    if (!studentAccess) {
      if (req.file) fs.unlink(req.file.path, () => {});
      return res.status(403).send('Forbidden (homework submit)');
    }

    const existing = await db.get(
      `
        SELECT id, file_path
        FROM homework_submissions
        WHERE homework_id = ? AND student_id = ?
        LIMIT 1
      `,
      [homeworkId, userId]
    );
    if (existing) {
      await db.run(
        `
          UPDATE homework_submissions
          SET submission_text = ?,
              link_url = ?,
              file_path = ?,
              file_name = ?,
              submitted_at = ?,
              updated_at = ?
          WHERE id = ?
        `,
        [
          submissionText || null,
          linkUrl || null,
          filePath || existing.file_path || null,
          fileName || null,
          nowIso,
          nowIso,
          existing.id,
        ]
      );
      if (filePath && existing.file_path && existing.file_path !== filePath) {
        const relativePath = String(existing.file_path).replace(/^\/+/, '');
        const absolutePath = path.join(__dirname, relativePath);
        fs.unlink(absolutePath, () => {});
      }
    } else {
      await db.run(
        `
          INSERT INTO homework_submissions
            (homework_id, student_id, submission_text, link_url, file_path, file_name, submitted_at, updated_at)
          VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `,
        [
          homeworkId,
          userId,
          submissionText || null,
          linkUrl || null,
          filePath,
          fileName,
          nowIso,
          nowIso,
        ]
      );
    }

    await db.run(
      `
        INSERT INTO homework_completions (user_id, homework_id, done_at)
        VALUES (?, ?, ?)
        ON CONFLICT (user_id, homework_id)
        DO UPDATE SET done_at = EXCLUDED.done_at
      `,
      [userId, homeworkId, nowIso]
    );

    logActivity(
      db,
      req,
      'homework_submit',
      'homework',
      homeworkId,
      {
        subject_id: Number(homework.subject_id),
        group_number: Number(homework.group_number),
        has_text: Boolean(submissionText),
        has_link: Boolean(linkUrl),
        has_file: Boolean(filePath),
      },
      Number(homework.course_id || courseId),
      homework.semester_id ? Number(homework.semester_id) : null
    );
    return res.redirect(redirectWith('ok', 'ДЗ здано'));
  } catch (err) {
    if (req.file) fs.unlink(req.file.path, () => {});
    return res.redirect(redirectWith('err', 'Database error'));
  }
});

app.get('/schedule', requireLogin, async (req, res) => {
  const { id: userId, schedule_group: group, username, course_id: courseId } = req.session.user;
  if (hasSessionRole(req, 'teacher')) {
    try {
      await ensureDbReady();
      const teacherSubjects = await db.all(
        `
          SELECT ts.subject_id, ts.group_number, s.name AS subject_name, s.group_count, s.is_general,
                 s.course_id, c.name AS course_name
          FROM teacher_subjects ts
          JOIN subjects s ON s.id = ts.subject_id
          JOIN courses c ON c.id = s.course_id
          WHERE ts.user_id = ? AND s.visible = 1
          ORDER BY c.id, s.name
        `,
        [userId]
      );
      const teacherCourseMap = new Map();
      teacherSubjects.forEach((row) => {
        if (!teacherCourseMap.has(row.course_id)) {
          teacherCourseMap.set(row.course_id, { id: row.course_id, name: row.course_name });
        }
      });
      const teacherCourses = Array.from(teacherCourseMap.values());
      const courseFilter = req.query.course ? Number(req.query.course) : null;
      const selectedCourse = teacherCourses.find((c) => Number(c.id) === Number(courseFilter)) || null;
      const courseIds = selectedCourse ? [selectedCourse.id] : teacherCourses.map((c) => c.id);
      const semesterMap = new Map();
      for (const cid of courseIds) {
        semesterMap.set(cid, await getActiveSemester(cid));
      }
      const courseWeekTime = new Map();
      for (const cid of courseIds) {
        const sem = semesterMap.get(cid);
        if (sem && sem.id) {
          courseWeekTime.set(cid, await getCourseWeekTimeMap(cid, sem.id));
        }
      }
      const primaryCourseId = selectedCourse ? selectedCourse.id : (courseIds[0] || null);
      const primarySemester = primaryCourseId ? semesterMap.get(primaryCourseId) : null;
      const totalWeeks = primarySemester && primarySemester.weeks_count ? Number(primarySemester.weeks_count) : 15;
      let selectedWeek = parseInt(req.query.week, 10);
      if (Number.isNaN(selectedWeek)) {
        selectedWeek = getAcademicWeekForSemester(new Date(), primarySemester);
      }
      if (selectedWeek < 1) selectedWeek = 1;
      if (selectedWeek > totalWeeks) selectedWeek = totalWeeks;

      let activeDaysSet = new Set();
      if (primaryCourseId) {
        if (selectedCourse) {
          const studyDays = await getCourseStudyDays(primaryCourseId);
          (studyDays || []).filter((d) => d.is_active).forEach((d) => {
            if (d.day_name) activeDaysSet.add(d.day_name);
          });
        } else {
          for (const cid of courseIds) {
            const studyDays = await getCourseStudyDays(cid);
            (studyDays || []).filter((d) => d.is_active).forEach((d) => {
              if (d.day_name) activeDaysSet.add(d.day_name);
            });
          }
        }
      }
      let activeDays = fullWeekDays.filter((day) => activeDaysSet.has(day));
      if (!activeDays.length) {
        activeDays = [...daysOfWeek];
      }
      const weekDates = fullWeekDays.map((_, idx) =>
        getDateForWeekIndex(selectedWeek, idx, primarySemester ? primarySemester.start_date : null)
      );
      const weekStartDate = weekDates[0];
      const weekEndDate = weekDates[6];
      const dayDates = {};
      activeDays.forEach((day) => {
        const idx = fullWeekDays.indexOf(day);
        dayDates[day] = idx >= 0 ? weekDates[idx] : null;
      });
      const scheduleByDay = {};
      activeDays.forEach((day) => {
        scheduleByDay[day] = [];
      });

      const selectionMap = new Map();
      teacherSubjects.forEach((row) => {
        const existing = selectionMap.get(row.subject_id) || {
          general: false,
          groups: new Set(),
          course_id: row.course_id,
          course_name: row.course_name,
          subject_name: row.subject_name,
        };
        if (row.group_number === null || typeof row.group_number === 'undefined') {
          existing.general = true;
        } else {
          existing.groups.add(Number(row.group_number));
        }
        selectionMap.set(row.subject_id, existing);
      });

      const courseNameMap = new Map(teacherCourses.map((c) => [Number(c.id), c.name]));
      const groupedMap = new Map();
      const scheduleRows = [];

      for (const cid of courseIds) {
        const subjectIds = teacherSubjects.filter((s) => Number(s.course_id) === Number(cid)).map((s) => s.subject_id);
        if (!subjectIds.length) continue;
        const sem = semesterMap.get(cid);
        const weekTimeMap = courseWeekTime.get(cid);
        const useLocalTime = weekTimeMap ? weekTimeMap.get(selectedWeek) === true : false;
        const placeholders = subjectIds.map(() => '?').join(',');
        const params = [selectedWeek, cid];
        let sql = `
          SELECT se.*, s.name AS subject_name
          FROM schedule_entries se
          JOIN subjects s ON s.id = se.subject_id
          WHERE se.week_number = ? AND se.course_id = ?
        `;
        if (sem) {
          sql += ' AND se.semester_id = ?';
          params.push(sem.id);
        }
        sql += ` AND se.subject_id IN (${placeholders})`;
        params.push(...subjectIds);
        const rows = await db.all(sql, params);
        rows.forEach((row) => {
          const selection = selectionMap.get(row.subject_id);
          if (!selection) return;
          if (!selection.general && !selection.groups.has(Number(row.group_number))) return;
          row.course_id = cid;
          row.course_name = courseNameMap.get(Number(cid)) || '';
          row.class_date = getDateForWeekDay(selectedWeek, row.day_of_week, sem ? sem.start_date : null);
          row.use_local_time = useLocalTime;
          scheduleRows.push(row);
        });
      }

      scheduleRows.forEach((row) => {
        const key = `${row.course_id}|${row.subject_id}|${row.day_of_week}|${row.class_number}`;
        if (!groupedMap.has(key)) {
          groupedMap.set(key, {
            ...row,
            group_numbers: new Set(),
          });
        }
        groupedMap.get(key).group_numbers.add(Number(row.group_number));
      });

      const teacherTargets = [];
      const targetSeen = new Set();
      teacherSubjects.forEach((row) => {
        const sem = semesterMap.get(row.course_id);
        const semId = sem ? sem.id : 0;
        if (row.group_number === null || typeof row.group_number === 'undefined') {
          const maxGroups = Number(row.group_count || 1);
          for (let g = 1; g <= maxGroups; g += 1) {
            const key = `${row.subject_id}|${g}|${row.course_id}|${semId}`;
            if (targetSeen.has(key)) continue;
            targetSeen.add(key);
            teacherTargets.push({
              subject_id: row.subject_id,
              group_number: g,
              course_id: row.course_id,
              semester_id: semId,
            });
          }
          return;
        }
        const groupNum = Number(row.group_number);
        const key = `${row.subject_id}|${groupNum}|${row.course_id}|${semId}`;
        if (targetSeen.has(key)) return;
        targetSeen.add(key);
        teacherTargets.push({
          subject_id: row.subject_id,
          group_number: groupNum,
          course_id: row.course_id,
          semester_id: semId,
        });
      });
      groupedMap.forEach((entry) => {
        const groups = Array.from(entry.group_numbers).sort((a, b) => a - b);
        const selection = selectionMap.get(entry.subject_id);
        let groupLabel = '';
        if (selection && selection.general) {
          groupLabel = 'Усі групи';
        } else if (groups.length === 1) {
          groupLabel = `Група ${groups[0]}`;
        } else {
          groupLabel = `Групи: ${groups.join(', ')}`;
        }
        const normalized = {
          ...entry,
          group_numbers: groups,
          group_number: groups[0] || null,
          group_label: groupLabel,
          is_general: selection ? selection.general : false,
        };
        if (scheduleByDay[entry.day_of_week]) {
          scheduleByDay[entry.day_of_week].push(normalized);
        }
      });

      activeDays.forEach((day) => {
        scheduleByDay[day].sort((a, b) => a.class_number - b.class_number);
      });

      const nowIso = new Date().toISOString();
      const homeworkMeta = {};
      const homeworkMetaAll = {};
      let homework = [];
      let homeworkTags = [];

      if (teacherTargets.length) {
        const hwConditions = teacherTargets
          .map(() => '(h.subject_id = ? AND h.group_number = ? AND h.course_id = ? AND COALESCE(h.semester_id, 0) = ?)')
          .join(' OR ');
        const hwParams = [];
        teacherTargets.forEach((t) => {
          hwParams.push(t.subject_id, t.group_number, t.course_id, t.semester_id);
        });
        const hwRows = await db.all(
          `
            SELECT h.*, subj.name AS subject_name, s.id AS subgroup_id, s.name AS subgroup_name, m.member_username AS subgroup_member
            FROM homework h
            JOIN subjects subj ON subj.id = h.subject_id
            LEFT JOIN subgroups s ON s.homework_id = h.id
            LEFT JOIN subgroup_members m ON m.subgroup_id = s.id
            WHERE (${hwConditions})
              AND COALESCE(h.status, 'published') = 'published'
              AND (h.scheduled_at IS NULL OR h.scheduled_at <= ?)
              AND (h.is_custom_deadline IS NULL OR h.is_custom_deadline = 0)
            ORDER BY h.created_at DESC
          `,
          [...hwParams, nowIso]
        );
        const homeworkMap = new Map();
        (hwRows || []).forEach((row) => {
          if (!homeworkMap.has(row.id)) {
            homeworkMap.set(row.id, {
              id: row.id,
              group_number: row.group_number,
              subject_id: row.subject_id,
              subject: row.subject_name,
              day: row.day_of_week,
              class_number: row.class_number,
              description: row.description,
              class_date: row.class_date,
              meeting_url: row.meeting_url,
              link_url: row.link_url,
              file_path: row.file_path,
              file_name: normalizeUploadedOriginalName(row.file_name),
              created_by: row.created_by,
              created_at: row.created_at,
              is_control: Number(row.is_control || 0),
              is_teacher_homework: Number(row.is_teacher_homework || 0),
              is_credit: Number(row.is_credit || 0),
              course_id: row.course_id,
              subgroups: {},
            });
          }
          if (row.subgroup_id) {
            const hw = homeworkMap.get(row.id);
            if (!hw.subgroups[row.subgroup_id]) {
              hw.subgroups[row.subgroup_id] = {
                id: row.subgroup_id,
                name: row.subgroup_name,
                members: [],
              };
            }
            if (row.subgroup_member) {
              hw.subgroups[row.subgroup_id].members.push(row.subgroup_member);
            }
          }
        });
        homework = dedupeTeacherHomeworkItems(
          Array.from(homeworkMap.values()).map((hw) => ({
            ...hw,
            subgroups: Object.values(hw.subgroups),
          }))
        );
        homework.forEach((hw) => {
          const legacyKey = `${hw.subject_id}|${hw.group_number}|${hw.day}|${hw.class_number}`;
          const key = hw.class_date ? `${legacyKey}|${hw.class_date}` : legacyKey;
          if (!homeworkMeta[key]) {
            homeworkMeta[key] = {
              count: 0,
              preview: [],
              control: false,
              teacher_homework: false,
              credit: false,
              meet: false,
              meet_link: '',
            };
          }
          homeworkMeta[key].count += 1;
          if (hw.is_control) {
            homeworkMeta[key].control = true;
          }
          if (hw.is_teacher_homework) {
            homeworkMeta[key].teacher_homework = true;
          }
          if (hw.is_credit) {
            homeworkMeta[key].credit = true;
          }
          if (hw.meeting_url) {
            homeworkMeta[key].meet = true;
            if (!homeworkMeta[key].meet_link) {
              homeworkMeta[key].meet_link = String(hw.meeting_url);
            }
          }
          if (hw.description && homeworkMeta[key].preview.length < 2) {
            homeworkMeta[key].preview.push(hw.description);
          }
          const allKey = hw.class_date
            ? `${hw.subject_id}|${hw.day}|${hw.class_number}|${hw.class_date}`
            : `${hw.subject_id}|${hw.day}|${hw.class_number}`;
          if (!homeworkMetaAll[allKey]) {
            homeworkMetaAll[allKey] = {
              count: 0,
              preview: [],
              control: false,
              teacher_homework: false,
              credit: false,
              meet: false,
              meet_link: '',
            };
          }
          homeworkMetaAll[allKey].count += 1;
          if (hw.is_control) {
            homeworkMetaAll[allKey].control = true;
          }
          if (hw.is_teacher_homework) {
            homeworkMetaAll[allKey].teacher_homework = true;
          }
          if (hw.is_credit) {
            homeworkMetaAll[allKey].credit = true;
          }
          if (hw.meeting_url) {
            homeworkMetaAll[allKey].meet = true;
            if (!homeworkMetaAll[allKey].meet_link) {
              homeworkMetaAll[allKey].meet_link = String(hw.meeting_url);
            }
          }
          if (hw.description && homeworkMetaAll[allKey].preview.length < 2) {
            homeworkMetaAll[allKey].preview.push(hw.description);
          }
        });
        const homeworkIds = homework.map((h) => h.id);
        if (homeworkIds.length) {
          const placeholders = homeworkIds.map(() => '?').join(',');
          const tagRows = await db.all(
            `SELECT ht.homework_id, t.name
             FROM homework_tag_map ht
             JOIN homework_tags t ON t.id = ht.tag_id
             WHERE ht.homework_id IN (${placeholders})`,
            homeworkIds
          );
          if (tagRows && tagRows.length) {
            const tagMap = {};
            tagRows.forEach((row) => {
              if (!tagMap[row.homework_id]) tagMap[row.homework_id] = [];
              tagMap[row.homework_id].push(row.name);
            });
            homework.forEach((hw) => {
              hw.tags = tagMap[hw.id] || [];
            });
          }
          const tagList = await db.all('SELECT name FROM homework_tags ORDER BY name');
          homeworkTags = (tagList || []).map((row) => row.name);
          const reactRows = await db.all(
            `SELECT homework_id, emoji, COUNT(*) AS count
             FROM homework_reactions
             WHERE homework_id IN (${placeholders})
             GROUP BY homework_id, emoji`,
            homeworkIds
          );
          const reactionMap = {};
          (reactRows || []).forEach((row) => {
            if (!reactionMap[row.homework_id]) reactionMap[row.homework_id] = {};
            reactionMap[row.homework_id][row.emoji] = Number(row.count || 0);
          });
          const myRows = await db.all(
            `SELECT homework_id, emoji
             FROM homework_reactions
             WHERE homework_id IN (${placeholders}) AND user_id = ?`,
            [...homeworkIds, userId]
          );
          const reactedMap = {};
          (myRows || []).forEach((row) => {
            if (!reactedMap[row.homework_id]) reactedMap[row.homework_id] = {};
            reactedMap[row.homework_id][row.emoji] = true;
          });
          homework.forEach((hw) => {
            hw.reactions = reactionMap[hw.id] || {};
            hw.reacted = reactedMap[hw.id] || {};
          });
        }
      }

      let customDeadlinesByDate = {};
      let weekendDeadlineCards = [];
      let customDeadlineItems = [];
      if (settingsCache.allow_custom_deadlines && teacherTargets.length && weekStartDate && weekEndDate) {
        const cdConditions = teacherTargets
          .map(() => '(h.subject_id = ? AND h.group_number = ? AND h.course_id = ? AND COALESCE(h.semester_id, 0) = ?)')
          .join(' OR ');
        const cdParams = [];
        teacherTargets.forEach((t) => {
          cdParams.push(t.subject_id, t.group_number, t.course_id, t.semester_id);
        });
        const cdRows = await db.all(
          `
            SELECT h.*, subj.name AS subject_name, c.name AS course_name
            FROM homework h
            JOIN subjects subj ON subj.id = h.subject_id
            JOIN courses c ON c.id = h.course_id
            WHERE (${cdConditions})
              AND COALESCE(h.status, 'published') = 'published'
              AND (h.scheduled_at IS NULL OR h.scheduled_at <= ?)
              AND h.is_custom_deadline = 1
              AND h.custom_due_date IS NOT NULL
              AND h.custom_due_date >= ?
              AND h.custom_due_date <= ?
            ORDER BY h.custom_due_date ASC, h.created_at DESC
          `,
          [...cdParams, nowIso, weekStartDate, weekEndDate]
        );
        customDeadlineItems = dedupeTeacherHomeworkItems(cdRows || []);
        const ids = customDeadlineItems.map((row) => row.id);
        const byDate = {};
        customDeadlineItems.forEach((row) => {
          const key = row.custom_due_date;
          if (!byDate[key]) byDate[key] = [];
          byDate[key].push(row);
        });
        const weekendCards = [];
        ['Saturday', 'Sunday'].forEach((day) => {
          const idx = fullWeekDays.indexOf(day);
          const date = idx >= 0 ? weekDates[idx] : null;
          if (!date) return;
          const items = byDate[date] || [];
          if (items.length) {
            weekendCards.push({ day, date, items });
          }
        });
        customDeadlinesByDate = byDate;
        weekendDeadlineCards = weekendCards;
        if (ids.length) {
          const placeholders = ids.map(() => '?').join(',');
          const reactRows = await db.all(
            `SELECT homework_id, emoji, COUNT(*) AS count
             FROM homework_reactions
             WHERE homework_id IN (${placeholders})
             GROUP BY homework_id, emoji`,
            ids
          );
          const reactionMap = {};
          (reactRows || []).forEach((row) => {
            if (!reactionMap[row.homework_id]) reactionMap[row.homework_id] = {};
            reactionMap[row.homework_id][row.emoji] = Number(row.count || 0);
          });
          const myRows = await db.all(
            `SELECT homework_id, emoji
             FROM homework_reactions
             WHERE homework_id IN (${placeholders}) AND user_id = ?`,
            [...ids, userId]
          );
          const reactedMap = {};
          (myRows || []).forEach((row) => {
            if (!reactedMap[row.homework_id]) reactedMap[row.homework_id] = {};
            reactedMap[row.homework_id][row.emoji] = true;
          });
          customDeadlineItems.forEach((row) => {
            row.reactions = reactionMap[row.id] || {};
            row.reacted = reactedMap[row.id] || {};
          });
        }
      }

      let customDeadlineSubjects = [];
      if (settingsCache.allow_custom_deadlines) {
        const seenCustom = new Set();
        teacherSubjects.forEach((row) => {
          const key = `${row.subject_id}|${row.group_number || 'all'}`;
          if (seenCustom.has(key)) return;
          seenCustom.add(key);
          const generalFlag = row.is_general === false || Number(row.is_general) === 0 ? 0 : 1;
          customDeadlineSubjects.push({
            id: row.subject_id,
            name: row.subject_name,
            course_id: row.course_id,
            course_name: row.course_name,
            group_number: row.group_number,
            is_general: generalFlag,
            group_count: row.group_count,
          });
        });
      }

      return res.render('schedule', {
        scheduleByDay,
        daysOfWeek: activeDays,
        dayDates,
        currentWeek: selectedWeek,
        totalWeeks,
        semester: primarySemester,
        bellSchedule,
        group: group || 'A',
        username,
        homework,
        homeworkMeta,
        homeworkMetaAll,
        homeworkTags,
        customDeadlinesByDate,
        weekendDeadlineCards,
        customDeadlineItems,
        customDeadlineSubjects,
        subgroupError: req.query.sg || null,
        role: req.session.role,
        viewAs: req.session.viewAs || null,
        viewAsCourse: null,
        viewAsGroupNumber: null,
        messageSubjects: [],
        userId,
        teacherCourses,
        selectedCourseId: selectedCourse ? selectedCourse.id : null,
      });
    } catch (err) {
      return handleDbError(res, err, 'teacher.schedule');
    }
  }
  const isAdminViewAs = hasSessionRole(req, 'admin') && req.session.viewAs === 'student';
  const viewAsMode = isAdminViewAs ? (req.session.viewAsMode || 'manual') : null;
  let viewAsCourseId = isAdminViewAs ? Number(req.session.viewAsCourseId) : null;
  let viewAsGroupNumber = isAdminViewAs ? Number(req.session.viewAsGroupNumber) : null;
  if (isAdminViewAs) {
    if (viewAsMode === 'self') {
      viewAsCourseId = Number.isFinite(Number(courseId)) ? Number(courseId) : 1;
      req.session.viewAsCourseId = viewAsCourseId;
      viewAsGroupNumber = null;
      req.session.viewAsGroupNumber = null;
    } else if (!Number.isFinite(viewAsCourseId)) {
      viewAsCourseId = Number.isFinite(Number(courseId)) ? Number(courseId) : 1;
      req.session.viewAsCourseId = viewAsCourseId;
    }
    if (viewAsMode !== 'self' && (!Number.isFinite(viewAsGroupNumber) || viewAsGroupNumber < 1)) {
      viewAsGroupNumber = 1;
      req.session.viewAsGroupNumber = viewAsGroupNumber;
    }
  }
  const scheduleCourseId = isAdminViewAs && Number.isFinite(viewAsCourseId)
    ? viewAsCourseId
    : (courseId || 1);
  const viewAsCourse = isAdminViewAs ? await getCourseById(scheduleCourseId) : null;
  const viewAsLabel = isAdminViewAs
    ? (viewAsMode === 'self' ? 'Ваші групи' : `Група ${viewAsGroupNumber || 1}`)
    : null;

  const activeSemester = await getActiveSemester(scheduleCourseId);
  const totalWeeks = activeSemester && activeSemester.weeks_count ? Number(activeSemester.weeks_count) : 15;
  let selectedWeek = parseInt(req.query.week, 10);
  if (Number.isNaN(selectedWeek)) {
    selectedWeek = getAcademicWeekForSemester(new Date(), activeSemester);
  }
  if (selectedWeek < 1) selectedWeek = 1;
  if (selectedWeek < 1) selectedWeek = 1;
  if (selectedWeek > totalWeeks) selectedWeek = totalWeeks;
  const weekTimeMap = activeSemester && activeSemester.id
    ? await getCourseWeekTimeMap(scheduleCourseId, activeSemester.id)
    : new Map();
  const useLocalTime = weekTimeMap.get(selectedWeek) === true;
  const studyDays = await getCourseStudyDays(scheduleCourseId);
  let activeDays = studyDays
    .filter((day) => day.is_active)
    .map((day) => fullWeekDays[day.weekday - 1])
    .filter(Boolean);
  if (!activeDays.length) {
    activeDays = [...daysOfWeek];
  }
  const weekDates = fullWeekDays.map((_, idx) =>
    getDateForWeekIndex(selectedWeek, idx, activeSemester ? activeSemester.start_date : null)
  );
  const weekStartDate = weekDates[0];
  const weekEndDate = weekDates[6];
  const nowIso = new Date().toISOString();

  const loadStudentGroups = (cb) => {
    if (!isAdminViewAs) {
      return db.all(
        `
          SELECT sg.subject_id, sg.group_number, s.name AS subject_name
          FROM student_groups sg
          JOIN subjects s ON s.id = sg.subject_id
          WHERE sg.student_id = ? AND s.course_id = ? AND s.visible = 1
        `,
        [userId, scheduleCourseId],
        cb
      );
    }
    if (viewAsMode === 'self') {
      return db.all(
        `
          SELECT sg.subject_id, sg.group_number, s.name AS subject_name
          FROM student_groups sg
          JOIN subjects s ON s.id = sg.subject_id
          WHERE sg.student_id = ? AND s.course_id = ? AND s.visible = 1
        `,
        [userId, scheduleCourseId],
        cb
      );
    }
    db.all(
      `
        SELECT id AS subject_id, name AS subject_name, group_count
        FROM subjects
        WHERE course_id = ? AND visible = 1
        ORDER BY name
      `,
      [scheduleCourseId],
      (err, subjects) => {
        if (err) {
          return cb(err);
        }
        const groupNumber = Number.isFinite(viewAsGroupNumber) ? viewAsGroupNumber : 1;
        const groups = (subjects || [])
          .filter((s) => Number(s.group_count || 1) >= groupNumber)
          .map((s) => ({
            subject_id: s.subject_id,
            group_number: groupNumber,
            subject_name: s.subject_name,
          }));
        return cb(null, groups);
      }
    );
  };

  loadStudentGroups((groupErr, studentGroups) => {
      if (groupErr) {
        return res.status(500).send('Database error');
      }

      const scheduleByDay = {};
      activeDays.forEach((day) => {
        scheduleByDay[day] = [];
      });
      const dayDates = {};
      activeDays.forEach((day) => {
        const idx = fullWeekDays.indexOf(day);
        dayDates[day] = idx >= 0 ? weekDates[idx] : null;
      });
      const customDeadlineSubjects = [];
      if (settingsCache.allow_custom_deadlines) {
        const subjectSeen = new Set();
        studentGroups.forEach((sg) => {
          if (!subjectSeen.has(sg.subject_id)) {
            subjectSeen.add(sg.subject_id);
            customDeadlineSubjects.push({ id: sg.subject_id, name: sg.subject_name });
          }
        });
      }

      const buildHomeworkTargets = (baseGroups = [], scheduleRows = []) => {
        const map = new Map();
        const baseGroupsBySubject = new Map();
        (baseGroups || []).forEach((item) => {
          const subjectId = Number(item.subject_id);
          const groupNumber = Number(item.group_number);
          if (!Number.isFinite(subjectId) || !Number.isFinite(groupNumber)) return;
          if (!baseGroupsBySubject.has(subjectId)) {
            baseGroupsBySubject.set(subjectId, new Set());
          }
          baseGroupsBySubject.get(subjectId).add(groupNumber);
          const key = `${subjectId}|${groupNumber}`;
          if (!map.has(key)) {
            map.set(key, {
              subject_id: subjectId,
              group_number: groupNumber,
              subject_name: item.subject_name || '',
            });
          }
        });
        (scheduleRows || []).forEach((row) => {
          const subjectId = Number(row.subject_id);
          const groupNumber = Number(row.group_number);
          if (!Number.isFinite(subjectId) || !Number.isFinite(groupNumber) || groupNumber < 1) return;
          if (baseGroupsBySubject.size) {
            const allowedGroups = baseGroupsBySubject.get(subjectId);
            if (!allowedGroups || !allowedGroups.has(groupNumber)) {
              return;
            }
          }
          const key = `${subjectId}|${groupNumber}`;
          if (!map.has(key)) {
            map.set(key, {
              subject_id: subjectId,
              group_number: groupNumber,
              subject_name: row.subject_name || '',
            });
          }
        });
        return Array.from(map.values());
      };

      const loadCustomDeadlines = (homeworkTargets, cb) => {
        if (!settingsCache.allow_custom_deadlines) {
          return cb({}, [], []);
        }
        if (!homeworkTargets.length || !weekStartDate || !weekEndDate) {
          return cb({}, [], []);
        }
        const conditions = homeworkTargets
          .map(() => '(h.subject_id = ? AND h.group_number = ?)')
          .join(' OR ');
        const params = [];
        homeworkTargets.forEach((sg) => {
          params.push(sg.subject_id, sg.group_number);
        });
        params.push(scheduleCourseId, activeSemester ? activeSemester.id : null, nowIso, weekStartDate, weekEndDate);
        const sql = `
          SELECT h.*, subj.name AS subject_name
          FROM homework h
          JOIN subjects subj ON subj.id = h.subject_id
          WHERE (${conditions})
            AND h.course_id = ?
            AND (h.semester_id = ? OR h.semester_id IS NULL)
            AND COALESCE(h.status, 'published') = 'published'
            AND (h.scheduled_at IS NULL OR h.scheduled_at <= ?)
            AND h.is_custom_deadline = 1
            AND h.custom_due_date IS NOT NULL
            AND h.custom_due_date >= ?
            AND h.custom_due_date <= ?
          ORDER BY h.custom_due_date ASC, h.created_at DESC
        `;
        db.all(sql, params, (err, rows) => {
          if (err) {
            return cb({}, [], []);
          }
          const rowsList = rows || [];
          const ids = rowsList.map((row) => row.id);
          const byDate = {};
          rowsList.forEach((row) => {
            const key = row.custom_due_date;
            if (!byDate[key]) byDate[key] = [];
            byDate[key].push(row);
          });
          const weekendCards = [];
          ['Saturday', 'Sunday'].forEach((day) => {
            const idx = fullWeekDays.indexOf(day);
            const date = idx >= 0 ? weekDates[idx] : null;
            if (!date) return;
            const items = byDate[date] || [];
            if (items.length) {
              weekendCards.push({ day, date, items });
            }
          });
          if (!ids.length) {
            return cb(byDate, weekendCards, rowsList);
          }
          const placeholders = ids.map(() => '?').join(',');
          db.all(
            `SELECT homework_id, emoji, COUNT(*) AS count
             FROM homework_reactions
             WHERE homework_id IN (${placeholders})
             GROUP BY homework_id, emoji`,
            ids,
            (reactErr, reactRows) => {
              const reactionMap = {};
              if (!reactErr && reactRows) {
                reactRows.forEach((row) => {
                  if (!reactionMap[row.homework_id]) reactionMap[row.homework_id] = {};
                  reactionMap[row.homework_id][row.emoji] = Number(row.count || 0);
                });
              }
              db.all(
                `SELECT homework_id, emoji
                 FROM homework_reactions
                 WHERE homework_id IN (${placeholders}) AND user_id = ?`,
                [...ids, userId],
                (myErr, myRows) => {
                  const reactedMap = {};
                  if (!myErr && myRows) {
                    myRows.forEach((row) => {
                      if (!reactedMap[row.homework_id]) reactedMap[row.homework_id] = {};
                      reactedMap[row.homework_id][row.emoji] = true;
                    });
                  }
                  rowsList.forEach((row) => {
                    row.reactions = reactionMap[row.id] || {};
                    row.reacted = reactedMap[row.id] || {};
                  });
                  return cb(byDate, weekendCards, rowsList);
                }
              );
            }
          );
        });
      };

      const loadHomework = (homeworkTargets) => {
        if (!homeworkTargets.length) {
          return loadCustomDeadlines(homeworkTargets, (customDeadlinesByDate, weekendDeadlineCards, customDeadlineItems) =>
            res.render('schedule', {
            scheduleByDay,
            daysOfWeek: activeDays,
            dayDates,
              currentWeek: selectedWeek,
              totalWeeks,
              semester: activeSemester,
              bellSchedule,
              group: isAdminViewAs ? `Група ${viewAsGroupNumber || 1}` : (group || 'A'),
              username,
              homework: [],
              homeworkMeta: {},
              homeworkMetaAll: null,
              homeworkTags: [],
              customDeadlinesByDate,
              weekendDeadlineCards,
              customDeadlineItems,
              customDeadlineSubjects,
              subgroupError: req.query.sg || null,
              role: req.session.role,
              viewAs: req.session.viewAs || null,
              viewAsCourse,
              viewAsGroupNumber: isAdminViewAs ? viewAsGroupNumber : null,
              viewAsLabel,
              messageSubjects: studentGroups || [],
              userId,
              selectedCourseId: scheduleCourseId,
            })
          );
        }

        const hwConditions = homeworkTargets
          .map(() => '(h.subject_id = ? AND h.group_number = ?)')
          .join(' OR ');
        const hwParams = [];
        homeworkTargets.forEach((sg) => {
          hwParams.push(sg.subject_id, sg.group_number);
        });

        db.all(
          `
            SELECT
              h.*,
              subj.name AS subject_name,
              hs.submitted_at AS submission_submitted_at,
              s.id AS subgroup_id,
              s.name AS subgroup_name,
              m.member_username AS subgroup_member
            FROM homework h
            JOIN subjects subj ON subj.id = h.subject_id
            LEFT JOIN homework_submissions hs ON hs.homework_id = h.id AND hs.student_id = ?
            LEFT JOIN subgroups s ON s.homework_id = h.id
            LEFT JOIN subgroup_members m ON m.subgroup_id = s.id
            WHERE (${hwConditions})
              AND h.course_id = ?
              AND (h.semester_id = ? OR h.semester_id IS NULL)
              AND COALESCE(h.status, 'published') = 'published'
              AND (h.scheduled_at IS NULL OR h.scheduled_at <= ?)
              AND (h.is_custom_deadline IS NULL OR h.is_custom_deadline = 0)
            ORDER BY h.created_at DESC
          `,
          [userId, ...hwParams, scheduleCourseId, activeSemester ? activeSemester.id : null, nowIso],
          (err, rows) => {
            if (err) {
              return res.status(500).send('Database error');
            }

            const homeworkMap = new Map();
            rows.forEach((row) => {
              if (!homeworkMap.has(row.id)) {
                homeworkMap.set(row.id, {
                  id: row.id,
                  group_number: row.group_number,
                  subject_id: row.subject_id,
                  subject: row.subject_name,
                  day: row.day_of_week,
                  class_number: row.class_number,
                  description: row.description,
                  class_date: row.class_date,
                  meeting_url: row.meeting_url,
                  link_url: row.link_url,
                  file_path: row.file_path,
                  file_name: normalizeUploadedOriginalName(row.file_name),
                  created_by: row.created_by,
                  created_at: row.created_at,
                  submitted_at: row.submission_submitted_at || null,
                  is_control: Number(row.is_control || 0),
                  is_teacher_homework: Number(row.is_teacher_homework || 0),
                  is_credit: Number(row.is_credit || 0),
                  course_id: row.course_id,
                  subgroups: {},
                });
              }
              if (row.subgroup_id) {
                const hw = homeworkMap.get(row.id);
                if (!hw.subgroups[row.subgroup_id]) {
                  hw.subgroups[row.subgroup_id] = {
                    id: row.subgroup_id,
                    name: row.subgroup_name,
                    members: [],
                  };
                }
                if (row.subgroup_member) {
                  hw.subgroups[row.subgroup_id].members.push(row.subgroup_member);
                }
              }
            });

            const homework = Array.from(homeworkMap.values()).map((hw) => ({
              ...hw,
              subgroups: Object.values(hw.subgroups),
            }));
            const homeworkMeta = {};
            homework.forEach((hw) => {
              const legacyKey = `${hw.subject_id}|${hw.group_number}|${hw.day}|${hw.class_number}`;
              const key = hw.class_date ? `${legacyKey}|${hw.class_date}` : legacyKey;
              if (!homeworkMeta[key]) {
                homeworkMeta[key] = {
                  count: 0,
                  preview: [],
                  control: false,
                  teacher_homework: false,
                  credit: false,
                  meet: false,
                  meet_link: '',
                };
              }
              homeworkMeta[key].count += 1;
              if (hw.is_control) {
                homeworkMeta[key].control = true;
              }
              if (hw.is_teacher_homework) {
                homeworkMeta[key].teacher_homework = true;
              }
              if (hw.is_credit) {
                homeworkMeta[key].credit = true;
              }
              if (hw.meeting_url) {
                homeworkMeta[key].meet = true;
                if (!homeworkMeta[key].meet_link) {
                  homeworkMeta[key].meet_link = String(hw.meeting_url);
                }
              }
              if (hw.description && homeworkMeta[key].preview.length < 2) {
                homeworkMeta[key].preview.push(hw.description);
              }
            });

            const homeworkIds = homework.map((h) => h.id);
            const finalizeRender = (tagOptions = [], customDeadlinesByDate = {}, weekendDeadlineCards = [], customDeadlineItems = []) => {
              res.render('schedule', {
                scheduleByDay,
                daysOfWeek: activeDays,
                dayDates,
                currentWeek: selectedWeek,
                totalWeeks,
                semester: activeSemester,
                bellSchedule,
                group: isAdminViewAs ? `Група ${viewAsGroupNumber || 1}` : (group || 'A'),
                username,
                homework,
                homeworkMeta,
                homeworkMetaAll: null,
                homeworkTags: tagOptions,
                customDeadlinesByDate,
                weekendDeadlineCards,
                customDeadlineItems,
                customDeadlineSubjects,
                subgroupError: req.query.sg || null,
                role: req.session.role,
                viewAs: req.session.viewAs || null,
                viewAsCourse,
                viewAsGroupNumber: isAdminViewAs ? viewAsGroupNumber : null,
                viewAsLabel,
                messageSubjects: studentGroups || [],
                userId,
                selectedCourseId: scheduleCourseId,
              });
            };

            if (!homeworkIds.length) {
              return loadCustomDeadlines(homeworkTargets, (customDeadlinesByDate, weekendDeadlineCards, customDeadlineItems) =>
                finalizeRender([], customDeadlinesByDate, weekendDeadlineCards, customDeadlineItems)
              );
            }
            const placeholders = homeworkIds.map(() => '?').join(',');
            db.all(
              `SELECT ht.homework_id, t.name
               FROM homework_tag_map ht
               JOIN homework_tags t ON t.id = ht.tag_id
               WHERE ht.homework_id IN (${placeholders})`,
              homeworkIds,
              (tagErr, tagRows) => {
                if (!tagErr && tagRows) {
                  const tagMap = {};
                  tagRows.forEach((row) => {
                    if (!tagMap[row.homework_id]) tagMap[row.homework_id] = [];
                    tagMap[row.homework_id].push(row.name);
                  });
                  homework.forEach((hw) => {
                    hw.tags = tagMap[hw.id] || [];
                  });
                }
                db.all('SELECT name FROM homework_tags ORDER BY name', (tagListErr, tagList) => {
                  const tagOptions = !tagListErr && tagList ? tagList.map((t) => t.name) : [];
                  db.all(
                    `SELECT homework_id, emoji, COUNT(*) AS count
                     FROM homework_reactions
                     WHERE homework_id IN (${placeholders})
                     GROUP BY homework_id, emoji`,
                    homeworkIds,
                    (reactErr, reactRows) => {
                      const reactionMap = {};
                      if (!reactErr && reactRows) {
                        reactRows.forEach((row) => {
                          if (!reactionMap[row.homework_id]) reactionMap[row.homework_id] = {};
                          reactionMap[row.homework_id][row.emoji] = Number(row.count || 0);
                        });
                      }
                      db.all(
                        `SELECT homework_id, emoji
                         FROM homework_reactions
                         WHERE homework_id IN (${placeholders}) AND user_id = ?`,
                        [...homeworkIds, userId],
                        (myErr, myRows) => {
                          const reactedMap = {};
                          if (!myErr && myRows) {
                            myRows.forEach((row) => {
                              if (!reactedMap[row.homework_id]) reactedMap[row.homework_id] = {};
                              reactedMap[row.homework_id][row.emoji] = true;
                            });
                          }
                          homework.forEach((hw) => {
                            hw.reactions = reactionMap[hw.id] || {};
                            hw.reacted = reactedMap[hw.id] || {};
                          });
                          loadCustomDeadlines(homeworkTargets, (customDeadlinesByDate, weekendDeadlineCards, customDeadlineItems) =>
                            finalizeRender(tagOptions, customDeadlinesByDate, weekendDeadlineCards, customDeadlineItems)
                          );
                        }
                      );
                    }
                  );
                });
              }
            );
          }
        );
      };

      const conditionParts = [];
      const params = [selectedWeek, scheduleCourseId, activeSemester ? activeSemester.id : null];
      if (studentGroups.length) {
        conditionParts.push(
          studentGroups.map(() => '(se.subject_id = ? AND se.group_number = ?)').join(' OR ')
        );
        studentGroups.forEach((sg) => {
          params.push(sg.subject_id, sg.group_number);
        });
      }
      conditionParts.push("COALESCE(se.lesson_type, '') = 'lecture'");

      const sql = `
        SELECT se.*, s.name AS subject_name
        FROM schedule_entries se
        JOIN subjects s ON s.id = se.subject_id
        WHERE se.week_number = ? AND se.course_id = ? AND se.semester_id = ? AND s.visible = 1
          AND (${conditionParts.join(' OR ')})
      `;

      db.all(sql, params, (scheduleErr, rows) => {
        if (scheduleErr) {
          return res.status(500).send('Database error');
        }
        rows.forEach((row) => {
          row.class_date = getDateForWeekDay(selectedWeek, row.day_of_week, activeSemester ? activeSemester.start_date : null);
          row.use_local_time = useLocalTime;
          if (scheduleByDay[row.day_of_week]) {
            scheduleByDay[row.day_of_week].push(row);
          }
        });
        activeDays.forEach((day) => {
          scheduleByDay[day].sort((a, b) => a.class_number - b.class_number);
        });
        const homeworkTargets = buildHomeworkTargets(studentGroups, rows || []);
        return loadHomework(homeworkTargets);
      });
    }
  );
});

const normalizeTeamworkLessonScope = (value) => {
  return String(value || '').toLowerCase() === 'seminar' ? 'seminar' : 'lecture';
};

const parseTeamworkGroupNumbers = (rawValue, maxGroupCount = 1) => {
  const safeMaxGroupCount = Math.max(1, Number(maxGroupCount) || 1);
  if (rawValue === null || typeof rawValue === 'undefined') {
    return { all: true, groups: [] };
  }

  const rawTokens = Array.isArray(rawValue) ? rawValue : String(rawValue).split(',');
  const groups = new Set();
  let all = false;

  rawTokens.forEach((tokenValue) => {
    const token = String(tokenValue || '').trim().toLowerCase();
    if (!token) return;
    if (token === 'all') {
      all = true;
      return;
    }
    const groupNum = Number(token);
    if (Number.isInteger(groupNum) && groupNum >= 1 && groupNum <= safeMaxGroupCount) {
      groups.add(groupNum);
    }
  });

  return {
    all,
    groups: Array.from(groups).sort((a, b) => a - b),
  };
};

const serializeTeamworkGroupNumbers = (groupNumbers) => {
  if (!Array.isArray(groupNumbers) || !groupNumbers.length) {
    return null;
  }
  return groupNumbers.join(',');
};

const buildTeamworkRandomDistribution = ({
  students = [],
  bucketCount = 1,
  limitsEnabled = false,
  minMembers = null,
  maxMembers = null,
}) => {
  const normalizedBucketCount = Math.max(1, Number(bucketCount) || 1);
  const shuffled = [...students];
  for (let index = shuffled.length - 1; index > 0; index -= 1) {
    const randomIndex = Math.floor(Math.random() * (index + 1));
    const current = shuffled[index];
    shuffled[index] = shuffled[randomIndex];
    shuffled[randomIndex] = current;
  }

  const distribution = Array.from({ length: normalizedBucketCount }, () => []);
  let cursor = 0;
  if (limitsEnabled && Number(minMembers) > 0) {
    for (let groupIndex = 0; groupIndex < normalizedBucketCount; groupIndex += 1) {
      for (let memberIndex = 0; memberIndex < Number(minMembers); memberIndex += 1) {
        if (cursor >= shuffled.length) break;
        distribution[groupIndex].push(shuffled[cursor]);
        cursor += 1;
      }
    }
  }

  while (cursor < shuffled.length) {
    const groupOrder = distribution
      .map((bucket, groupIndex) => ({ groupIndex, size: bucket.length }))
      .sort((a, b) => a.size - b.size || a.groupIndex - b.groupIndex);
    let placed = false;
    for (const group of groupOrder) {
      if (limitsEnabled && maxMembers && distribution[group.groupIndex].length >= Number(maxMembers)) continue;
      distribution[group.groupIndex].push(shuffled[cursor]);
      cursor += 1;
      placed = true;
      break;
    }
    if (!placed) return null;
  }

  return distribution;
};

const buildTeacherSubjectAccess = (rows, maxGroupCount = 1) => {
  const safeMaxGroupCount = Math.max(1, Number(maxGroupCount) || 1);
  const hasRows = Array.isArray(rows) && rows.length > 0;
  if (!hasRows) {
    return { hasRows: false, allowAll: false, groups: new Set() };
  }

  const allowAll = rows.some((row) => row.group_number === null || typeof row.group_number === 'undefined');
  if (allowAll) {
    return {
      hasRows: true,
      allowAll: true,
      groups: new Set(Array.from({ length: safeMaxGroupCount }, (_v, index) => index + 1)),
    };
  }

  const groups = new Set();
  rows.forEach((row) => {
    const groupNum = Number(row.group_number);
    if (Number.isInteger(groupNum) && groupNum >= 1 && groupNum <= safeMaxGroupCount) {
      groups.add(groupNum);
    }
  });

  return {
    hasRows: true,
    allowAll: false,
    groups,
  };
};

const buildTeamworkTaskAudience = (task, teacherAccess, maxGroupCount = 1) => {
  const safeMaxGroupCount = Math.max(1, Number(maxGroupCount) || 1);
  const allGroups = Array.from({ length: safeMaxGroupCount }, (_value, index) => index + 1);
  const baseAccess = teacherAccess && teacherAccess.hasRows
    ? teacherAccess
    : { hasRows: false, allowAll: true, groups: new Set(allGroups) };

  const lessonScope = normalizeTeamworkLessonScope(task.lesson_scope);
  const baseGroups = baseAccess.allowAll
    ? [...allGroups]
    : Array.from(baseAccess.groups || []).filter((groupNum) => groupNum >= 1 && groupNum <= safeMaxGroupCount).sort((a, b) => a - b);

  if (lessonScope !== 'seminar') {
    const lectureAllowAll = baseAccess.allowAll || baseGroups.length === safeMaxGroupCount;
    return {
      lessonScope,
      allowAll: lectureAllowAll,
      groups: new Set(lectureAllowAll ? allGroups : baseGroups),
      label: lectureAllowAll ? 'Усі групи' : `Групи ${baseGroups.join(', ')}`,
    };
  }

  const parsedSeminarGroups = parseTeamworkGroupNumbers(task.seminar_group_numbers, safeMaxGroupCount);
  const requestedSeminarGroups = parsedSeminarGroups.all || !parsedSeminarGroups.groups.length
    ? [...allGroups]
    : parsedSeminarGroups.groups;
  const finalGroups = requestedSeminarGroups.filter((groupNum) => baseAccess.allowAll || baseGroups.includes(groupNum));
  const seminarAllowAll = finalGroups.length === safeMaxGroupCount;

  return {
    lessonScope,
    allowAll: seminarAllowAll,
    groups: new Set(finalGroups),
    label: seminarAllowAll ? 'Усі групи' : (finalGroups.length ? `Групи ${finalGroups.join(', ')}` : 'Немає груп'),
  };
};

const SUBJECT_MATERIAL_TYPES = new Set(['lecture', 'file', 'link', 'mixed']);

const normalizeSubjectMaterialType = (rawValue) => {
  const normalized = String(rawValue || '').trim().toLowerCase();
  return SUBJECT_MATERIAL_TYPES.has(normalized) ? normalized : 'lecture';
};

const parseSubjectMaterialInputType = (rawValue) => {
  const normalized = String(rawValue || '').trim().toLowerCase();
  if (normalized === 'syllabus') {
    return { materialType: 'lecture', isSyllabus: 1 };
  }
  return {
    materialType: normalizeSubjectMaterialType(normalized),
    isSyllabus: 0,
  };
};

const normalizeExternalUrl = (rawValue) => {
  const value = String(rawValue || '').trim();
  if (!value) return '';
  try {
    const parsed = new URL(value);
    if (!['http:', 'https:'].includes(parsed.protocol)) {
      return '';
    }
    return parsed.toString();
  } catch (err) {
    return '';
  }
};

const JOURNAL_COLUMN_TYPES = new Set(['homework', 'seminar', 'exam', 'credit', 'custom']);
const JOURNAL_SCORING_TYPES = ['homework', 'seminar', 'exam', 'credit', 'custom'];
const JOURNAL_SCORING_TYPE_META = {
  homework: { key: 'homework', label: 'ДЗ' },
  seminar: { key: 'seminar', label: 'Семінар' },
  exam: { key: 'exam', label: 'Екзамен' },
  credit: { key: 'credit', label: 'Залік' },
  custom: { key: 'custom', label: 'Кастом' },
};
const JOURNAL_GRADE_UNDO_SECONDS = 30;
const JOURNAL_SUBJECT_CLOSE_EVENT_TYPE = 'closed';
const JOURNAL_SUBJECT_CLOSED_ERROR = 'Предмет закрито. Редагування журналу вимкнено.';
const SEMESTER_ARCHIVE_UPLOADS_DIR = 'semester-archives';
const JOURNAL_RETAKE_KINDS = ['retake', 'makeup'];
const JOURNAL_RETAKE_KIND_META = {
  retake: { key: 'retake', label: 'Перездача' },
  makeup: { key: 'makeup', label: 'Відпрацювання' },
};
const JOURNAL_RETAKE_STATUSES = ['planned', 'submitted', 'graded', 'cancelled'];
const JOURNAL_RETAKE_STATUS_META = {
  planned: { key: 'planned', label: 'Заплановано' },
  submitted: { key: 'submitted', label: 'Здано' },
  graded: { key: 'graded', label: 'Оцінено' },
  cancelled: { key: 'cancelled', label: 'Скасовано' },
};
const JOURNAL_RETAKE_NOTE_MAX_LENGTH = 1200;
const JOURNAL_RETAKE_COMMENT_MAX_LENGTH = 2000;
const JOURNAL_APPEAL_STATUSES = ['pending', 'in_review', 'approved', 'rejected'];
const JOURNAL_APPEAL_STATUS_META = {
  pending: { key: 'pending', label: 'Нова' },
  in_review: { key: 'in_review', label: 'На розгляді' },
  approved: { key: 'approved', label: 'Підтверджено' },
  rejected: { key: 'rejected', label: 'Відхилено' },
};
const JOURNAL_APPEAL_REASON_MAX_LENGTH = 2400;
const JOURNAL_APPEAL_COMMENT_MAX_LENGTH = 2400;
const JOURNAL_APPEAL_SLA_HOURS = 72;
const JOURNAL_MODERATION_STATUSES = ['pending', 'approved', 'adjusted', 'rejected'];
const JOURNAL_MODERATION_STATUS_META = {
  pending: { key: 'pending', label: 'Очікує другого рецензента' },
  approved: { key: 'approved', label: 'Підтверджено' },
  adjusted: { key: 'adjusted', label: 'Скориговано' },
  rejected: { key: 'rejected', label: 'Відхилено' },
};
const JOURNAL_MODERATION_COMMENT_MAX_LENGTH = 2400;
const COMPETENCY_DEFINITIONS = [
  { key: 'leadership', label: 'Лідерство' },
  { key: 'negotiation', label: 'Перемовини' },
  { key: 'communication', label: 'Ораторика' },
  { key: 'analysis', label: 'Аналітика' },
  { key: 'teamwork', label: 'Командність' },
  { key: 'self_organization', label: 'Самоорганізація' },
  { key: 'critical_thinking', label: 'Критичне мислення' },
  { key: 'resilience', label: 'Стійкість' },
];
const COMPETENCY_KEYS = new Set(COMPETENCY_DEFINITIONS.map((item) => item.key));
const COMPETENCY_SCORE_MIN = 0;
const COMPETENCY_SCORE_MAX = 5;
const COMPETENCY_NOTE_MAX_LENGTH = 1200;
const ATTENDANCE_STATUS_OPTIONS = ['present', 'late', 'absent', 'excused'];
const ATTENDANCE_STATUS_META = {
  present: { key: 'present', label: 'Присутній' },
  late: { key: 'late', label: 'Запізнення' },
  absent: { key: 'absent', label: 'Відсутній' },
  excused: { key: 'excused', label: 'Поважна причина' },
};
const ATTENDANCE_REASON_MAX_LENGTH = 240;

const DEFAULT_SUBJECT_GRADING_SETTINGS = {
  homework_enabled: 1,
  seminar_enabled: 1,
  exam_enabled: 1,
  credit_enabled: 1,
  custom_enabled: 1,
  homework_max_points: 10,
  seminar_max_points: 10,
  exam_max_points: 40,
  credit_max_points: 20,
  custom_max_points: 10,
  homework_weight_points: 20,
  seminar_weight_points: 20,
  exam_weight_points: 40,
  credit_weight_points: 10,
  custom_weight_points: 10,
  final_max_points: 100,
};

const toDateOnly = (rawValue) => String(rawValue || '').slice(0, 10);
const normalizeJournalRetakeKind = (rawValue) => {
  const normalized = String(rawValue || '').trim().toLowerCase();
  return JOURNAL_RETAKE_KINDS.includes(normalized) ? normalized : 'retake';
};

const normalizeJournalRetakeStatus = (rawValue) => {
  const normalized = String(rawValue || '').trim().toLowerCase();
  return JOURNAL_RETAKE_STATUSES.includes(normalized) ? normalized : 'planned';
};

const normalizeJournalRetakeNote = (rawValue) => String(rawValue || '').trim().slice(0, JOURNAL_RETAKE_NOTE_MAX_LENGTH);
const normalizeJournalRetakeComment = (rawValue) => String(rawValue || '').trim().slice(0, JOURNAL_RETAKE_COMMENT_MAX_LENGTH);
const normalizeJournalAppealStatus = (rawValue) => {
  const normalized = String(rawValue || '').trim().toLowerCase();
  return JOURNAL_APPEAL_STATUSES.includes(normalized) ? normalized : 'pending';
};
const normalizeJournalAppealReason = (rawValue) => String(rawValue || '').trim().slice(0, JOURNAL_APPEAL_REASON_MAX_LENGTH);
const normalizeJournalAppealComment = (rawValue) => String(rawValue || '').trim().slice(0, JOURNAL_APPEAL_COMMENT_MAX_LENGTH);
const normalizeJournalModerationStatus = (rawValue) => {
  const normalized = String(rawValue || '').trim().toLowerCase();
  return JOURNAL_MODERATION_STATUSES.includes(normalized) ? normalized : 'pending';
};
const normalizeJournalModerationComment = (rawValue) => String(rawValue || '').trim().slice(0, JOURNAL_MODERATION_COMMENT_MAX_LENGTH);
const normalizeCompetencyKey = (rawValue) => {
  const normalized = String(rawValue || '').trim().toLowerCase();
  return COMPETENCY_KEYS.has(normalized) ? normalized : '';
};
const normalizeCompetencyNote = (rawValue) => String(rawValue || '').trim().slice(0, COMPETENCY_NOTE_MAX_LENGTH);
const parseCompetencyScore = (rawValue) => {
  const parsed = Number(String(rawValue || '').replace(',', '.'));
  if (!Number.isFinite(parsed)) return NaN;
  const normalized = Math.round(parsed * 100) / 100;
  if (normalized < COMPETENCY_SCORE_MIN || normalized > COMPETENCY_SCORE_MAX) return NaN;
  return normalized;
};
const normalizeCompetencyKeyArray = (rawValue) => {
  const values = Array.isArray(rawValue) ? rawValue : [rawValue];
  return Array.from(new Set(
    values
      .map((item) => normalizeCompetencyKey(item))
      .filter((item) => Boolean(item))
  ));
};
const getCompetencyLabelByKey = (key) => {
  const found = COMPETENCY_DEFINITIONS.find((item) => item.key === key);
  return found ? found.label : key;
};

const normalizeAttendanceStatus = (rawValue) => {
  const normalized = String(rawValue || '').trim().toLowerCase();
  return ATTENDANCE_STATUS_OPTIONS.includes(normalized) ? normalized : '';
};

const normalizeAttendanceReason = (rawValue) => {
  const normalized = String(rawValue || '').trim();
  if (!normalized) return '';
  return normalized.slice(0, ATTENDANCE_REASON_MAX_LENGTH);
};

const buildExactSemesterCondition = (alias, semesterId) => {
  if (semesterId) {
    return {
      clause: `AND ${alias}.semester_id = ?`,
      params: [semesterId],
    };
  }
  return {
    clause: `AND ${alias}.semester_id IS NULL`,
    params: [],
  };
};

const buildJournalClosedRedirectPath = (subjectId, message = JOURNAL_SUBJECT_CLOSED_ERROR) => {
  const safeSubjectId = Number(subjectId);
  const base = Number.isFinite(safeSubjectId) && safeSubjectId > 0
    ? `/journal?subject_id=${safeSubjectId}`
    : '/journal';
  const separator = base.includes('?') ? '&' : '?';
  return `${base}${separator}err=${encodeURIComponent(message)}`;
};

const resolveStoredUploadAbsolutePath = (storedPath) => {
  const normalized = String(storedPath || '').trim();
  if (!normalized) return '';
  const relative = normalized.replace(/^\/+/, '');
  if (!relative) return '';
  const absolutePath = path.resolve(__dirname, relative);
  const allowedRoot = path.resolve(uploadsDir);
  if (!absolutePath.startsWith(allowedRoot)) return '';
  return absolutePath;
};

const getAttendanceClassOptions = () => (
  Object.entries(bellSchedule)
    .map(([classNumber, slot]) => ({
      value: Number(classNumber),
      start: slot.start || '',
      end: slot.end || '',
      label: `Пара ${classNumber}${slot.start && slot.end ? ` (${slot.start}-${slot.end})` : ''}`,
    }))
    .sort((a, b) => a.value - b.value)
);

const parseBellTimeToMinutes = (rawValue) => {
  const value = String(rawValue || '').trim();
  const match = value.match(/^(\d{2}):(\d{2})$/);
  if (!match) return null;
  const hours = Number(match[1]);
  const minutes = Number(match[2]);
  if (!Number.isFinite(hours) || !Number.isFinite(minutes)) return null;
  if (hours < 0 || hours > 23 || minutes < 0 || minutes > 59) return null;
  return hours * 60 + minutes;
};

async function resolveJournalCurrentAttendanceSlot({
  subjectId,
  courseId,
  semesterId,
  semester = null,
  allowedGroupNumbers = [],
  hasAllGroups = false,
}) {
  const response = {
    available: false,
    class_date: formatLocalDate(new Date()),
    class_number: null,
    day_of_week: null,
    start: '',
    end: '',
    label: '',
    group_numbers: [],
  };
  if (!Number.isFinite(Number(subjectId)) || !Number.isFinite(Number(courseId))) {
    return response;
  }
  const now = new Date();
  const classDate = formatLocalDate(now);
  response.class_date = classDate;
  const dayName = getDayNameFromDate(classDate);
  response.day_of_week = dayName;
  if (!dayName) return response;
  const weekNumber = getAcademicWeekForSemester(
    new Date(`${classDate}T12:00:00`),
    semester || null
  );
  const semesterFilter = buildExactSemesterCondition('se', semesterId);
  const normalizedGroups = Array.isArray(allowedGroupNumbers)
    ? allowedGroupNumbers
      .map((value) => Number(value))
      .filter((value) => Number.isInteger(value) && value > 0)
    : [];
  const uniqueGroups = Array.from(new Set(normalizedGroups));
  const applyGroupFilter = !hasAllGroups && uniqueGroups.length > 0;
  const groupFilter = applyGroupFilter
    ? ` AND se.group_number IN (${uniqueGroups.map(() => '?').join(',')})`
    : '';
  const groupFilterParams = applyGroupFilter ? uniqueGroups : [];
  const rows = await db.all(
    `
      SELECT se.class_number, se.group_number
      FROM schedule_entries se
      WHERE se.subject_id = ?
        AND se.course_id = ?
        AND se.day_of_week = ?
        AND se.week_number = ?
        ${semesterFilter.clause}
        ${groupFilter}
      ORDER BY se.class_number ASC
    `,
    [Number(subjectId), Number(courseId), dayName, Number(weekNumber), ...semesterFilter.params, ...groupFilterParams]
  );
  if (!rows || !rows.length) return response;

  const nowMinutes = now.getHours() * 60 + now.getMinutes();
  const byClass = new Map();
  (rows || []).forEach((row) => {
    const classNumber = Number(row.class_number || 0);
    if (!Number.isInteger(classNumber) || classNumber < 1 || !bellSchedule[classNumber]) return;
    if (!byClass.has(classNumber)) {
      byClass.set(classNumber, new Set());
    }
    const groupNumber = Number(row.group_number || 0);
    if (Number.isInteger(groupNumber) && groupNumber > 0) {
      byClass.get(classNumber).add(groupNumber);
    }
  });

  const orderedClasses = Array.from(byClass.keys()).sort((a, b) => a - b);
  for (const classNumber of orderedClasses) {
    const slot = bellSchedule[classNumber];
    if (!slot) continue;
    const startMinutes = parseBellTimeToMinutes(slot.start);
    const endMinutes = parseBellTimeToMinutes(slot.end);
    if (!Number.isFinite(startMinutes) || !Number.isFinite(endMinutes)) continue;
    if (nowMinutes < startMinutes || nowMinutes > endMinutes) continue;
    const groups = Array.from(byClass.get(classNumber) || []).sort((a, b) => a - b);
    const groupLabel = groups.length ? ` · Група ${groups.join(', ')}` : '';
    return {
      available: true,
      class_date: classDate,
      class_number: classNumber,
      day_of_week: dayName,
      start: slot.start || '',
      end: slot.end || '',
      label: `Пара ${classNumber}${slot.start && slot.end ? ` (${slot.start}-${slot.end})` : ''}${groupLabel}`,
      group_numbers: groups,
    };
  }
  return response;
}

const normalizeBatchToken = (rawValue) => String(rawValue || '').trim().toLowerCase();

const buildHomeworkBatchKey = (row) => {
  const parts = [
    Number(row?.created_by_id || row?.created_by || 0),
    String(row?.created_at || ''),
    Number(row?.subject_id || 0),
    Number(row?.course_id || 0),
    Number(row?.semester_id || 0),
    Number(row?.is_custom_deadline || 0),
    Number(row?.is_credit || 0),
    Number(row?.is_control || 0),
    normalizeBatchToken(row?.description),
    String(row?.custom_due_date || row?.class_date || ''),
    normalizeBatchToken(row?.day_of_week),
    Number(row?.class_number || 0),
    normalizeBatchToken(row?.meeting_url),
    normalizeBatchToken(row?.link_url),
    normalizeBatchToken(row?.file_path),
  ];
  return parts.join('|');
};

const buildHomeworkBatchKeyFromColumnRow = (row) => {
  return buildHomeworkBatchKey({
    created_by_id: row?.homework_created_by_id,
    created_by: row?.homework_created_by,
    created_at: row?.homework_created_at,
    subject_id: row?.subject_id,
    course_id: row?.course_id,
    semester_id: row?.semester_id,
    is_custom_deadline: row?.homework_is_custom_deadline,
    is_credit: row?.homework_is_credit,
    is_control: row?.homework_is_control,
    description: row?.homework_description,
    custom_due_date: row?.custom_due_date || row?.homework_custom_due_date,
    class_date: row?.class_date || row?.homework_class_date,
    day_of_week: row?.homework_day_of_week,
    class_number: row?.homework_class_number,
    meeting_url: row?.homework_meeting_url,
    link_url: row?.homework_link_url,
    file_path: row?.homework_file_path,
  });
};

const dedupeTeacherHomeworkItems = (items) => {
  const deduped = [];
  const byBatchKey = new Map();
  (Array.isArray(items) ? items : []).forEach((item) => {
    const isTeacherHomework = Number(item?.is_teacher_homework || 0) === 1;
    if (!isTeacherHomework) {
      deduped.push(item);
      return;
    }
    const batchKey = buildHomeworkBatchKey(item);
    if (!byBatchKey.has(batchKey)) {
      const groupNumbers = Number.isInteger(Number(item.group_number)) ? [Number(item.group_number)] : [];
      const next = {
        ...item,
        group_numbers: groupNumbers,
      };
      byBatchKey.set(batchKey, next);
      deduped.push(next);
      return;
    }
    const target = byBatchKey.get(batchKey);
    const groupNumber = Number(item.group_number);
    if (Number.isInteger(groupNumber) && groupNumber > 0) {
      const set = new Set([...(target.group_numbers || []), groupNumber]);
      target.group_numbers = Array.from(set).sort((a, b) => a - b);
      target.group_number = target.group_numbers[0] || target.group_number;
    }
  });
  return deduped;
};

const selectPreferredHomeworkBatchRow = (currentRow, candidateRow, existingByHomeworkId = new Map()) => {
  if (!currentRow) return candidateRow;
  if (!candidateRow) return currentRow;
  const currentColumn = existingByHomeworkId.get(Number(currentRow.id));
  const candidateColumn = existingByHomeworkId.get(Number(candidateRow.id));
  if (currentColumn && !candidateColumn) return currentRow;
  if (candidateColumn && !currentColumn) return candidateRow;
  if (currentColumn && candidateColumn) {
    const currentGrades = Number(currentColumn.grades_count || 0);
    const candidateGrades = Number(candidateColumn.grades_count || 0);
    if (candidateGrades > currentGrades) return candidateRow;
    if (currentGrades > candidateGrades) return currentRow;
  }
  return Number(candidateRow.id || 0) < Number(currentRow.id || 0) ? candidateRow : currentRow;
};

const buildTeacherHomeworkBatchLookup = (rows = []) => {
  const byBatchGroup = new Map();
  const byHomeworkId = new Map();
  (Array.isArray(rows) ? rows : []).forEach((row) => {
    const homeworkId = Number(row?.id || 0);
    if (!Number.isFinite(homeworkId) || homeworkId < 1) return;
    const groupNumber = Number(row?.group_number || 0);
    const batchKey = Number(row?.is_teacher_homework || 0) === 1 ? buildHomeworkBatchKey(row) : '';
    const item = {
      id: homeworkId,
      group_number: Number.isInteger(groupNumber) && groupNumber > 0 ? groupNumber : null,
      batch_key: batchKey,
      custom_due_date: toDateOnly(row?.custom_due_date),
      class_date: toDateOnly(row?.class_date),
    };
    byHomeworkId.set(homeworkId, item);
    if (batchKey && item.group_number) {
      byBatchGroup.set(`${batchKey}|${item.group_number}`, item);
    }
  });
  return {
    byHomeworkId,
    byBatchGroup,
  };
};

const parsePositiveDecimal = (rawValue, fallbackValue) => {
  if (rawValue === null || typeof rawValue === 'undefined' || rawValue === '') return fallbackValue;
  const normalized = Number(String(rawValue).replace(',', '.'));
  if (!Number.isFinite(normalized) || normalized <= 0) return fallbackValue;
  return Math.round(normalized * 100) / 100;
};

const parseNonNegativeDecimal = (rawValue, fallbackValue) => {
  if (rawValue === null || typeof rawValue === 'undefined' || rawValue === '') return fallbackValue;
  const normalized = Number(String(rawValue).replace(',', '.'));
  if (!Number.isFinite(normalized) || normalized < 0) return fallbackValue;
  return Math.round(normalized * 100) / 100;
};

const parseBinaryFlag = (rawValue, fallbackValue = 0) => {
  const candidateValue = Array.isArray(rawValue)
    ? rawValue[rawValue.length - 1]
    : rawValue;
  if (candidateValue === null || typeof candidateValue === 'undefined' || candidateValue === '') {
    return Number(fallbackValue) === 1 ? 1 : 0;
  }
  const normalized = String(candidateValue).trim().toLowerCase();
  if (['1', 'true', 'on', 'yes'].includes(normalized)) return 1;
  if (['0', 'false', 'off', 'no'].includes(normalized)) return 0;
  return Number(fallbackValue) === 1 ? 1 : 0;
};

const normalizeColumnType = (rawValue) => {
  const normalized = String(rawValue || '').trim().toLowerCase();
  return JOURNAL_COLUMN_TYPES.has(normalized) ? normalized : 'custom';
};

const getGradingTypeEnabled = (gradingSettings, columnType) => {
  const safeType = normalizeColumnType(columnType);
  const field = `${safeType}_enabled`;
  const fallback = Number(DEFAULT_SUBJECT_GRADING_SETTINGS[field] || 0);
  return parseBinaryFlag(gradingSettings?.[field], fallback) === 1;
};

const getGradingTypeWeightPoints = (gradingSettings, columnType) => {
  const safeType = normalizeColumnType(columnType);
  const field = `${safeType}_weight_points`;
  const fallback = Number(DEFAULT_SUBJECT_GRADING_SETTINGS[field] || 0);
  return parseNonNegativeDecimal(gradingSettings?.[field], fallback);
};

const getDefaultMaxPointsByType = (gradingSettings, columnType) => {
  const safeSettings = {
    ...DEFAULT_SUBJECT_GRADING_SETTINGS,
    ...(gradingSettings || {}),
  };
  if (columnType === 'homework') return Number(safeSettings.homework_max_points || 10);
  if (columnType === 'seminar') return Number(safeSettings.seminar_max_points || 10);
  if (columnType === 'exam') return Number(safeSettings.exam_max_points || 40);
  if (columnType === 'credit') return Number(safeSettings.credit_max_points || 20);
  return Number(safeSettings.custom_max_points || 10);
};

const isJournalModerationRequiredColumn = (column) => {
  const type = normalizeColumnType(column?.column_type);
  if (type === 'exam' || type === 'credit') return true;
  return Number(column?.is_credit || 0) === 1;
};

const resolveEffectiveGradeScore = (grade, moderation) => {
  const originalScore = Number(grade?.score);
  const moderatedScore = Number(moderation?.moderated_score);
  const moderationStatus = normalizeJournalModerationStatus(moderation?.status);
  if (moderationStatus === 'adjusted' && Number.isFinite(moderatedScore)) {
    return moderatedScore;
  }
  return Number.isFinite(originalScore) ? originalScore : null;
};

async function upsertJournalModerationPending({
  column,
  studentId,
  score,
  actorUserId,
}) {
  if (!isJournalModerationRequiredColumn(column)) return;
  const safeScore = Number(score);
  if (!Number.isFinite(safeScore)) return;
  await db.run(
    `
      INSERT INTO journal_grade_moderations
      (
        subject_id,
        course_id,
        semester_id,
        column_id,
        student_id,
        status,
        original_score,
        moderated_score,
        moderation_comment,
        created_by,
        created_at,
        reviewed_by,
        reviewed_at,
        updated_at
      )
      VALUES (?, ?, ?, ?, ?, 'pending', ?, NULL, NULL, ?, NOW(), NULL, NULL, NOW())
      ON CONFLICT (column_id, student_id)
      DO UPDATE SET
        status = 'pending',
        original_score = EXCLUDED.original_score,
        moderated_score = NULL,
        moderation_comment = NULL,
        reviewed_by = NULL,
        reviewed_at = NULL,
        updated_at = NOW()
    `,
    [
      Number(column.subject_id || 0),
      Number(column.course_id || 0) || null,
      column.semester_id ? Number(column.semester_id) : null,
      Number(column.id || 0),
      Number(studentId || 0),
      safeScore,
      Number(actorUserId || 0) || null,
    ]
  );
}

const buildCompetencyProfileFromSignalRows = ({
  signalRows = [],
  includeEmpty = true,
  now = new Date(),
}) => {
  const safeRows = Array.isArray(signalRows) ? signalRows : [];
  const nowMs = now.getTime();
  const recentSince = nowMs - (30 * 24 * 60 * 60 * 1000);
  const previousSince = nowMs - (60 * 24 * 60 * 60 * 1000);

  const marksByKey = new Map();
  COMPETENCY_DEFINITIONS.forEach((item) => {
    marksByKey.set(item.key, {
      total: 0,
      recent: 0,
      previous: 0,
    });
  });

  safeRows.forEach((row) => {
    const key = normalizeCompetencyKey(row?.competency_key);
    if (!key || !marksByKey.has(key)) return;
    const score = Number(row?.score);
    if (!Number.isFinite(score)) return;
    const mark = score > 0 ? 1 : 0;
    if (mark < 1) return;
    const createdAtMs = row?.created_at ? new Date(row.created_at).getTime() : Number.NaN;
    const bucket = marksByKey.get(key);
    bucket.total += 1;
    if (Number.isFinite(createdAtMs) && createdAtMs >= recentSince) {
      bucket.recent += 1;
    } else if (Number.isFinite(createdAtMs) && createdAtMs >= previousSince && createdAtMs < recentSince) {
      bucket.previous += 1;
    }
  });

  const competencies = COMPETENCY_DEFINITIONS.map((definition) => {
    const bucket = marksByKey.get(definition.key) || { total: 0, recent: 0, previous: 0 };
    const count = Number(bucket.total || 0);
    const delta = Number(bucket.recent || 0) - Number(bucket.previous || 0);
    return {
      key: definition.key,
      label: definition.label,
      count,
      score: count,
      share_percent: 0,
      bar_percent: 0,
      delta: Math.round(delta),
      trend: delta >= 1 ? 'up' : (delta <= -1 ? 'down' : 'steady'),
      has_data: count > 0,
    };
  }).filter((item) => includeEmpty || item.has_data);

  const totalMarks = competencies.reduce((sum, item) => sum + Number(item.count || 0), 0);
  const equalShare = competencies.length ? (100 / competencies.length) : 0;
  competencies.forEach((item) => {
    const share = totalMarks > 0
      ? (Number(item.count || 0) / totalMarks) * 100
      : equalShare;
    item.share_percent = Math.round(share * 100) / 100;
    item.bar_percent = totalMarks > 0 ? item.share_percent : 0;
  });

  const withData = competencies.filter((item) => item.has_data);
  const sortedByScore = [...competencies].sort((a, b) => {
    if (Number(b.count || 0) !== Number(a.count || 0)) return Number(b.count || 0) - Number(a.count || 0);
    if (Number(b.delta || 0) !== Number(a.delta || 0)) return Number(b.delta || 0) - Number(a.delta || 0);
    return String(a.label || '').localeCompare(String(b.label || ''));
  });
  const sortedByWeakest = [...competencies].sort((a, b) => {
    if (Number(a.count || 0) !== Number(b.count || 0)) return Number(a.count || 0) - Number(b.count || 0);
    if (Number(a.delta || 0) !== Number(b.delta || 0)) return Number(a.delta || 0) - Number(b.delta || 0);
    return String(a.label || '').localeCompare(String(b.label || ''));
  });
  const sortedByDelta = [...withData].sort((a, b) => b.delta - a.delta);
  const strongest = totalMarks > 0 ? (sortedByScore[0] || null) : null;
  const weakest = totalMarks > 0 ? (sortedByWeakest[0] || null) : null;
  const fastestGrowth = sortedByDelta.length && Number(sortedByDelta[0].delta || 0) > 0
    ? sortedByDelta[0]
    : null;
  const average = competencies.length
    ? Math.round(totalMarks / competencies.length)
    : 0;

  return {
    competencies: competencies.map((item) => ({
      key: item.key,
      label: item.label,
      count: Math.max(0, Math.floor(Number(item.count || 0))),
      score: Math.max(0, Math.floor(Number(item.score || 0))),
      share_percent: Math.max(0, Math.min(100, Number(item.share_percent || 0))),
      bar_percent: Math.max(0, Math.min(100, Number(item.bar_percent || 0))),
      delta: Number(item.delta || 0),
      trend: item.trend || 'steady',
      has_data: Boolean(item.has_data),
    })),
    strongest,
    weakest,
    fastest_growth: fastestGrowth,
    average,
    total_marks: Math.max(0, Math.floor(totalMarks)),
    has_marks: totalMarks > 0,
    populated_count: withData.length,
  };
};

const buildHomeworkJournalTitle = (homeworkRow) => {
  const base = String(homeworkRow?.description || 'Завдання')
    .replace(/\s+/g, ' ')
    .trim();
  const shortBase = base.length > 78 ? `${base.slice(0, 75)}...` : base;
  const dueDate = toDateOnly(homeworkRow?.custom_due_date || homeworkRow?.class_date);
  return dueDate ? `${shortBase} (${dueDate})` : shortBase;
};

const resolveHomeworkSubmissionStatus = (homeworkRow, submissionRow) => {
  if (!submissionRow) return 'missing';
  const dueDate = toDateOnly(homeworkRow?.custom_due_date || homeworkRow?.class_date);
  if (!dueDate) return 'manual';
  const submittedDate = toDateOnly(submissionRow.submitted_at);
  if (!submittedDate) return 'manual';
  return submittedDate <= dueDate ? 'on_time' : 'late';
};

const isJournalColumnLocked = (column) => Number(column?.is_locked || 0) === 1;

const canUseTeacherJournalMode = (req, journalScope) => {
  const roles = getSessionRoleList(req);
  const hasTeacherContext = roles.some((roleKey) => ['teacher', 'deanery', 'admin'].includes(roleKey));
  return Boolean(
    journalScope?.fullAccess
    || (hasTeacherContext && journalScope?.permissionKeys && journalScope.permissionKeys.has(JOURNAL_OWN_PERMISSION))
    || hasTeacherContext
  );
};

async function ensureSubjectGradingSettings(subjectId, courseId, semesterId, userId) {
  try {
    await db.run(
      `
        INSERT INTO subject_grading_settings
        (
          subject_id, course_id, semester_id,
          homework_enabled, seminar_enabled, exam_enabled, credit_enabled, custom_enabled,
          homework_max_points, seminar_max_points, exam_max_points, credit_max_points, custom_max_points,
          homework_weight_points, seminar_weight_points, exam_weight_points, credit_weight_points, custom_weight_points,
          final_max_points, created_by, updated_by, created_at, updated_at
        )
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 100, ?, ?, NOW(), NOW())
        ON CONFLICT (subject_id) DO NOTHING
      `,
      [
        subjectId,
        courseId || null,
        semesterId || null,
        DEFAULT_SUBJECT_GRADING_SETTINGS.homework_enabled,
        DEFAULT_SUBJECT_GRADING_SETTINGS.seminar_enabled,
        DEFAULT_SUBJECT_GRADING_SETTINGS.exam_enabled,
        DEFAULT_SUBJECT_GRADING_SETTINGS.credit_enabled,
        DEFAULT_SUBJECT_GRADING_SETTINGS.custom_enabled,
        DEFAULT_SUBJECT_GRADING_SETTINGS.homework_max_points,
        DEFAULT_SUBJECT_GRADING_SETTINGS.seminar_max_points,
        DEFAULT_SUBJECT_GRADING_SETTINGS.exam_max_points,
        DEFAULT_SUBJECT_GRADING_SETTINGS.credit_max_points,
        DEFAULT_SUBJECT_GRADING_SETTINGS.custom_max_points,
        DEFAULT_SUBJECT_GRADING_SETTINGS.homework_weight_points,
        DEFAULT_SUBJECT_GRADING_SETTINGS.seminar_weight_points,
        DEFAULT_SUBJECT_GRADING_SETTINGS.exam_weight_points,
        DEFAULT_SUBJECT_GRADING_SETTINGS.credit_weight_points,
        DEFAULT_SUBJECT_GRADING_SETTINGS.custom_weight_points,
        userId || null,
        userId || null,
      ]
    );
    const row = await db.get(
      `
        SELECT *
        FROM subject_grading_settings
        WHERE subject_id = ?
        LIMIT 1
      `,
      [subjectId]
    );
    if (!row) {
      return {
        ...DEFAULT_SUBJECT_GRADING_SETTINGS,
        is_closed: 0,
        closed_by: null,
        closed_at: null,
      };
    }
    return {
      homework_enabled: parseBinaryFlag(row.homework_enabled, DEFAULT_SUBJECT_GRADING_SETTINGS.homework_enabled),
      seminar_enabled: parseBinaryFlag(row.seminar_enabled, DEFAULT_SUBJECT_GRADING_SETTINGS.seminar_enabled),
      exam_enabled: parseBinaryFlag(row.exam_enabled, DEFAULT_SUBJECT_GRADING_SETTINGS.exam_enabled),
      credit_enabled: parseBinaryFlag(row.credit_enabled, DEFAULT_SUBJECT_GRADING_SETTINGS.credit_enabled),
      custom_enabled: parseBinaryFlag(row.custom_enabled, DEFAULT_SUBJECT_GRADING_SETTINGS.custom_enabled),
      homework_max_points: parsePositiveDecimal(row.homework_max_points, DEFAULT_SUBJECT_GRADING_SETTINGS.homework_max_points),
      seminar_max_points: parsePositiveDecimal(row.seminar_max_points, DEFAULT_SUBJECT_GRADING_SETTINGS.seminar_max_points),
      exam_max_points: parsePositiveDecimal(row.exam_max_points, DEFAULT_SUBJECT_GRADING_SETTINGS.exam_max_points),
      credit_max_points: parsePositiveDecimal(row.credit_max_points, DEFAULT_SUBJECT_GRADING_SETTINGS.credit_max_points),
      custom_max_points: parsePositiveDecimal(row.custom_max_points, DEFAULT_SUBJECT_GRADING_SETTINGS.custom_max_points),
      homework_weight_points: parseNonNegativeDecimal(row.homework_weight_points, DEFAULT_SUBJECT_GRADING_SETTINGS.homework_weight_points),
      seminar_weight_points: parseNonNegativeDecimal(row.seminar_weight_points, DEFAULT_SUBJECT_GRADING_SETTINGS.seminar_weight_points),
      exam_weight_points: parseNonNegativeDecimal(row.exam_weight_points, DEFAULT_SUBJECT_GRADING_SETTINGS.exam_weight_points),
      credit_weight_points: parseNonNegativeDecimal(row.credit_weight_points, DEFAULT_SUBJECT_GRADING_SETTINGS.credit_weight_points),
      custom_weight_points: parseNonNegativeDecimal(row.custom_weight_points, DEFAULT_SUBJECT_GRADING_SETTINGS.custom_weight_points),
      final_max_points: 100,
      is_closed: parseBinaryFlag(row.is_closed, 0),
      closed_by: Number.isFinite(Number(row.closed_by)) ? Number(row.closed_by) : null,
      closed_at: row.closed_at || null,
    };
  } catch (err) {
    if (isDbSchemaCompatibilityError(err)) {
      return {
        ...DEFAULT_SUBJECT_GRADING_SETTINGS,
        is_closed: 0,
        closed_by: null,
        closed_at: null,
      };
    }
    throw err;
  }
}

async function getJournalSubjectClosureState(subjectId) {
  const safeSubjectId = Number(subjectId || 0);
  if (!Number.isFinite(safeSubjectId) || safeSubjectId < 1) {
    return {
      is_closed: false,
      closed_by: null,
      closed_at: null,
      latest_event: null,
      latest_export_name: '',
      latest_export_path: '',
    };
  }

  let settingsRow = null;
  let latestEvent = null;
  try {
    settingsRow = await db.get(
      `
        SELECT is_closed, closed_by, closed_at
        FROM subject_grading_settings
        WHERE subject_id = ?
        LIMIT 1
      `,
      [safeSubjectId]
    );
  } catch (_err) {
    settingsRow = null;
  }
  try {
    latestEvent = await db.get(
      `
        SELECT
          id,
          event_type,
          export_file_name,
          export_file_path,
          export_rows_count,
          export_columns_count,
          created_by,
          created_at,
          details
        FROM journal_subject_close_events
        WHERE subject_id = ?
        ORDER BY created_at DESC, id DESC
        LIMIT 1
      `,
      [safeSubjectId]
    );
  } catch (_err) {
    latestEvent = null;
  }

  let inferredClosedFromLocks = false;
  if (!settingsRow) {
    try {
      const lockState = await db.get(
        `
          SELECT
            COUNT(*)::int AS total_columns,
            COUNT(*) FILTER (WHERE COALESCE(is_locked, 0) = 1)::int AS locked_columns
          FROM journal_columns
          WHERE subject_id = ?
            AND COALESCE(is_archived, 0) = 0
        `,
        [safeSubjectId]
      );
      const totalColumns = Number(lockState?.total_columns || 0);
      const lockedColumns = Number(lockState?.locked_columns || 0);
      inferredClosedFromLocks = totalColumns > 0 && lockedColumns >= totalColumns;
    } catch (_err) {
      inferredClosedFromLocks = false;
    }
  }

  return {
    is_closed: Number(settingsRow?.is_closed || 0) === 1 || inferredClosedFromLocks,
    closed_by: Number.isFinite(Number(settingsRow?.closed_by)) ? Number(settingsRow.closed_by) : null,
    closed_at: settingsRow?.closed_at || latestEvent?.created_at || null,
    latest_event: latestEvent
      ? {
          id: Number(latestEvent.id),
          event_type: String(latestEvent.event_type || ''),
          export_file_name: String(latestEvent.export_file_name || ''),
          export_file_path: String(latestEvent.export_file_path || ''),
          export_rows_count: Number(latestEvent.export_rows_count || 0),
          export_columns_count: Number(latestEvent.export_columns_count || 0),
          created_by: Number.isFinite(Number(latestEvent.created_by)) ? Number(latestEvent.created_by) : null,
          created_at: latestEvent.created_at || null,
          details: latestEvent.details || null,
        }
      : null,
    latest_export_name: String(latestEvent?.export_file_name || ''),
    latest_export_path: String(latestEvent?.export_file_path || ''),
  };
}

async function getPreviousSemesterForCourse(courseId, currentSemester = null) {
  const safeCourseId = Number(courseId || 0);
  if (!Number.isFinite(safeCourseId) || safeCourseId < 1) return null;

  const currentSemesterId = Number(currentSemester?.id || 0);
  const currentSemesterStart = String(currentSemester?.start_date || '').trim();
  if (!Number.isFinite(currentSemesterId) || currentSemesterId < 1) return null;

  let row = null;
  if (currentSemesterStart) {
    row = await db.get(
      `
        SELECT id, title, start_date, weeks_count, is_active, is_archived
        FROM semesters
        WHERE course_id = ?
          AND id <> ?
          AND (start_date < ? OR (start_date = ? AND id < ?))
        ORDER BY start_date DESC, id DESC
        LIMIT 1
      `,
      [safeCourseId, currentSemesterId, currentSemesterStart, currentSemesterStart, currentSemesterId]
    );
  }

  if (!row) {
    row = await db.get(
      `
        SELECT id, title, start_date, weeks_count, is_active, is_archived
        FROM semesters
        WHERE course_id = ?
          AND id <> ?
        ORDER BY start_date DESC, id DESC
        LIMIT 1
      `,
      [safeCourseId, currentSemesterId]
    );
  }

  return row || null;
}

const formatJournalClosureCsvNumber = (rawValue) => {
  const numberValue = Number(rawValue);
  if (!Number.isFinite(numberValue)) return '';
  const rounded = Math.round(numberValue * 100) / 100;
  return rounded
    .toFixed(2)
    .replace(/\.00$/, '')
    .replace(/(\.\d)0$/, '$1');
};

function buildJournalClosureCsv({
  subjectName = '',
  courseName = '',
  semesterTitle = '',
  closedAt = new Date(),
  columns = [],
  rows = [],
}) {
  const safeColumns = Array.isArray(columns) ? columns : [];
  const safeRows = Array.isArray(rows) ? rows : [];
  const closedAtIso = closedAt instanceof Date ? closedAt.toISOString() : String(closedAt || new Date().toISOString());
  const lines = [];
  lines.push([
    'Предмет',
    String(subjectName || '').trim() || 'Предмет',
  ].map((value) => escapeCsvValue(value)).join(','));
  lines.push([
    'Курс',
    String(courseName || '').trim() || '-',
  ].map((value) => escapeCsvValue(value)).join(','));
  lines.push([
    'Семестр',
    String(semesterTitle || '').trim() || '-',
  ].map((value) => escapeCsvValue(value)).join(','));
  lines.push([
    'Закрито о',
    closedAtIso,
  ].map((value) => escapeCsvValue(value)).join(','));
  lines.push('');

  const header = [
    'ПІБ',
    'Група',
    ...safeColumns.map((column) => {
      const title = String(column?.title || '').trim() || 'Колонка';
      const maxPoints = formatJournalClosureCsvNumber(column?.max_points);
      return maxPoints ? `${title} (${maxPoints} б.)` : title;
    }),
    'Сирі бали',
    'Сирий максимум',
    'Підсумок / 100',
  ];
  lines.push(header.map((value) => escapeCsvValue(value)).join(','));

  safeRows.forEach((row) => {
    const student = row?.student || {};
    const cells = Array.isArray(row?.cells) ? row.cells : [];
    const cellValues = safeColumns.map((_column, index) => {
      const score = Number(cells[index]?.score);
      return Number.isFinite(score) ? formatJournalClosureCsvNumber(score) : '';
    });
    const line = [
      String(student.full_name || '').trim() || 'Студент',
      Number.isInteger(Number(student.group_number)) && Number(student.group_number) > 0
        ? Number(student.group_number)
        : '',
      ...cellValues,
      formatJournalClosureCsvNumber(row?.raw_earned),
      formatJournalClosureCsvNumber(row?.raw_max),
      formatJournalClosureCsvNumber(row?.final_score),
    ];
    lines.push(line.map((value) => escapeCsvValue(value)).join(','));
  });

  return {
    csv: lines.join('\n'),
    exportRowsCount: safeRows.length,
    exportColumnsCount: safeColumns.length,
  };
}

function writeJournalClosureExportFile({
  subjectId,
  courseId,
  semesterId,
  csvContent,
}) {
  const safeSubjectId = Number(subjectId || 0);
  const safeCourseId = Number(courseId || 0);
  const safeSemesterId = Number(semesterId || 0);
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const directory = path.join(uploadsDir, 'journal-closures', `subject-${safeSubjectId}`);
  fs.mkdirSync(directory, { recursive: true });
  const fileName = `journal-subject-${safeSubjectId}-c${safeCourseId}-s${safeSemesterId}-${timestamp}.csv`;
  const absolutePath = path.join(directory, fileName);
  fs.writeFileSync(absolutePath, String(csvContent || ''), 'utf8');
  const relativeToUploads = path.relative(uploadsDir, absolutePath).split(path.sep).join('/');
  return {
    fileName,
    absolutePath,
    filePath: `/uploads/${relativeToUploads}`,
  };
}

const normalizeArchiveFileSlug = (rawValue, fallback = 'item') => {
  const safeFallback = String(fallback || 'item')
    .replace(/[^a-zA-Z0-9-_]+/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-+|-+$/g, '')
    || 'item';
  const normalized = String(rawValue || '')
    .replace(/[^a-zA-Z0-9-_]+/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-+|-+$/g, '')
    .toLowerCase();
  return normalized || safeFallback;
};

function writeSemesterArchiveFile({
  courseId,
  semesterId,
  fileName,
  content,
}) {
  const safeCourseId = Number(courseId || 0);
  const safeSemesterId = Number(semesterId || 0);
  const safeFileName = String(fileName || '').trim() || `semester-${safeSemesterId}-archive.csv`;
  const directory = path.join(
    uploadsDir,
    SEMESTER_ARCHIVE_UPLOADS_DIR,
    `course-${safeCourseId}`,
    `semester-${safeSemesterId}`
  );
  fs.mkdirSync(directory, { recursive: true });
  const absolutePath = path.join(directory, safeFileName);
  fs.writeFileSync(absolutePath, String(content || ''), 'utf8');
  const relativeToUploads = path.relative(uploadsDir, absolutePath).split(path.sep).join('/');
  return {
    fileName: safeFileName,
    absolutePath,
    filePath: `/uploads/${relativeToUploads}`,
    directory,
  };
}

async function buildSemesterJournalArchiveSnapshot({
  courseId,
  semester,
  actorUserId,
}) {
  const safeCourseId = Number(courseId || 0);
  const safeSemesterId = Number(semester?.id || 0);
  const semesterTitle = String(semester?.title || '').trim() || `Semester ${safeSemesterId}`;
  const timestamp = new Date();
  const timestampToken = timestamp.toISOString().replace(/[:.]/g, '-');

  const subjectRows = await db.all(
    `
      SELECT DISTINCT s.id AS subject_id, s.name AS subject_name
      FROM subjects s
      JOIN journal_columns jc ON jc.subject_id = s.id
      WHERE s.course_id = ?
        AND jc.course_id = ?
        AND jc.semester_id = ?
        AND COALESCE(jc.is_archived, 0) = 0
      ORDER BY s.name ASC, s.id ASC
    `,
    [safeCourseId, safeCourseId, safeSemesterId]
  );

  const summaryLines = [
    ['course_id', 'semester_id', 'semester_title', 'generated_at']
      .map((value) => escapeCsvValue(value)).join(','),
    [safeCourseId, safeSemesterId, semesterTitle, timestamp.toISOString()]
      .map((value) => escapeCsvValue(value)).join(','),
    '',
    ['subject_id', 'subject_name', 'student_id', 'student_name', 'group_number', 'final_score_100', 'weighted_earned', 'raw_earned', 'raw_max']
      .map((value) => escapeCsvValue(value)).join(','),
  ];
  const manifestLines = [
    ['subject_id', 'subject_name', 'rows', 'columns', 'file_name', 'file_path']
      .map((value) => escapeCsvValue(value)).join(','),
  ];

  let studentsRowsCount = 0;
  const subjectFiles = [];

  for (const subject of (subjectRows || [])) {
    const subjectId = Number(subject.subject_id || 0);
    if (!Number.isFinite(subjectId) || subjectId < 1) continue;
    const subjectName = String(subject.subject_name || '').trim() || `Subject ${subjectId}`;
    const matrix = await buildJournalMatrix({
      subjectId,
      courseId: safeCourseId,
      semesterId: safeSemesterId,
      actorUserId: Number(actorUserId || 0) || null,
      groupFilterSet: null,
      studentFilterIds: [],
    });
    const detailedCsv = buildJournalClosureCsv({
      subjectName,
      courseName: `Course ${safeCourseId}`,
      semesterTitle,
      closedAt: timestamp,
      columns: matrix.columns || [],
      rows: matrix.rows || [],
    });
    const subjectSlug = normalizeArchiveFileSlug(subjectName, `subject-${subjectId}`);
    const subjectFile = writeSemesterArchiveFile({
      courseId: safeCourseId,
      semesterId: safeSemesterId,
      fileName: `semester-${safeSemesterId}-subject-${subjectId}-${subjectSlug}-${timestampToken}.csv`,
      content: detailedCsv.csv,
    });
    subjectFiles.push({
      subject_id: subjectId,
      subject_name: subjectName,
      file_name: subjectFile.fileName,
      file_path: subjectFile.filePath,
      rows: Number(detailedCsv.exportRowsCount || 0),
      columns: Number(detailedCsv.exportColumnsCount || 0),
    });
    manifestLines.push(
      [
        subjectId,
        subjectName,
        Number(detailedCsv.exportRowsCount || 0),
        Number(detailedCsv.exportColumnsCount || 0),
        subjectFile.fileName,
        subjectFile.filePath,
      ].map((value) => escapeCsvValue(value)).join(',')
    );

    (matrix.rows || []).forEach((row) => {
      const student = row?.student || {};
      summaryLines.push(
        [
          subjectId,
          subjectName,
          Number(student.id || 0),
          String(student.full_name || '').trim() || 'Студент',
          Number(student.group_number || 0),
          formatJournalClosureCsvNumber(row?.final_score),
          formatJournalClosureCsvNumber(row?.weighted_earned),
          formatJournalClosureCsvNumber(row?.raw_earned),
          formatJournalClosureCsvNumber(row?.raw_max),
        ].map((value) => escapeCsvValue(value)).join(',')
      );
      studentsRowsCount += 1;
    });
  }

  const summaryContent = summaryLines.join('\n');
  const manifestContent = manifestLines.join('\n');
  const summaryFile = writeSemesterArchiveFile({
    courseId: safeCourseId,
    semesterId: safeSemesterId,
    fileName: `semester-${safeSemesterId}-archive-summary-${timestampToken}.csv`,
    content: summaryContent,
  });
  const latestSummaryFile = writeSemesterArchiveFile({
    courseId: safeCourseId,
    semesterId: safeSemesterId,
    fileName: `semester-${safeSemesterId}-archive-summary-latest.csv`,
    content: summaryContent,
  });
  const manifestFile = writeSemesterArchiveFile({
    courseId: safeCourseId,
    semesterId: safeSemesterId,
    fileName: `semester-${safeSemesterId}-archive-manifest-${timestampToken}.csv`,
    content: manifestContent,
  });
  const latestManifestFile = writeSemesterArchiveFile({
    courseId: safeCourseId,
    semesterId: safeSemesterId,
    fileName: `semester-${safeSemesterId}-archive-manifest-latest.csv`,
    content: manifestContent,
  });

  return {
    summary_file: summaryFile,
    summary_file_latest: latestSummaryFile,
    manifest_file: manifestFile,
    manifest_file_latest: latestManifestFile,
    subject_files: subjectFiles,
    subjects_count: subjectFiles.length,
    students_rows_count: studentsRowsCount,
    generated_at: timestamp.toISOString(),
  };
}

async function syncJournalColumnsFromHomework(subjectId, courseId, semesterId, gradingSettings, userId) {
  const params = [subjectId, courseId];
  let sql = `
    SELECT
      h.id,
      h.subject_id,
      h.course_id,
      h.semester_id,
      h.group_number,
      h.description,
      h.custom_due_date,
      h.class_date,
      h.day_of_week,
      h.class_number,
      h.meeting_url,
      h.link_url,
      h.file_path,
      h.is_credit,
      h.is_control,
      h.is_custom_deadline,
      h.is_teacher_homework,
      h.created_by_id,
      h.created_by,
      h.created_at
    FROM homework h
    WHERE h.subject_id = ?
      AND h.course_id = ?
      AND COALESCE(h.status, 'published') = 'published'
      AND COALESCE(h.is_teacher_homework, 0) = 1
  `;
  if (semesterId) {
    sql += ' AND (h.semester_id = ? OR h.semester_id IS NULL)';
    params.push(semesterId);
  } else {
    sql += ' AND h.semester_id IS NULL';
  }
  sql += ' ORDER BY COALESCE(h.custom_due_date, h.class_date, h.created_at) ASC, h.id ASC';
  const rawHomeworkRows = await db.all(sql, params);

  const columnParams = [subjectId, courseId];
  let columnsSql = `
    SELECT
      jc.id,
      jc.source_homework_id,
      jc.title,
      jc.column_type,
      jc.max_points,
      jc.include_in_final,
      jc.is_credit,
      jc.position,
      COALESCE(gc.grades_count, 0) AS grades_count,
      COALESCE(hs.is_teacher_homework, 0) AS source_is_teacher_homework
    FROM journal_columns jc
    LEFT JOIN (
      SELECT column_id, COUNT(*) AS grades_count
      FROM journal_grades
      WHERE deleted_at IS NULL
      GROUP BY column_id
    ) gc ON gc.column_id = jc.id
    LEFT JOIN homework hs ON hs.id = jc.source_homework_id
    WHERE jc.subject_id = ?
      AND jc.course_id = ?
      AND jc.source_homework_id IS NOT NULL
      AND COALESCE(jc.is_archived, 0) = 0
  `;
  if (semesterId) {
    columnsSql += ' AND (jc.semester_id = ? OR jc.semester_id IS NULL)';
    columnParams.push(semesterId);
  } else {
    columnsSql += ' AND jc.semester_id IS NULL';
  }
  const existing = await db.all(columnsSql, columnParams);
  const existingByHomeworkId = new Map();
  const staleHomeworkColumnIds = [];
  let maxNonCreditPosition = 0;
  let maxCreditPosition = 0;
  (existing || []).forEach((row) => {
    if (Number(row.source_is_teacher_homework || 0) !== 1) {
      const staleId = Number(row.id);
      if (Number.isFinite(staleId) && staleId > 0) {
        staleHomeworkColumnIds.push(staleId);
      }
      return;
    }
    existingByHomeworkId.set(Number(row.source_homework_id), row);
    const position = Number(row.position || 0);
    if (Number(row.is_credit) === 1) {
      if (position > maxCreditPosition) maxCreditPosition = position;
    } else if (position > maxNonCreditPosition) {
      maxNonCreditPosition = position;
    }
  });
  if (staleHomeworkColumnIds.length) {
    await db.run(
      `
        UPDATE journal_columns
        SET is_archived = 1,
            updated_at = NOW()
        WHERE id = ANY(?)
      `,
      [staleHomeworkColumnIds]
    );
  }

  const dedupedHomeworkRows = [];
  const teacherBatchState = new Map();
  (rawHomeworkRows || []).forEach((homeworkRow) => {
    const isTeacherHomework = Number(homeworkRow.is_teacher_homework || 0) === 1;
    if (!isTeacherHomework) {
      dedupedHomeworkRows.push(homeworkRow);
      return;
    }
    const batchKey = buildHomeworkBatchKey(homeworkRow);
    if (!teacherBatchState.has(batchKey)) {
      teacherBatchState.set(batchKey, {
        index: dedupedHomeworkRows.length,
        preferred: homeworkRow,
        rows: [homeworkRow],
      });
      dedupedHomeworkRows.push(homeworkRow);
      return;
    }
    const state = teacherBatchState.get(batchKey);
    state.rows.push(homeworkRow);
    state.preferred = selectPreferredHomeworkBatchRow(state.preferred, homeworkRow, existingByHomeworkId);
    dedupedHomeworkRows[state.index] = state.preferred;
  });

  for (const state of teacherBatchState.values()) {
    if (!state || !state.rows || state.rows.length < 2 || !state.preferred) continue;
    const preferredHomeworkId = Number(state.preferred.id);
    const targetColumn = existingByHomeworkId.get(preferredHomeworkId);
    if (!targetColumn) continue;
    for (const row of state.rows) {
      const duplicateHomeworkId = Number(row.id);
      if (!Number.isFinite(duplicateHomeworkId) || duplicateHomeworkId < 1 || duplicateHomeworkId === preferredHomeworkId) continue;
      const duplicateColumn = existingByHomeworkId.get(duplicateHomeworkId);
      if (!duplicateColumn || Number(duplicateColumn.id) === Number(targetColumn.id)) continue;
      await db.run(
        `
          INSERT INTO journal_grades
            (column_id, student_id, score, teacher_comment, graded_by, graded_at, submission_status)
          SELECT ?, student_id, score, teacher_comment, graded_by, graded_at, submission_status
          FROM journal_grades
          WHERE column_id = ?
            AND deleted_at IS NULL
          ON CONFLICT (column_id, student_id) DO NOTHING
        `,
        [targetColumn.id, duplicateColumn.id]
      );
      await db.run(
        `
          UPDATE journal_columns
          SET is_archived = 1,
              updated_at = NOW()
          WHERE id = ?
        `,
        [duplicateColumn.id]
      );
      existingByHomeworkId.delete(duplicateHomeworkId);
    }
  }

  for (const homeworkRow of dedupedHomeworkRows) {
    const homeworkId = Number(homeworkRow.id);
    const isCredit = Number(homeworkRow.is_credit || 0) === 1 ? 1 : 0;
    const columnType = isCredit ? 'credit' : 'homework';
    const title = buildHomeworkJournalTitle(homeworkRow);
    const defaultMaxPoints = parsePositiveDecimal(
      getDefaultMaxPointsByType(gradingSettings, columnType),
      getDefaultMaxPointsByType(DEFAULT_SUBJECT_GRADING_SETTINGS, columnType)
    );
    const existingRow = existingByHomeworkId.get(homeworkId);
    if (existingRow) {
      const existingMaxPoints = parsePositiveDecimal(existingRow.max_points, defaultMaxPoints);
      const needsUpdate = String(existingRow.title || '') !== title
        || String(existingRow.column_type || '') !== columnType
        || Number(existingRow.is_credit || 0) !== isCredit
        || Number(existingMaxPoints) !== Number(defaultMaxPoints);
      if (needsUpdate) {
        await db.run(
          `
            UPDATE journal_columns
            SET title = ?,
                column_type = ?,
                is_credit = ?,
                max_points = ?,
                updated_at = NOW()
            WHERE id = ?
          `,
          [title, columnType, isCredit, defaultMaxPoints, existingRow.id]
        );
      }
      continue;
    }
    const nextPosition = isCredit ? (maxCreditPosition + 10) : (maxNonCreditPosition + 10);
    if (isCredit) maxCreditPosition = nextPosition;
    else maxNonCreditPosition = nextPosition;
    const includeInFinalDefault = getGradingTypeEnabled(gradingSettings, columnType) ? 1 : 0;
    await db.run(
      `
        INSERT INTO journal_columns
        (
          subject_id, course_id, semester_id, source_type, source_homework_id,
          title, column_type, max_points, position, is_credit, include_in_final, created_by, created_at, updated_at
        )
        VALUES (?, ?, ?, 'homework', ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
      `,
      [
        subjectId,
        courseId,
        semesterId || null,
        homeworkId,
        title,
        columnType,
        defaultMaxPoints,
        nextPosition,
        isCredit,
        includeInFinalDefault,
        userId || null,
      ]
    );
  }
}

async function getTeacherJournalSubjectAccess(userId, subjectId) {
  const rows = await db.all(
    `
      SELECT ts.group_number, s.group_count
      FROM teacher_subjects ts
      JOIN subjects s ON s.id = ts.subject_id
      WHERE ts.user_id = ? AND ts.subject_id = ?
    `,
    [userId, subjectId]
  );
  if (!rows || !rows.length) {
    return { hasRows: false, allowAll: false, groups: new Set() };
  }
  return buildTeacherSubjectAccess(rows, Number(rows[0].group_count || 1));
}

async function getStudentJournalSubjectOptions(userId) {
  const rows = await db.all(
    `
      SELECT sg.subject_id, sg.group_number, s.name AS subject_name, s.group_count, s.course_id, c.name AS course_name
      FROM student_groups sg
      JOIN subjects s ON s.id = sg.subject_id
      JOIN courses c ON c.id = s.course_id
      WHERE sg.student_id = ?
        AND COALESCE(LOWER(TRIM(CAST(s.visible AS TEXT))), '1') IN ('1', 'true', 't')
      ORDER BY c.id ASC, s.name ASC
    `,
    [userId]
  );
  return (rows || []).map((row) => ({
    subject_id: Number(row.subject_id),
    subject_name: row.subject_name,
    group_count: Math.max(1, Number(row.group_count || 1)),
    course_id: Number(row.course_id || 1),
    course_name: row.course_name || '',
    has_all_groups: false,
    group_numbers: [Number(row.group_number || 1)],
    group_label: `Група ${Number(row.group_number || 1)}`,
  }));
}

async function getJournalSubjectOptionsForUser(req, journalScope, teacherJournalMode) {
  const userId = Number(req.session.user.id);
  if (teacherJournalMode && journalScope.fullAccess) {
    const rows = await db.all(
      `
        SELECT s.id AS subject_id, s.name AS subject_name, s.group_count, s.course_id, c.name AS course_name
        FROM subjects s
        JOIN courses c ON c.id = s.course_id
        WHERE COALESCE(LOWER(TRIM(CAST(s.visible AS TEXT))), '1') IN ('1', 'true', 't')
        ORDER BY c.id ASC, s.name ASC
      `
    );
    return (rows || []).map((row) => ({
      subject_id: Number(row.subject_id),
      subject_name: row.subject_name,
      group_count: Math.max(1, Number(row.group_count || 1)),
      course_id: Number(row.course_id || 1),
      course_name: row.course_name || '',
      has_all_groups: true,
      group_numbers: Array.from({ length: Math.max(1, Number(row.group_count || 1)) }, (_v, index) => index + 1),
      group_label: 'Усі групи',
    }));
  }

  if (teacherJournalMode) {
    const rows = await db.all(
      `
        SELECT ts.subject_id, ts.group_number, s.name AS subject_name, s.group_count, s.course_id, c.name AS course_name
        FROM teacher_subjects ts
        JOIN subjects s ON s.id = ts.subject_id
        JOIN courses c ON c.id = s.course_id
        WHERE ts.user_id = ?
          AND COALESCE(LOWER(TRIM(CAST(s.visible AS TEXT))), '1') IN ('1', 'true', 't')
        ORDER BY c.id ASC, s.name ASC
      `,
      [userId]
    );
    if (!rows || !rows.length) {
      return getStudentJournalSubjectOptions(userId);
    }
    const map = new Map();
    (rows || []).forEach((row) => {
      const key = Number(row.subject_id);
      if (!map.has(key)) {
        map.set(key, {
          subject_id: key,
          subject_name: row.subject_name,
          group_count: Math.max(1, Number(row.group_count || 1)),
          course_id: Number(row.course_id || 1),
          course_name: row.course_name || '',
          has_all_groups: false,
          group_numbers_set: new Set(),
        });
      }
      const item = map.get(key);
      if (row.group_number === null || typeof row.group_number === 'undefined') {
        item.has_all_groups = true;
      } else {
        const groupNumber = Number(row.group_number);
        if (Number.isInteger(groupNumber) && groupNumber > 0) {
          item.group_numbers_set.add(groupNumber);
        }
      }
    });
    return Array.from(map.values()).map((item) => {
      const groupNumbers = item.has_all_groups
        ? Array.from({ length: item.group_count }, (_v, index) => index + 1)
        : Array.from(item.group_numbers_set).sort((a, b) => a - b);
      let groupLabel = 'Без груп';
      if (item.has_all_groups) groupLabel = 'Усі групи';
      else if (groupNumbers.length === 1) groupLabel = `Група ${groupNumbers[0]}`;
      else if (groupNumbers.length > 1) groupLabel = `Групи ${groupNumbers.join(', ')}`;
      return {
        subject_id: item.subject_id,
        subject_name: item.subject_name,
        group_count: item.group_count,
        course_id: item.course_id,
        course_name: item.course_name,
        has_all_groups: item.has_all_groups,
        group_numbers: groupNumbers,
        group_label: groupLabel,
      };
    });
  }

  return getStudentJournalSubjectOptions(userId);
}

async function getJournalColumns(subjectId, courseId, semesterId) {
  const params = [subjectId, courseId];
  let sql = `
    SELECT
      jc.*,
      COALESCE(gc.grades_count, 0) AS grades_count,
      h.description AS homework_description,
      h.custom_due_date,
      h.class_date,
      h.group_number AS homework_group_number,
      h.day_of_week AS homework_day_of_week,
      h.class_number AS homework_class_number,
      h.meeting_url AS homework_meeting_url,
      h.link_url AS homework_link_url,
      h.file_path AS homework_file_path,
      h.file_name AS homework_file_name,
      h.is_custom_deadline AS homework_is_custom_deadline,
      h.is_control AS homework_is_control,
      h.is_credit AS homework_is_credit,
      h.is_teacher_homework AS homework_is_teacher_homework,
      h.created_at AS homework_created_at,
      h.created_by AS homework_created_by,
      h.created_by_id AS homework_created_by_id,
      u.full_name AS homework_created_by_name
    FROM journal_columns jc
    LEFT JOIN (
      SELECT column_id, COUNT(*) AS grades_count
      FROM journal_grades
      WHERE deleted_at IS NULL
      GROUP BY column_id
    ) gc ON gc.column_id = jc.id
    LEFT JOIN homework h ON h.id = jc.source_homework_id
    LEFT JOIN users u ON u.id = h.created_by_id
    WHERE jc.subject_id = ?
      AND jc.course_id = ?
      AND COALESCE(jc.is_archived, 0) = 0
  `;
  if (semesterId) {
    sql += ' AND (jc.semester_id = ? OR jc.semester_id IS NULL)';
    params.push(semesterId);
  } else {
    sql += ' AND jc.semester_id IS NULL';
  }
  sql += `
    ORDER BY
      CASE WHEN COALESCE(jc.is_credit, 0) = 1 THEN 1 ELSE 0 END ASC,
      COALESCE(jc.position, 0) ASC,
      COALESCE(h.custom_due_date, h.class_date, h.created_at, jc.created_at::text) ASC,
      jc.id ASC
  `;
  let rows = [];
  try {
    rows = await db.all(sql, params);
  } catch (err) {
    if (!isDbSchemaCompatibilityError(err)) {
      throw err;
    }
    try {
      const legacyParams = [subjectId, courseId];
      let legacySql = `
        SELECT
          jc.id,
          jc.subject_id,
          jc.course_id,
          jc.semester_id,
          jc.source_type,
          jc.source_homework_id,
          jc.title,
          jc.column_type,
          jc.max_points,
          CASE WHEN LOWER(COALESCE(jc.column_type, '')) = 'credit' THEN 1 ELSE 0 END AS is_credit,
          COALESCE(jc.position, 0) AS position,
          0::int AS grades_count,
          h.description AS homework_description,
          h.custom_due_date,
          h.class_date,
          h.group_number AS homework_group_number,
          h.day_of_week AS homework_day_of_week,
          h.class_number AS homework_class_number,
          h.meeting_url AS homework_meeting_url,
          h.link_url AS homework_link_url,
          h.file_path AS homework_file_path,
          h.file_name AS homework_file_name,
          0::int AS homework_is_custom_deadline,
          0::int AS homework_is_control,
          0::int AS homework_is_credit,
          0::int AS homework_is_teacher_homework,
          h.created_at AS homework_created_at,
          h.created_by AS homework_created_by,
          h.created_by_id AS homework_created_by_id,
          u.full_name AS homework_created_by_name
        FROM journal_columns jc
        LEFT JOIN homework h ON h.id = jc.source_homework_id
        LEFT JOIN users u ON u.id = h.created_by_id
        WHERE jc.subject_id = ?
          AND jc.course_id = ?
      `;
      if (semesterId) {
        legacySql += ' AND (jc.semester_id = ? OR jc.semester_id IS NULL)';
        legacyParams.push(semesterId);
      } else {
        legacySql += ' AND jc.semester_id IS NULL';
      }
      legacySql += ' ORDER BY COALESCE(jc.position, 0) ASC, jc.id ASC';
      rows = await db.all(legacySql, legacyParams);
    } catch (legacyErr) {
      if (!isDbSchemaCompatibilityError(legacyErr)) {
        throw legacyErr;
      }
      rows = [];
    }
  }
  const normalizedRows = (rows || []).map((row) => {
    const sourceHomeworkId = row.source_homework_id ? Number(row.source_homework_id) : null;
    const sourceHomeworkIsTeacher = Number(row.homework_is_teacher_homework || 0) === 1;
    const sourceHomeworkBatchKey = sourceHomeworkId && sourceHomeworkIsTeacher
      ? buildHomeworkBatchKeyFromColumnRow({
          ...row,
          subject_id: row.subject_id,
          course_id: row.course_id,
          semester_id: row.semester_id,
        })
      : '';
    return {
      id: Number(row.id),
      subject_id: Number(row.subject_id),
      source_type: String(row.source_type || 'manual'),
      source_homework_id: sourceHomeworkId,
      source_homework_is_teacher: sourceHomeworkIsTeacher,
      source_homework_batch_key: sourceHomeworkBatchKey,
      title: String(row.title || ''),
      column_type: normalizeColumnType(row.column_type),
      max_points: parsePositiveDecimal(row.max_points, 10),
      include_in_final: Number(row.include_in_final ?? 1) === 1,
      is_locked: Number(row.is_locked || 0) === 1,
      is_credit: Number(row.is_credit || 0) === 1,
      position: Number(row.position || 0),
      homework_description: row.homework_description || null,
      custom_due_date: toDateOnly(row.custom_due_date),
      class_date: toDateOnly(row.class_date),
      homework_group_number: row.homework_group_number ? Number(row.homework_group_number) : null,
      homework_meeting_url: row.homework_meeting_url || null,
      homework_link_url: row.homework_link_url || null,
      homework_file_path: row.homework_file_path || null,
      homework_file_name: normalizeUploadedOriginalName(row.homework_file_name),
      homework_is_custom_deadline: Number(row.homework_is_custom_deadline || 0) === 1,
      homework_created_at: row.homework_created_at || null,
      homework_created_by: row.homework_created_by || null,
      homework_created_by_name: row.homework_created_by_name || null,
      _grades_count: Number(row.grades_count || 0),
    };
  });

  const selectedByKey = new Map();
  const orderedKeys = [];
  normalizedRows.forEach((column) => {
    const dedupeKey = column.source_homework_id && column.source_homework_is_teacher && column.source_homework_batch_key
      ? `teacher:${column.source_homework_batch_key}`
      : `column:${column.id}`;
    if (!selectedByKey.has(dedupeKey)) {
      selectedByKey.set(dedupeKey, column);
      orderedKeys.push(dedupeKey);
      return;
    }
    const existingColumn = selectedByKey.get(dedupeKey);
    const shouldReplace = Number(column._grades_count || 0) > Number(existingColumn._grades_count || 0)
      || (
        Number(column._grades_count || 0) === Number(existingColumn._grades_count || 0)
        && Number(column.id || 0) < Number(existingColumn.id || 0)
      );
    if (shouldReplace) {
      selectedByKey.set(dedupeKey, column);
    }
  });

  return orderedKeys.map((key) => {
    const row = { ...(selectedByKey.get(key) || {}) };
    delete row._grades_count;
    return row;
  });
}

async function getJournalStudents(subjectId, courseId, groupFilterSet = null, userFilterIds = []) {
  const activeUserFilter = usersHasIsActive
    ? " AND COALESCE(LOWER(TRIM(CAST(u.is_active AS TEXT))), '1') IN ('1', 'true', 't')"
    : '';
  const params = [subjectId, courseId];
  let sql = `
    SELECT DISTINCT u.id, u.full_name, sg.group_number
    FROM student_groups sg
    JOIN users u ON u.id = sg.student_id
    WHERE sg.subject_id = ?
      AND u.course_id = ?
      ${activeUserFilter}
  `;
  if (groupFilterSet && groupFilterSet.size) {
    const groups = Array.from(groupFilterSet).filter((value) => Number.isInteger(value) && value > 0);
    if (groups.length) {
      sql += ` AND sg.group_number IN (${groups.map(() => '?').join(',')})`;
      params.push(...groups);
    }
  }
  const userIds = Array.isArray(userFilterIds)
    ? Array.from(new Set(userFilterIds.map((value) => Number(value)).filter((value) => Number.isFinite(value) && value > 0)))
    : [];
  if (userIds.length) {
    sql += ` AND u.id IN (${userIds.map(() => '?').join(',')})`;
    params.push(...userIds);
  }
  sql += ' ORDER BY sg.group_number ASC, u.full_name ASC';
  const rows = await db.all(sql, params);
  return (rows || []).map((row) => ({
    id: Number(row.id),
    full_name: row.full_name,
    group_number: Number(row.group_number || 0),
  }));
}

async function getJournalStudentGroup(subjectId, studentId) {
  const activeUserFilter = usersHasIsActive
    ? " AND COALESCE(LOWER(TRIM(CAST(u.is_active AS TEXT))), '1') IN ('1', 'true', 't')"
    : '';
  return db.get(
    `
      SELECT sg.group_number
      FROM student_groups sg
      JOIN users u ON u.id = sg.student_id
      WHERE sg.subject_id = ? AND sg.student_id = ?${activeUserFilter}
      LIMIT 1
    `,
    [subjectId, studentId]
  );
}

async function buildJournalAttendanceContext({
  subjectId,
  courseId,
  semesterId,
  semester = null,
  students = [],
  requestedDate,
  requestedClassNumber,
  studentViewUserId = null,
  allowedGroupNumbers = [],
  hasAllGroups = false,
}) {
  const classOptions = getAttendanceClassOptions();
  const normalizedDate = isValidDateString(String(requestedDate || ''))
    ? String(requestedDate)
    : formatLocalDate(new Date());
  const classNumberRaw = Number(requestedClassNumber);
  const normalizedClassNumber = (
    Number.isInteger(classNumberRaw)
    && classNumberRaw > 0
    && classOptions.some((option) => option.value === classNumberRaw)
  )
    ? classNumberRaw
    : (classOptions[0] ? Number(classOptions[0].value) : 1);

  const safeStudents = Array.isArray(students)
    ? students
      .map((student) => ({
        id: Number(student?.id || 0),
        full_name: String(student?.full_name || '').trim() || 'Студент',
        group_number: Number(student?.group_number || 0),
      }))
      .filter((student) => Number.isFinite(student.id) && student.id > 0)
    : [];
  const studentIds = safeStudents.map((student) => student.id);

  const semesterFilter = buildExactSemesterCondition('ar', semesterId);
  let recordsByStudentId = new Map();
  if (studentIds.length) {
    try {
      const rows = await db.all(
        `
          SELECT ar.student_id, ar.status, ar.reason, ar.marked_at
          FROM attendance_records ar
          WHERE ar.subject_id = ?
            AND ar.course_id = ?
            ${semesterFilter.clause}
            AND ar.class_date = ?
            AND ar.class_number = ?
            AND ar.student_id = ANY(?::int[])
        `,
        [subjectId, courseId, ...semesterFilter.params, normalizedDate, normalizedClassNumber, studentIds]
      );
      recordsByStudentId = new Map(
        (rows || []).map((row) => [
          Number(row.student_id),
          {
            status: normalizeAttendanceStatus(row.status),
            reason: String(row.reason || ''),
            marked_at: row.marked_at || null,
          },
        ])
      );
    } catch (err) {
      if (!isDbSchemaCompatibilityError(err)) {
        throw err;
      }
      recordsByStudentId = new Map();
    }
  }

  const summary = {
    present: 0,
    late: 0,
    absent: 0,
    excused: 0,
    unset: 0,
    marked_total: 0,
    students_total: safeStudents.length,
  };

  const rows = safeStudents.map((student) => {
    const record = recordsByStudentId.get(student.id) || null;
    const status = record ? normalizeAttendanceStatus(record.status) : '';
    if (!status) {
      summary.unset += 1;
    } else {
      summary.marked_total += 1;
      summary[status] = Number(summary[status] || 0) + 1;
    }
    return {
      student_id: student.id,
      full_name: student.full_name,
      group_number: Number.isInteger(student.group_number) && student.group_number > 0 ? student.group_number : null,
      status,
      reason: record ? String(record.reason || '') : '',
      marked_at: record ? (record.marked_at || null) : null,
    };
  });

  let studentSummary = null;
  const safeStudentViewId = Number(studentViewUserId || 0);
  if (Number.isFinite(safeStudentViewId) && safeStudentViewId > 0) {
    try {
      const groupedRows = await db.all(
        `
          SELECT ar.status, COUNT(*) AS count
          FROM attendance_records ar
          WHERE ar.subject_id = ?
            AND ar.course_id = ?
            ${semesterFilter.clause}
            AND ar.student_id = ?
          GROUP BY ar.status
        `,
        [subjectId, courseId, ...semesterFilter.params, safeStudentViewId]
      );
      const recentRows = await db.all(
        `
          SELECT ar.class_date, ar.class_number, ar.status, ar.reason, ar.marked_at
          FROM attendance_records ar
          WHERE ar.subject_id = ?
            AND ar.course_id = ?
            ${semesterFilter.clause}
            AND ar.student_id = ?
          ORDER BY ar.class_date DESC, ar.class_number DESC
          LIMIT 8
        `,
        [subjectId, courseId, ...semesterFilter.params, safeStudentViewId]
      );
      const grouped = {
        present: 0,
        late: 0,
        absent: 0,
        excused: 0,
      };
      (groupedRows || []).forEach((row) => {
        const status = normalizeAttendanceStatus(row.status);
        if (!status) return;
        grouped[status] = Number(row.count || 0);
      });
      const attendedTotal = Number(grouped.present || 0) + Number(grouped.late || 0);
      const recordsTotal = attendedTotal + Number(grouped.absent || 0) + Number(grouped.excused || 0);
      studentSummary = {
        ...grouped,
        total: recordsTotal,
        attended_total: attendedTotal,
        attendance_rate: recordsTotal > 0 ? Math.round((attendedTotal / recordsTotal) * 100) : null,
        recent_records: (recentRows || []).map((row) => ({
          class_date: toDateOnly(row.class_date),
          class_number: Number(row.class_number || 0),
          status: normalizeAttendanceStatus(row.status),
          reason: String(row.reason || ''),
          marked_at: row.marked_at || null,
        })),
      };
    } catch (err) {
      if (!isDbSchemaCompatibilityError(err)) {
        throw err;
      }
      studentSummary = null;
    }
  }

  let quickCurrentSlot = {
    available: false,
    class_date: formatLocalDate(new Date()),
    class_number: null,
    day_of_week: null,
    start: '',
    end: '',
    label: '',
    group_numbers: [],
    is_selected: false,
  };
  if (!(Number.isFinite(safeStudentViewId) && safeStudentViewId > 0)) {
    quickCurrentSlot = await resolveJournalCurrentAttendanceSlot({
      subjectId,
      courseId,
      semesterId,
      semester,
      allowedGroupNumbers,
      hasAllGroups,
    });
    quickCurrentSlot.is_selected = Boolean(
      quickCurrentSlot.available
      && String(quickCurrentSlot.class_date || '') === String(normalizedDate || '')
      && Number(quickCurrentSlot.class_number) === Number(normalizedClassNumber)
    );
  }

  return {
    date: normalizedDate,
    class_number: normalizedClassNumber,
    class_options: classOptions,
    statuses: ATTENDANCE_STATUS_OPTIONS.map((status) => ATTENDANCE_STATUS_META[status]),
    rows,
    summary,
    student_summary: studentSummary,
    reason_max_length: ATTENDANCE_REASON_MAX_LENGTH,
    quick_current_slot: quickCurrentSlot,
  };
}

async function resolveJournalColumnHomeworkForStudent(columnRow, studentGroupNumber) {
  const sourceHomeworkId = Number(columnRow?.source_homework_id || 0);
  const fallback = {
    homework_id: Number.isFinite(sourceHomeworkId) && sourceHomeworkId > 0 ? sourceHomeworkId : null,
    custom_due_date: toDateOnly(columnRow?.custom_due_date || columnRow?.homework_custom_due_date),
    class_date: toDateOnly(columnRow?.class_date || columnRow?.homework_class_date),
  };
  if (!fallback.homework_id) return fallback;

  const isTeacherHomework = Number(
    columnRow?.source_homework_is_teacher
    || columnRow?.homework_is_teacher_homework
    || 0
  ) === 1;
  if (!isTeacherHomework) return fallback;

  const groupNumber = Number(studentGroupNumber || 0);
  if (!Number.isInteger(groupNumber) || groupNumber < 1) return fallback;

  const batchKey = buildHomeworkBatchKey({
    created_by_id: columnRow?.homework_created_by_id,
    created_by: columnRow?.homework_created_by,
    created_at: columnRow?.homework_created_at,
    subject_id: columnRow?.subject_id,
    course_id: columnRow?.course_id,
    semester_id: columnRow?.semester_id,
    is_custom_deadline: columnRow?.homework_is_custom_deadline,
    is_credit: columnRow?.homework_is_credit,
    is_control: columnRow?.homework_is_control,
    description: columnRow?.homework_description,
    custom_due_date: columnRow?.custom_due_date || columnRow?.homework_custom_due_date,
    class_date: columnRow?.class_date || columnRow?.homework_class_date,
    day_of_week: columnRow?.homework_day_of_week,
    class_number: columnRow?.homework_class_number,
    meeting_url: columnRow?.homework_meeting_url,
    link_url: columnRow?.homework_link_url,
    file_path: columnRow?.homework_file_path,
  });
  if (!batchKey) return fallback;

  const params = [columnRow.subject_id, columnRow.course_id, groupNumber];
  let sql = `
    SELECT
      h.id,
      h.group_number,
      h.subject_id,
      h.course_id,
      h.semester_id,
      h.created_by_id,
      h.created_by,
      h.created_at,
      h.description,
      h.custom_due_date,
      h.class_date,
      h.day_of_week,
      h.class_number,
      h.meeting_url,
      h.link_url,
      h.file_path,
      h.is_custom_deadline,
      h.is_control,
      h.is_credit,
      h.is_teacher_homework
    FROM homework h
    WHERE h.subject_id = ?
      AND h.course_id = ?
      AND h.group_number = ?
      AND COALESCE(h.status, 'published') = 'published'
      AND COALESCE(h.is_teacher_homework, 0) = 1
  `;
  if (columnRow.semester_id) {
    sql += ' AND (h.semester_id = ? OR h.semester_id IS NULL)';
    params.push(columnRow.semester_id);
  } else {
    sql += ' AND h.semester_id IS NULL';
  }
  const rows = await db.all(sql, params);
  const matched = (rows || []).find((row) => buildHomeworkBatchKey(row) === batchKey);
  if (!matched) return fallback;

  return {
    homework_id: Number(matched.id),
    custom_due_date: toDateOnly(matched.custom_due_date),
    class_date: toDateOnly(matched.class_date),
  };
}

async function buildJournalMatrix({
  subjectId,
  courseId,
  semesterId,
  actorUserId,
  groupFilterSet = null,
  studentFilterIds = [],
}) {
  const gradingSettings = await ensureSubjectGradingSettings(subjectId, courseId, semesterId, actorUserId);
  if (Number(gradingSettings?.is_closed || 0) !== 1) {
    try {
      await syncJournalColumnsFromHomework(subjectId, courseId, semesterId, gradingSettings, actorUserId);
    } catch (err) {
      if (!isDbSchemaCompatibilityError(err)) {
        throw err;
      }
    }
  }

  let columns = await getJournalColumns(subjectId, courseId, semesterId);
  const students = await getJournalStudents(subjectId, courseId, groupFilterSet, studentFilterIds);
  if (!students.length) {
    return {
      gradingSettings,
      columns,
      rows: [],
    };
  }

  let teacherBatchLookup = {
    byHomeworkId: new Map(),
    byBatchGroup: new Map(),
  };
  const hasTeacherHomeworkColumns = columns.some((column) => (
    Number(column.source_homework_id || 0) > 0
    && column.source_homework_is_teacher
    && column.source_homework_batch_key
  ));
  if (hasTeacherHomeworkColumns) {
    const teacherHomeworkParams = [subjectId, courseId];
    let teacherHomeworkSql = `
      SELECT
        h.id,
        h.group_number,
        h.subject_id,
        h.course_id,
        h.semester_id,
        h.created_by_id,
        h.created_by,
        h.created_at,
        h.description,
        h.custom_due_date,
        h.class_date,
        h.day_of_week,
        h.class_number,
        h.meeting_url,
        h.link_url,
        h.file_path,
        h.is_custom_deadline,
        h.is_control,
        h.is_credit,
        h.is_teacher_homework
      FROM homework h
      WHERE h.subject_id = ?
        AND h.course_id = ?
        AND COALESCE(h.status, 'published') = 'published'
        AND COALESCE(h.is_teacher_homework, 0) = 1
    `;
    if (semesterId) {
      teacherHomeworkSql += ' AND (h.semester_id = ? OR h.semester_id IS NULL)';
      teacherHomeworkParams.push(semesterId);
    } else {
      teacherHomeworkSql += ' AND h.semester_id IS NULL';
    }
    try {
      const teacherHomeworkRows = await db.all(teacherHomeworkSql, teacherHomeworkParams);
      teacherBatchLookup = buildTeacherHomeworkBatchLookup(teacherHomeworkRows || []);
    } catch (err) {
      if (!isDbSchemaCompatibilityError(err)) {
        throw err;
      }
      teacherBatchLookup = {
        byHomeworkId: new Map(),
        byBatchGroup: new Map(),
      };
    }
  }

  if (groupFilterSet && groupFilterSet.size) {
    const allowedGroups = Array.from(groupFilterSet)
      .map((value) => Number(value))
      .filter((value) => Number.isInteger(value) && value > 0);
    columns = columns.filter((column) => {
      if (!column.source_homework_id) return true;
      const homeworkGroup = Number(column.homework_group_number || 0);
      if (!column.source_homework_is_teacher) {
        if (!homeworkGroup) return true;
        return allowedGroups.includes(homeworkGroup);
      }
      if (homeworkGroup && allowedGroups.includes(homeworkGroup)) return true;
      if (!column.source_homework_batch_key) return false;
      return allowedGroups.some((groupNumber) => teacherBatchLookup.byBatchGroup.has(`${column.source_homework_batch_key}|${groupNumber}`));
    });
  }

  const columnIds = columns.map((column) => column.id);
  const studentIds = students.map((student) => student.id);
  let gradesByKey = new Map();
  if (columnIds.length && studentIds.length) {
    let rows = [];
    try {
      rows = await db.all(
        `
          SELECT
            jg.column_id,
            jg.student_id,
            jg.score,
            jg.teacher_comment,
            jg.submission_status,
            jg.graded_at,
            jg.graded_by,
            jgm.status AS moderation_status,
            jgm.moderated_score,
            jgm.reviewed_at AS moderation_reviewed_at,
            jgm.reviewed_by AS moderation_reviewed_by
          FROM journal_grades jg
          LEFT JOIN journal_grade_moderations jgm
            ON jgm.column_id = jg.column_id
           AND jgm.student_id = jg.student_id
          WHERE jg.column_id = ANY(?::int[])
            AND jg.student_id = ANY(?::int[])
            AND jg.deleted_at IS NULL
        `,
        [columnIds, studentIds]
      );
    } catch (err) {
      if (!isDbSchemaCompatibilityError(err)) {
        throw err;
      }
      try {
        rows = await db.all(
          `
            SELECT
              jg.column_id,
              jg.student_id,
              jg.score,
              jg.teacher_comment,
              jg.submission_status,
              jg.graded_at,
              jg.graded_by
            FROM journal_grades jg
            WHERE jg.column_id = ANY(?::int[])
              AND jg.student_id = ANY(?::int[])
          `,
          [columnIds, studentIds]
        );
      } catch (legacyErr) {
        if (!isDbSchemaCompatibilityError(legacyErr)) {
          throw legacyErr;
        }
        rows = [];
      }
    }
    gradesByKey = new Map(
      (rows || []).map((row) => [
        `${Number(row.column_id)}|${Number(row.student_id)}`,
        {
          score: resolveEffectiveGradeScore(
            { score: row.score },
            { status: row.moderation_status, moderated_score: row.moderated_score }
          ),
          original_score: Number(row.score),
          teacher_comment: row.teacher_comment || '',
          submission_status: String(row.submission_status || ''),
          graded_at: row.graded_at || null,
          graded_by: Number.isFinite(Number(row.graded_by)) ? Number(row.graded_by) : null,
          moderation_status: normalizeJournalModerationStatus(row.moderation_status),
          moderation_score: Number.isFinite(Number(row.moderated_score)) ? Number(row.moderated_score) : null,
          moderation_reviewed_at: row.moderation_reviewed_at || null,
          moderation_reviewed_by: Number.isFinite(Number(row.moderation_reviewed_by))
            ? Number(row.moderation_reviewed_by)
            : null,
        },
      ])
    );
  }

  const resolveHomeworkContextForCell = (column, studentGroupNumber) => {
    const fallbackHomeworkId = Number(column?.source_homework_id || 0);
    if (!Number.isFinite(fallbackHomeworkId) || fallbackHomeworkId < 1) {
      return { homework_id: null, due_row: column };
    }
    if (!column.source_homework_is_teacher || !column.source_homework_batch_key) {
      return {
        homework_id: fallbackHomeworkId,
        due_row: teacherBatchLookup.byHomeworkId.get(fallbackHomeworkId) || column,
      };
    }
    const groupNumber = Number(studentGroupNumber || 0);
    if (Number.isInteger(groupNumber) && groupNumber > 0) {
      const mapped = teacherBatchLookup.byBatchGroup.get(`${column.source_homework_batch_key}|${groupNumber}`);
      if (mapped && Number(mapped.id) > 0) {
        return { homework_id: Number(mapped.id), due_row: mapped };
      }
    }
    return {
      homework_id: fallbackHomeworkId,
      due_row: teacherBatchLookup.byHomeworkId.get(fallbackHomeworkId) || column,
    };
  };

  const homeworkIdSet = new Set();
  columns.forEach((column) => {
    const fallbackHomeworkId = Number(column.source_homework_id || 0);
    if (!Number.isFinite(fallbackHomeworkId) || fallbackHomeworkId < 1) return;
    if (!column.source_homework_is_teacher || !column.source_homework_batch_key) {
      homeworkIdSet.add(fallbackHomeworkId);
      return;
    }
    students.forEach((student) => {
      const context = resolveHomeworkContextForCell(column, student.group_number);
      if (Number(context.homework_id) > 0) {
        homeworkIdSet.add(Number(context.homework_id));
      }
    });
  });
  const homeworkIds = Array.from(homeworkIdSet);

  let submissionsByKey = new Map();
  if (homeworkIds.length && studentIds.length) {
    let rows = [];
    try {
      rows = await db.all(
        `
          SELECT homework_id, student_id, submission_text, link_url, file_path, file_name, submitted_at, updated_at
          FROM homework_submissions
          WHERE homework_id = ANY(?::int[])
            AND student_id = ANY(?::int[])
        `,
        [homeworkIds, studentIds]
      );
    } catch (err) {
      if (!isDbSchemaCompatibilityError(err)) {
        throw err;
      }
      rows = [];
    }
    submissionsByKey = new Map(
      (rows || []).map((row) => [
        `${Number(row.homework_id)}|${Number(row.student_id)}`,
        {
          submission_text: row.submission_text || '',
          link_url: row.link_url || '',
          file_path: row.file_path || '',
          file_name: normalizeUploadedOriginalName(row.file_name),
          submitted_at: row.submitted_at || null,
          updated_at: row.updated_at || null,
        },
      ])
    );
  }

  const scoringColumnIndexesByType = new Map();
  columns.forEach((column, index) => {
    const type = normalizeColumnType(column.column_type);
    if (!JOURNAL_SCORING_TYPES.includes(type)) return;
    if (!column.include_in_final) return;
    if (!getGradingTypeEnabled(gradingSettings, type)) return;
    if (!scoringColumnIndexesByType.has(type)) {
      scoringColumnIndexesByType.set(type, []);
    }
    scoringColumnIndexesByType.get(type).push(index);
  });

  const rows = students.map((student) => {
    const cells = columns.map((column) => {
      const grade = gradesByKey.get(`${column.id}|${student.id}`) || null;
      const homeworkContext = resolveHomeworkContextForCell(column, student.group_number);
      const submission = homeworkContext.homework_id
        ? (submissionsByKey.get(`${homeworkContext.homework_id}|${student.id}`) || null)
        : null;
      let status = 'missing';
      if (homeworkContext.homework_id) {
        status = resolveHomeworkSubmissionStatus(
          {
            custom_due_date: homeworkContext.due_row?.custom_due_date || column.custom_due_date,
            class_date: homeworkContext.due_row?.class_date || column.class_date,
          },
          submission
        );
      } else if (grade && Number.isFinite(grade.score)) {
        status = 'manual';
      }
      if (grade && grade.submission_status) {
        status = grade.submission_status;
      }
      return {
        column_id: column.id,
        student_id: student.id,
        score: grade && Number.isFinite(grade.score) ? Number(grade.score) : null,
        teacher_comment: grade ? grade.teacher_comment : '',
        graded_at: grade ? grade.graded_at : null,
        status,
        submission,
      };
    });
    let rawEarned = 0;
    let rawMax = 0;
    let weightedEarned = 0;
    const typeBreakdown = [];
    JOURNAL_SCORING_TYPES.forEach((type) => {
      const indexes = scoringColumnIndexesByType.get(type) || [];
      if (!indexes.length) return;
      const typeWeight = getGradingTypeWeightPoints(gradingSettings, type);
      const typeRawMax = indexes.reduce((sum, idx) => sum + parsePositiveDecimal(columns[idx]?.max_points, 0), 0);
      const typeRawEarned = indexes.reduce((sum, idx) => {
        const score = Number(cells[idx]?.score);
        return sum + (Number.isFinite(score) ? score : 0);
      }, 0);
      rawEarned += typeRawEarned;
      rawMax += typeRawMax;
      const ratio = typeRawMax > 0 ? Math.max(0, Math.min(1, typeRawEarned / typeRawMax)) : 0;
      const contribution = typeWeight > 0 ? ratio * typeWeight : 0;
      if (typeRawMax > 0 && typeWeight > 0) {
        weightedEarned += contribution;
      }
      typeBreakdown.push({
        type,
        label: JOURNAL_SCORING_TYPE_META[type]?.label || type,
        columns_count: indexes.length,
        weight_points: Math.round(typeWeight * 100) / 100,
        raw_earned: Math.round(typeRawEarned * 100) / 100,
        raw_max: Math.round(typeRawMax * 100) / 100,
        ratio: Math.round(ratio * 10000) / 10000,
        contribution: Math.round(contribution * 100) / 100,
      });
    });
    const finalScore = Math.min(100, weightedEarned);
    return {
      student,
      cells,
      raw_earned: Math.round(rawEarned * 100) / 100,
      raw_max: Math.round(rawMax * 100) / 100,
      weighted_earned: Math.round(weightedEarned * 100) / 100,
      final_score: Math.round(finalScore * 100) / 100,
      type_breakdown: typeBreakdown,
    };
  });

  return {
    gradingSettings,
    columns,
    rows,
  };
}

app.get('/journal', requireLogin, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'journal.init');
  }

  try {
    const journalScope = await getJournalAccessScope(req);
    if (!journalScope.canUseJournal) {
      return res.status(403).send('Forbidden (journal)');
    }
    const teacherJournalMode = canUseTeacherJournalMode(req, journalScope);
    const subjectOptions = await getJournalSubjectOptionsForUser(req, journalScope, teacherJournalMode);
    const requestedSubjectId = Number(req.query.subject_id);
    const selectedSubject = Number.isFinite(requestedSubjectId) && requestedSubjectId > 0
      ? (subjectOptions.find((item) => Number(item.subject_id) === requestedSubjectId) || null)
      : (subjectOptions[0] || null);
    const undoColumnId = Number(req.query.undo_column_id);
    const undoStudentId = Number(req.query.undo_student_id);
    const undoUntilMs = Number(req.query.undo_until);
    const nowMs = Date.now();
    const undoGrade = (
      Number.isFinite(undoColumnId) && undoColumnId > 0
      && Number.isFinite(undoStudentId) && undoStudentId > 0
      && Number.isFinite(undoUntilMs) && undoUntilMs > nowMs
    )
      ? {
          column_id: undoColumnId,
          student_id: undoStudentId,
          until: undoUntilMs,
          seconds_left: Math.max(1, Math.floor((undoUntilMs - nowMs) / 1000)),
        }
      : null;

    if (!selectedSubject) {
      await renderViewToResponse(
        res,
        'journal',
        buildJournalEmptyStateViewModel({
          req,
          subjects: [],
          teacherJournalMode,
          canManageAllSubjects: Boolean(journalScope.fullAccess),
        })
      );
      return;
    }

    const selectedCourseId = Number(selectedSubject.course_id || req.session.user.course_id || 1);
    const selectedSemester = await getActiveSemester(selectedCourseId);
    const subjectClosure = await getJournalSubjectClosureState(Number(selectedSubject.subject_id));
    const canEditJournal = teacherJournalMode && !subjectClosure.is_closed;
    const canCloseSubject = Boolean(
      teacherJournalMode
      && !subjectClosure.is_closed
      && (journalScope.fullAccess || selectedSubject.has_all_groups)
    );

    let groupFilterSet = null;
    let studentFilterIds = [];

    if (!teacherJournalMode) {
      groupFilterSet = new Set((selectedSubject.group_numbers || []).map((value) => Number(value)).filter((value) => Number.isInteger(value) && value > 0));
      studentFilterIds = [Number(req.session.user.id)];
    } else if (!journalScope.fullAccess && !selectedSubject.has_all_groups) {
      groupFilterSet = new Set((selectedSubject.group_numbers || []).map((value) => Number(value)).filter((value) => Number.isInteger(value) && value > 0));
    }

    const matrix = await buildJournalMatrix({
      subjectId: Number(selectedSubject.subject_id),
      courseId: selectedCourseId,
      semesterId: selectedSemester ? Number(selectedSemester.id) : null,
      actorUserId: Number(req.session.user.id),
      groupFilterSet,
      studentFilterIds,
    });
    const attendanceContext = await buildJournalAttendanceContext({
      subjectId: Number(selectedSubject.subject_id),
      courseId: selectedCourseId,
      semesterId: selectedSemester ? Number(selectedSemester.id) : null,
      semester: selectedSemester || null,
      students: (matrix.rows || []).map((row) => row.student),
      requestedDate: req.query.attendance_date,
      requestedClassNumber: req.query.attendance_class_number,
      studentViewUserId: teacherJournalMode ? null : Number(req.session.user.id),
      allowedGroupNumbers: Array.isArray(selectedSubject.group_numbers) ? selectedSubject.group_numbers : [],
      hasAllGroups: Boolean(selectedSubject.has_all_groups),
    });

    await renderViewToResponse(res, 'journal', {
      username: req.session.user.username,
      role: req.session.role,
      subjects: subjectOptions,
      selectedSubject,
      columns: matrix.columns,
      journalRows: matrix.rows,
      gradingSettings: matrix.gradingSettings,
      attendanceContext,
      canEditJournal,
      canEditAttendance: teacherJournalMode,
      teacherJournalMode,
      attendanceQuickAutoOpen: teacherJournalMode && String(req.query.attendance_quick || '') === '1',
      canManageAllSubjects: Boolean(journalScope.fullAccess),
      subjectClosure,
      canCloseSubject,
      selectedSemester,
      undoGrade: canEditJournal ? undoGrade : null,
      gradingTypeMeta: JOURNAL_SCORING_TYPE_META,
    });
    return;
  } catch (err) {
    if (err && err.isViewRenderError) {
      console.error('Journal render failed (journal.page.render)', {
        view: err.viewName || 'journal',
        message: normalizeRuntimeErrorMessage(err && err.message ? err.message : err),
      });
      return sendJournalPlainFallback(res);
    }
    if (isDbSchemaCompatibilityError(err)) {
      console.error('Journal compatibility fallback (journal.page.compat)', {
        code: err && err.code ? String(err.code) : '',
        message: normalizeRuntimeErrorMessage(err && err.message ? err.message : err),
      });
      try {
        if (res.locals && res.locals.messages && !res.locals.messages.error) {
          res.locals.messages.error = 'Журнал тимчасово працює в режимі сумісності (оновіть структуру БД).';
        }
        await renderViewToResponse(
          res,
          'journal',
          buildJournalEmptyStateViewModel({
            req,
            subjects: [],
            teacherJournalMode: false,
            canManageAllSubjects: false,
            compatibilityMessage: 'Журнал тимчасово працює в режимі сумісності (оновіть структуру БД).',
          })
        );
        return;
      } catch (renderErr) {
        console.error('Journal compatibility render fallback failed', renderErr);
        return sendJournalPlainFallback(res);
      }
    }
    return handleDbError(res, err, 'journal.page');
  }
});

app.post('/journal/attendance/save', requireLogin, writeLimiter, async (req, res) => {
  const subjectId = Number(req.body.subject_id);
  const attendanceDate = String(req.body.attendance_date || '').trim();
  const attendanceClassNumber = Number(req.body.attendance_class_number);
  const rowsRaw = String(req.body.rows_json || '[]').trim() || '[]';

  if (!Number.isFinite(subjectId) || subjectId < 1) {
    return res.redirect('/journal?err=Invalid%20subject');
  }
  if (!isValidDateString(attendanceDate)) {
    return res.redirect(`/journal?subject_id=${subjectId}&err=Invalid%20attendance%20date`);
  }
  if (!Number.isInteger(attendanceClassNumber) || !bellSchedule[attendanceClassNumber]) {
    return res.redirect(`/journal?subject_id=${subjectId}&err=Invalid%20class%20number`);
  }

  let parsedRows = [];
  try {
    const parsed = JSON.parse(rowsRaw);
    parsedRows = Array.isArray(parsed) ? parsed : [];
  } catch (err) {
    return res.redirect(`/journal?subject_id=${subjectId}&err=Invalid%20attendance%20payload`);
  }
  if (!parsedRows.length) {
    return res.redirect(`/journal?subject_id=${subjectId}&err=No%20attendance%20rows`);
  }
  if (parsedRows.length > 500) {
    return res.redirect(`/journal?subject_id=${subjectId}&err=Attendance%20payload%20is%20too%20large`);
  }

  try {
    await ensureDbReady();
    const journalScope = await getJournalAccessScope(req);
    const teacherJournalMode = canUseTeacherJournalMode(req, journalScope);
    if (!journalScope.canUseJournal || !teacherJournalMode) {
      return res.status(403).send('Forbidden (journal)');
    }

    const subjectOptions = await getJournalSubjectOptionsForUser(req, journalScope, teacherJournalMode);
    const selectedSubject = (subjectOptions || []).find((subject) => Number(subject.subject_id) === subjectId);
    if (!selectedSubject) {
      return res.status(403).send('Forbidden (journal)');
    }

    const selectedCourseId = Number(selectedSubject.course_id || req.session.user.course_id || 1);
    const selectedSemester = await getActiveSemester(selectedCourseId);
    const semesterId = selectedSemester ? Number(selectedSemester.id) : null;
    let groupFilterSet = null;
    if (!journalScope.fullAccess && !selectedSubject.has_all_groups) {
      groupFilterSet = new Set(
        (selectedSubject.group_numbers || [])
          .map((value) => Number(value))
          .filter((value) => Number.isInteger(value) && value > 0)
      );
    }

    const allowedStudents = await getJournalStudents(subjectId, selectedCourseId, groupFilterSet);
    const allowedStudentMap = new Map(
      (allowedStudents || []).map((student) => [Number(student.id), student])
    );

    const normalizedMap = new Map();
    parsedRows.forEach((row) => {
      const studentId = Number(row?.student_id);
      if (!Number.isFinite(studentId) || studentId < 1) return;
      const normalizedStatus = normalizeAttendanceStatus(row?.status);
      const normalizedReason = normalizeAttendanceReason(row?.reason);
      normalizedMap.set(studentId, {
        student_id: studentId,
        status: normalizedStatus,
        reason: normalizedReason,
      });
    });
    const normalizedEntries = Array.from(normalizedMap.values());
    if (!normalizedEntries.length) {
      return res.redirect(
        `/journal?subject_id=${subjectId}&attendance_date=${encodeURIComponent(attendanceDate)}&attendance_class_number=${attendanceClassNumber}&err=No%20attendance%20rows`
      );
    }

    for (const entry of normalizedEntries) {
      if (!allowedStudentMap.has(Number(entry.student_id))) {
        return res.status(403).send('Forbidden (journal)');
      }
    }

    const semesterMatchClause = semesterId ? 'AND ar.semester_id = ?' : 'AND ar.semester_id IS NULL';
    const semesterMatchParams = semesterId ? [semesterId] : [];
    let updatedCount = 0;
    let deletedCount = 0;

    await withTransaction(async (client) => {
      const query = (sql, params = []) => client.query(convertPlaceholders(sql), params);
      for (const entry of normalizedEntries) {
        const studentId = Number(entry.student_id);
        const studentGroup = Number(allowedStudentMap.get(studentId)?.group_number || 0);
        if (!entry.status) {
          const deleteResult = await query(
            `
              DELETE FROM attendance_records ar
              WHERE ar.subject_id = ?
                AND ar.course_id = ?
                ${semesterMatchClause}
                AND ar.class_date = ?
                AND ar.class_number = ?
                AND ar.student_id = ?
            `,
            [subjectId, selectedCourseId, ...semesterMatchParams, attendanceDate, attendanceClassNumber, studentId]
          );
          deletedCount += Number(deleteResult.rowCount || 0);
          continue;
        }

        const existing = await query(
          `
            SELECT ar.id
            FROM attendance_records ar
            WHERE ar.subject_id = ?
              AND ar.course_id = ?
              ${semesterMatchClause}
              AND ar.class_date = ?
              AND ar.class_number = ?
              AND ar.student_id = ?
            ORDER BY ar.id ASC
            LIMIT 1
          `,
          [subjectId, selectedCourseId, ...semesterMatchParams, attendanceDate, attendanceClassNumber, studentId]
        );
        const existingId = existing.rows && existing.rows[0] ? Number(existing.rows[0].id) : null;
        if (Number.isFinite(existingId) && existingId > 0) {
          await query(
            `
              UPDATE attendance_records
              SET status = ?,
                  reason = ?,
                  group_number = ?,
                  marked_by = ?,
                  marked_at = NOW(),
                  updated_at = NOW()
              WHERE id = ?
            `,
            [
              entry.status,
              entry.reason || null,
              Number.isInteger(studentGroup) && studentGroup > 0 ? studentGroup : null,
              Number(req.session.user.id),
              existingId,
            ]
          );
        } else {
          await query(
            `
              INSERT INTO attendance_records
              (
                subject_id, course_id, semester_id, student_id, group_number,
                class_date, class_number, status, reason, marked_by, marked_at, updated_at
              )
              VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
            `,
            [
              subjectId,
              selectedCourseId,
              semesterId,
              studentId,
              Number.isInteger(studentGroup) && studentGroup > 0 ? studentGroup : null,
              attendanceDate,
              attendanceClassNumber,
              entry.status,
              entry.reason || null,
              Number(req.session.user.id),
            ]
          );
        }
        updatedCount += 1;
      }
    });

    logActivity(
      db,
      req,
      'journal_attendance_save',
      'attendance_record',
      null,
      {
        subject_id: subjectId,
        class_date: attendanceDate,
        class_number: attendanceClassNumber,
        updated_count: updatedCount,
        deleted_count: deletedCount,
      },
      selectedCourseId,
      semesterId
    );
    return res.redirect(
      `/journal?subject_id=${subjectId}&attendance_date=${encodeURIComponent(attendanceDate)}&attendance_class_number=${attendanceClassNumber}&ok=Відвідуваність%20збережено`
    );
  } catch (err) {
    return res.redirect(`/journal?subject_id=${subjectId}&err=Database%20error`);
  }
});

app.post('/journal/subject/close', requireLogin, writeLimiter, async (req, res) => {
  const subjectId = Number(req.body.subject_id);
  if (!Number.isFinite(subjectId) || subjectId < 1) {
    return res.redirect('/journal?err=Invalid%20subject');
  }

  try {
    await ensureDbReady();
    const journalScope = await getJournalAccessScope(req);
    const teacherJournalMode = canUseTeacherJournalMode(req, journalScope);
    if (!journalScope.canUseJournal || !teacherJournalMode) {
      return res.status(403).send('Forbidden (journal)');
    }

    const subjectOptions = await getJournalSubjectOptionsForUser(req, journalScope, teacherJournalMode);
    const selectedSubject = (subjectOptions || []).find((subject) => Number(subject.subject_id) === subjectId);
    if (!selectedSubject) {
      return res.status(403).send('Forbidden (journal)');
    }
    if (!journalScope.fullAccess && !selectedSubject.has_all_groups) {
      return res.redirect(
        `/journal?subject_id=${subjectId}&err=${encodeURIComponent('Для закриття предмета потрібен доступ до всіх груп')}`
      );
    }

    const selectedCourseId = Number(selectedSubject.course_id || req.session.user.course_id || 1);
    const selectedSemester = await getActiveSemester(selectedCourseId);
    const semesterId = selectedSemester ? Number(selectedSemester.id) : null;
    await ensureSubjectGradingSettings(subjectId, selectedCourseId, semesterId, Number(req.session.user.id));
    const subjectClosure = await getJournalSubjectClosureState(subjectId);
    if (subjectClosure.is_closed) {
      return res.redirect(`/journal?subject_id=${subjectId}&ok=${encodeURIComponent('Предмет уже закрито')}`);
    }

    const matrix = await buildJournalMatrix({
      subjectId,
      courseId: selectedCourseId,
      semesterId,
      actorUserId: Number(req.session.user.id),
      groupFilterSet: null,
      studentFilterIds: [],
    });
    const exportPayload = buildJournalClosureCsv({
      subjectName: selectedSubject.subject_name,
      courseName: selectedSubject.course_name,
      semesterTitle: selectedSemester ? String(selectedSemester.title || '') : '',
      closedAt: new Date(),
      columns: matrix.columns,
      rows: matrix.rows,
    });
    const exportFile = writeJournalClosureExportFile({
      subjectId,
      courseId: selectedCourseId,
      semesterId,
      csvContent: exportPayload.csv,
    });

    const actorUserId = Number(req.session.user.id);
    let closeCompatibilityMode = false;
    await withTransaction(async (client) => {
      const query = (sql, params = []) => client.query(convertPlaceholders(sql), params);
      let savepointCounter = 0;
      const runCompatibilityQuery = async (sql, params = []) => {
        savepointCounter += 1;
        const savepointName = `journal_close_sp_${savepointCounter}`;
        await client.query(`SAVEPOINT ${savepointName}`);
        try {
          await query(sql, params);
          await client.query(`RELEASE SAVEPOINT ${savepointName}`);
          return true;
        } catch (err) {
          try {
            await client.query(`ROLLBACK TO SAVEPOINT ${savepointName}`);
          } catch (_rollbackErr) {
            // Ignore savepoint rollback failures and rely on outer transaction rollback if needed.
          }
          try {
            await client.query(`RELEASE SAVEPOINT ${savepointName}`);
          } catch (_releaseErr) {
            // Ignore release failures after rollback.
          }
          if (!isDbSchemaCompatibilityError(err)) {
            throw err;
          }
          closeCompatibilityMode = true;
          return false;
        }
      };

      const buildSubjectCloseUpsertSql = (closedLiteral) => (
        `
          INSERT INTO subject_grading_settings
          (
            subject_id, course_id, semester_id,
            homework_enabled, seminar_enabled, exam_enabled, credit_enabled, custom_enabled,
            homework_max_points, seminar_max_points, exam_max_points, credit_max_points, custom_max_points,
            homework_weight_points, seminar_weight_points, exam_weight_points, credit_weight_points, custom_weight_points,
            final_max_points,
            is_closed, closed_by, closed_at,
            created_by, created_at, updated_by, updated_at
          )
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 100, ${closedLiteral}, ?, NOW(), ?, NOW(), ?, NOW())
          ON CONFLICT (subject_id)
          DO UPDATE SET
            course_id = EXCLUDED.course_id,
            semester_id = EXCLUDED.semester_id,
            is_closed = ${closedLiteral},
            closed_by = EXCLUDED.closed_by,
            closed_at = EXCLUDED.closed_at,
            updated_by = EXCLUDED.updated_by,
            updated_at = EXCLUDED.updated_at
        `
      );

      const closeUpsertParams = [
        subjectId,
        selectedCourseId,
        semesterId,
        DEFAULT_SUBJECT_GRADING_SETTINGS.homework_enabled,
        DEFAULT_SUBJECT_GRADING_SETTINGS.seminar_enabled,
        DEFAULT_SUBJECT_GRADING_SETTINGS.exam_enabled,
        DEFAULT_SUBJECT_GRADING_SETTINGS.credit_enabled,
        DEFAULT_SUBJECT_GRADING_SETTINGS.custom_enabled,
        DEFAULT_SUBJECT_GRADING_SETTINGS.homework_max_points,
        DEFAULT_SUBJECT_GRADING_SETTINGS.seminar_max_points,
        DEFAULT_SUBJECT_GRADING_SETTINGS.exam_max_points,
        DEFAULT_SUBJECT_GRADING_SETTINGS.credit_max_points,
        DEFAULT_SUBJECT_GRADING_SETTINGS.custom_max_points,
        DEFAULT_SUBJECT_GRADING_SETTINGS.homework_weight_points,
        DEFAULT_SUBJECT_GRADING_SETTINGS.seminar_weight_points,
        DEFAULT_SUBJECT_GRADING_SETTINGS.exam_weight_points,
        DEFAULT_SUBJECT_GRADING_SETTINGS.credit_weight_points,
        DEFAULT_SUBJECT_GRADING_SETTINGS.custom_weight_points,
        actorUserId,
        actorUserId,
        actorUserId,
      ];

      let closeUpsertApplied = await runCompatibilityQuery(
        buildSubjectCloseUpsertSql('TRUE'),
        closeUpsertParams
      );
      if (!closeUpsertApplied) {
        closeUpsertApplied = await runCompatibilityQuery(
          buildSubjectCloseUpsertSql('1'),
          closeUpsertParams
        );
      }
      if (!closeUpsertApplied) {
        closeCompatibilityMode = true;
      }

      const buildLockWhereClause = ({ withSemester = true, withArchived = true } = {}) => {
        const conditions = [
          'jc.subject_id = ?',
          'jc.course_id = ?',
        ];
        const params = [subjectId, selectedCourseId];
        if (withSemester) {
          const semesterFilter = buildExactSemesterCondition('jc', semesterId);
          const semesterClause = String(semesterFilter?.clause || '')
            .replace(/^\s*AND\s+/i, '')
            .trim();
          if (semesterClause) {
            conditions.push(semesterClause);
            params.push(...(Array.isArray(semesterFilter?.params) ? semesterFilter.params : []));
          }
        }
        if (withArchived) {
          conditions.push('COALESCE(jc.is_archived, 0) = 0');
        }
        return {
          whereSql: conditions.join('\n              AND '),
          whereParams: params,
        };
      };

      const lockVariants = [
        {
          setSql: `
            SET is_locked = 1,
                locked_by = ?,
                locked_at = COALESCE(jc.locked_at, NOW()),
                updated_at = NOW()
          `,
          setParams: [actorUserId],
          withSemester: true,
          withArchived: true,
        },
        {
          setSql: `
            SET is_locked = 1,
                updated_at = NOW()
          `,
          setParams: [],
          withSemester: true,
          withArchived: true,
        },
        {
          setSql: 'SET is_locked = 1',
          setParams: [],
          withSemester: true,
          withArchived: true,
        },
        {
          setSql: 'SET is_locked = 1',
          setParams: [],
          withSemester: false,
          withArchived: true,
        },
        {
          setSql: 'SET is_locked = 1',
          setParams: [],
          withSemester: false,
          withArchived: false,
        },
      ];

      let lockApplied = false;
      for (const variant of lockVariants) {
        const where = buildLockWhereClause({
          withSemester: variant.withSemester,
          withArchived: variant.withArchived,
        });
        const ok = await runCompatibilityQuery(
          `
            UPDATE journal_columns jc
            ${variant.setSql}
            WHERE ${where.whereSql}
          `,
          [...variant.setParams, ...where.whereParams]
        );
        if (ok) {
          lockApplied = true;
          break;
        }
      }
      if (!lockApplied) {
        closeCompatibilityMode = true;
      }

      await runCompatibilityQuery(
        `
          INSERT INTO journal_subject_close_events
          (
            subject_id,
            course_id,
            semester_id,
            event_type,
            export_file_name,
            export_file_path,
            export_rows_count,
            export_columns_count,
            created_by,
            created_at,
            details
          )
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), ?::jsonb)
        `,
        [
          subjectId,
          selectedCourseId,
          semesterId,
          JOURNAL_SUBJECT_CLOSE_EVENT_TYPE,
          exportFile.fileName,
          exportFile.filePath,
          exportPayload.exportRowsCount,
          exportPayload.exportColumnsCount,
          actorUserId,
          JSON.stringify({
            subject_name: selectedSubject.subject_name || '',
            course_name: selectedSubject.course_name || '',
            semester_title: selectedSemester ? String(selectedSemester.title || '') : '',
          }),
        ]
      );
    });

    logActivity(
      db,
      req,
      'journal_subject_close',
      'subject_grading_settings',
      subjectId,
      {
        subject_id: subjectId,
        export_file_name: exportFile.fileName,
        export_rows_count: exportPayload.exportRowsCount,
        export_columns_count: exportPayload.exportColumnsCount,
        compatibility_mode: closeCompatibilityMode ? 'fallback' : 'full',
      },
      selectedCourseId,
      semesterId
    );
    res.setHeader('Content-Type', 'text/csv; charset=utf-8');
    res.setHeader('Content-Disposition', `attachment; filename="${exportFile.fileName}"`);
    return res.send(exportPayload.csv);
  } catch (err) {
    return res.redirect(`/journal?subject_id=${subjectId}&err=Database%20error`);
  }
});

app.get('/journal/subject/close-export', requireLogin, readLimiter, async (req, res) => {
  const subjectId = Number(req.query.subject_id);
  if (!Number.isFinite(subjectId) || subjectId < 1) {
    return res.redirect('/journal?err=Invalid%20subject');
  }

  try {
    await ensureDbReady();
    const journalScope = await getJournalAccessScope(req);
    const teacherJournalMode = canUseTeacherJournalMode(req, journalScope);
    if (!journalScope.canUseJournal || !teacherJournalMode) {
      return res.status(403).send('Forbidden (journal)');
    }

    const subjectOptions = await getJournalSubjectOptionsForUser(req, journalScope, teacherJournalMode);
    const selectedSubject = (subjectOptions || []).find((subject) => Number(subject.subject_id) === subjectId);
    if (!selectedSubject) {
      return res.status(403).send('Forbidden (journal)');
    }
    if (!journalScope.fullAccess && !selectedSubject.has_all_groups) {
      return res.status(403).send('Forbidden (journal)');
    }

    const subjectClosure = await getJournalSubjectClosureState(subjectId);
    if (!subjectClosure.is_closed || !subjectClosure.latest_export_path) {
      return res.redirect(
        `/journal?subject_id=${subjectId}&err=${encodeURIComponent('Експорт для закритого предмета не знайдено')}`
      );
    }
    const absolutePath = resolveStoredUploadAbsolutePath(subjectClosure.latest_export_path);
    if (!absolutePath || !fs.existsSync(absolutePath)) {
      return res.redirect(
        `/journal?subject_id=${subjectId}&err=${encodeURIComponent('Файл експорту недоступний')}`
      );
    }

    return res.download(
      absolutePath,
      subjectClosure.latest_export_name || path.basename(absolutePath)
    );
  } catch (err) {
    return res.redirect(`/journal?subject_id=${subjectId}&err=Database%20error`);
  }
});

app.get('/journal/cell.json', requireLogin, readLimiter, async (req, res) => {
  const columnId = Number(req.query.column_id);
  const studentId = Number(req.query.student_id);
  if (!Number.isFinite(columnId) || columnId < 1 || !Number.isFinite(studentId) || studentId < 1) {
    return res.status(400).json({ error: 'Invalid cell' });
  }

  try {
    await ensureDbReady();
    const journalScope = await getJournalAccessScope(req);
    if (!journalScope.canUseJournal) {
      return res.status(403).json({ error: 'Forbidden' });
    }
    const teacherJournalMode = canUseTeacherJournalMode(req, journalScope);
    const column = await db.get(
      `
        SELECT
          jc.*,
          h.group_number AS homework_group_number,
          h.custom_due_date,
          h.class_date,
          h.description AS homework_description,
          h.day_of_week AS homework_day_of_week,
          h.class_number AS homework_class_number,
          h.meeting_url AS homework_meeting_url,
          h.link_url AS homework_link_url,
          h.file_path AS homework_file_path,
          h.is_custom_deadline AS homework_is_custom_deadline,
          h.is_control AS homework_is_control,
          h.is_credit AS homework_is_credit,
          h.is_teacher_homework AS homework_is_teacher_homework,
          h.created_at AS homework_created_at,
          h.created_by AS homework_created_by,
          h.created_by_id AS homework_created_by_id
        FROM journal_columns jc
        LEFT JOIN homework h ON h.id = jc.source_homework_id
        WHERE jc.id = ?
      `,
      [columnId]
    );
    if (!column) {
      return res.status(404).json({ error: 'Column not found' });
    }

    const activeUserFilter = usersHasIsActive ? ' AND u.is_active = 1' : '';
    const studentRow = await db.get(
      `
        SELECT sg.group_number, u.id, u.full_name
        FROM student_groups sg
        JOIN users u ON u.id = sg.student_id
        WHERE sg.subject_id = ? AND sg.student_id = ?${activeUserFilter}
        LIMIT 1
      `,
      [column.subject_id, studentId]
    );
    if (!studentRow) {
      return res.status(404).json({ error: 'Student not found for subject' });
    }

    if (!teacherJournalMode) {
      if (Number(req.session.user.id) !== studentId) {
        return res.status(403).json({ error: 'Forbidden' });
      }
    } else if (!journalScope.fullAccess) {
      const access = await getTeacherJournalSubjectAccess(Number(req.session.user.id), Number(column.subject_id));
      if (!access.hasRows) {
        return res.status(403).json({ error: 'Forbidden' });
      }
      const studentGroup = Number(studentRow.group_number || 0);
      if (!access.allowAll && !access.groups.has(studentGroup)) {
        return res.status(403).json({ error: 'Forbidden' });
      }
    }

    const resolvedHomework = await resolveJournalColumnHomeworkForStudent(column, Number(studentRow.group_number || 0));

    const grade = await db.get(
      `
        SELECT score, teacher_comment, submission_status, graded_at, graded_by
        FROM journal_grades
        WHERE column_id = ? AND student_id = ?
          AND deleted_at IS NULL
        LIMIT 1
      `,
      [columnId, studentId]
    );
    const submission = resolvedHomework.homework_id
      ? await db.get(
          `
            SELECT submission_text, link_url, file_path, file_name, submitted_at, updated_at
            FROM homework_submissions
            WHERE homework_id = ? AND student_id = ?
            LIMIT 1
          `,
          [resolvedHomework.homework_id, studentId]
        )
      : null;
    const submissionStatus = resolvedHomework.homework_id
      ? resolveHomeworkSubmissionStatus(
          {
            custom_due_date: resolvedHomework.custom_due_date,
            class_date: resolvedHomework.class_date,
          },
          submission
        )
      : 'manual';
    const retakeRows = await db.all(
      `
        SELECT
          jra.id,
          jra.attempt_no,
          jra.kind,
          jra.status,
          jra.due_date,
          jra.approved_at,
          jra.note,
          jra.score,
          jra.teacher_comment,
          jra.graded_at,
          jra.count_in_final,
          ua.full_name AS approved_by_name,
          ug.full_name AS graded_by_name
        FROM journal_retake_attempts jra
        LEFT JOIN users ua ON ua.id = jra.approved_by
        LEFT JOIN users ug ON ug.id = jra.graded_by
        WHERE jra.column_id = ?
          AND jra.student_id = ?
        ORDER BY jra.attempt_no DESC, jra.id DESC
      `,
      [columnId, studentId]
    );
    const subjectClosure = await getJournalSubjectClosureState(Number(column.subject_id));
    const subjectIsClosed = subjectClosure.is_closed;
    const canManageRetakes = teacherJournalMode && !subjectIsClosed && !isJournalColumnLocked(column);
    const appealRows = await db.all(
      `
        SELECT
          jga.id,
          jga.requested_score,
          jga.reason,
          jga.status,
          jga.decision_comment,
          jga.resolved_score,
          jga.created_at,
          jga.updated_at,
          jga.sla_due_at,
          jga.reviewed_at,
          uc.full_name AS created_by_name,
          ur.full_name AS reviewed_by_name
        FROM journal_grade_appeals jga
        LEFT JOIN users uc ON uc.id = jga.created_by
        LEFT JOIN users ur ON ur.id = jga.reviewed_by
        WHERE jga.column_id = ?
          AND jga.student_id = ?
        ORDER BY jga.created_at DESC, jga.id DESC
      `,
      [columnId, studentId]
    );
    const canManageAppeals = teacherJournalMode && !subjectIsClosed && !isJournalColumnLocked(column);
    const moderationRow = await db.get(
      `
        SELECT
          jgm.status,
          jgm.original_score,
          jgm.moderated_score,
          jgm.moderation_comment,
          jgm.created_at,
          jgm.updated_at,
          jgm.reviewed_at,
          jgm.created_by,
          jgm.reviewed_by,
          uc.full_name AS created_by_name,
          ur.full_name AS reviewed_by_name
        FROM journal_grade_moderations jgm
        LEFT JOIN users uc ON uc.id = jgm.created_by
        LEFT JOIN users ur ON ur.id = jgm.reviewed_by
        WHERE jgm.column_id = ?
          AND jgm.student_id = ?
        LIMIT 1
      `,
      [columnId, studentId]
    );
    const columnNeedsModeration = isJournalModerationRequiredColumn(column);
    const canManageModeration = (
      teacherJournalMode
      && !subjectIsClosed
      && !isJournalColumnLocked(column)
      && columnNeedsModeration
      && Boolean(grade && Number.isFinite(Number(grade.score)))
      && Number(req.session.user.id) !== Number(grade?.graded_by || 0)
    );
    const competencyRows = await db.all(
      `
        SELECT
          ce.id,
          ce.column_id,
          ce.competency_key,
          ce.score,
          ce.note,
          ce.source_type,
          ce.created_at,
          ce.created_by,
          u.full_name AS created_by_name
        FROM competency_evaluations ce
        LEFT JOIN users u ON u.id = ce.created_by
        WHERE ce.subject_id = ?
          AND ce.student_id = ?
          AND (
            ce.column_id = ?
            OR ce.column_id IS NULL
          )
        ORDER BY ce.created_at DESC, ce.id DESC
        LIMIT 12
      `,
      [Number(column.subject_id), studentId, columnId]
    );
    const competencyQuickValues = {};
    COMPETENCY_DEFINITIONS.forEach((definition) => {
      competencyQuickValues[definition.key] = 0;
    });
    const checklistResolved = new Set();
    (competencyRows || []).forEach((row) => {
      const sourceType = String(row?.source_type || '').toLowerCase();
      const key = normalizeCompetencyKey(row?.competency_key);
      if (!key || sourceType !== 'checklist' || checklistResolved.has(key)) return;
      const score = Number(row?.score);
      competencyQuickValues[key] = Number.isFinite(score) && score > 0 ? 1 : 0;
      checklistResolved.add(key);
    });
    const canAddCompetencySignal = (
      teacherJournalMode
      && !subjectIsClosed
      && !isJournalColumnLocked(column)
    );
    const canCreateAppeals = (
      !teacherJournalMode
      && !subjectIsClosed
      && Number(req.session.user.id) === studentId
      && Boolean(grade && Number.isFinite(Number(grade.score)))
    );
    const effectiveScore = resolveEffectiveGradeScore(
      grade || null,
      moderationRow || null
    );

    return res.json({
      column: {
        id: Number(column.id),
        title: String(column.title || ''),
        max_points: parsePositiveDecimal(column.max_points, 10),
        column_type: normalizeColumnType(column.column_type),
        is_locked: isJournalColumnLocked(column),
        source_homework_id: column.source_homework_id ? Number(column.source_homework_id) : null,
        homework_description: column.homework_description || null,
        due_date: toDateOnly(column.custom_due_date || column.class_date),
      },
      student: {
        id: Number(studentRow.id),
        full_name: studentRow.full_name,
        group_number: Number(studentRow.group_number || 0),
      },
      grade: grade
        ? {
            score: Number.isFinite(Number(effectiveScore)) ? Number(effectiveScore) : Number(grade.score),
            original_score: Number(grade.score),
            graded_by: Number.isFinite(Number(grade.graded_by)) ? Number(grade.graded_by) : null,
            teacher_comment: grade.teacher_comment || '',
            submission_status: String(grade.submission_status || submissionStatus),
            graded_at: grade.graded_at || null,
          }
        : null,
      submission: submission
        ? {
            submission_text: submission.submission_text || '',
            link_url: submission.link_url || '',
            file_path: submission.file_path || '',
            file_name: normalizeUploadedOriginalName(submission.file_name),
            submitted_at: submission.submitted_at || null,
            updated_at: submission.updated_at || null,
          }
        : null,
      submission_status: submissionStatus,
      subject_is_closed: subjectIsClosed,
      subject_closed_at: subjectClosure.closed_at || null,
      can_edit: teacherJournalMode && !subjectIsClosed && !isJournalColumnLocked(column),
      can_manage_retakes: canManageRetakes,
      can_create_appeals: canCreateAppeals,
      can_manage_appeals: canManageAppeals,
      can_manage_moderation: canManageModeration,
      can_add_competency_signal: canAddCompetencySignal,
      moderation_meta: {
        required: columnNeedsModeration,
        statuses: JOURNAL_MODERATION_STATUSES.map((key) => ({
          key,
          label: JOURNAL_MODERATION_STATUS_META[key]?.label || key,
        })),
        comment_max_length: JOURNAL_MODERATION_COMMENT_MAX_LENGTH,
      },
      moderation: moderationRow
        ? {
            status: normalizeJournalModerationStatus(moderationRow.status),
            status_label: JOURNAL_MODERATION_STATUS_META[normalizeJournalModerationStatus(moderationRow.status)]?.label
              || normalizeJournalModerationStatus(moderationRow.status),
            original_score: Number.isFinite(Number(moderationRow.original_score))
              ? Number(moderationRow.original_score)
              : null,
            moderated_score: Number.isFinite(Number(moderationRow.moderated_score))
              ? Number(moderationRow.moderated_score)
              : null,
            moderation_comment: moderationRow.moderation_comment || '',
            created_at: moderationRow.created_at || null,
            updated_at: moderationRow.updated_at || null,
            reviewed_at: moderationRow.reviewed_at || null,
            created_by_name: moderationRow.created_by_name || '',
            reviewed_by_name: moderationRow.reviewed_by_name || '',
          }
        : null,
      competency_meta: {
        definitions: COMPETENCY_DEFINITIONS.map((item) => ({
          key: item.key,
          label: item.label,
        })),
        score_min: COMPETENCY_SCORE_MIN,
        score_max: COMPETENCY_SCORE_MAX,
        note_max_length: COMPETENCY_NOTE_MAX_LENGTH,
      },
      competency_quick_values: competencyQuickValues,
      competency_signals: (competencyRows || []).map((row) => {
        const key = normalizeCompetencyKey(row.competency_key);
        return {
          id: Number(row.id),
          competency_key: key || String(row.competency_key || ''),
          competency_label: getCompetencyLabelByKey(key || String(row.competency_key || '')),
          score: Number.isFinite(Number(row.score)) ? Number(row.score) : null,
          note: row.note || '',
          source_type: String(row.source_type || 'manual'),
          created_at: row.created_at || null,
          created_by_name: row.created_by_name || '',
        };
      }),
      retake_meta: {
        kinds: JOURNAL_RETAKE_KINDS.map((key) => ({
          key,
          label: JOURNAL_RETAKE_KIND_META[key]?.label || key,
        })),
        statuses: JOURNAL_RETAKE_STATUSES.map((key) => ({
          key,
          label: JOURNAL_RETAKE_STATUS_META[key]?.label || key,
        })),
        note_max_length: JOURNAL_RETAKE_NOTE_MAX_LENGTH,
        comment_max_length: JOURNAL_RETAKE_COMMENT_MAX_LENGTH,
      },
      retake_attempts: (retakeRows || []).map((row) => {
        const parsedScore = Number(row.score);
        return {
          id: Number(row.id),
          attempt_no: Number(row.attempt_no || 1),
          kind: normalizeJournalRetakeKind(row.kind),
          kind_label: JOURNAL_RETAKE_KIND_META[normalizeJournalRetakeKind(row.kind)]?.label || normalizeJournalRetakeKind(row.kind),
          status: normalizeJournalRetakeStatus(row.status),
          status_label: JOURNAL_RETAKE_STATUS_META[normalizeJournalRetakeStatus(row.status)]?.label || normalizeJournalRetakeStatus(row.status),
          due_date: toDateOnly(row.due_date),
          approved_at: row.approved_at || null,
          approved_by_name: row.approved_by_name || '',
          note: row.note || '',
          score: Number.isFinite(parsedScore) ? parsedScore : null,
          teacher_comment: row.teacher_comment || '',
          graded_at: row.graded_at || null,
          graded_by_name: row.graded_by_name || '',
          count_in_final: Number(row.count_in_final || 0) === 1,
        };
      }),
      appeal_meta: {
        statuses: JOURNAL_APPEAL_STATUSES.map((key) => ({
          key,
          label: JOURNAL_APPEAL_STATUS_META[key]?.label || key,
        })),
        reason_max_length: JOURNAL_APPEAL_REASON_MAX_LENGTH,
        comment_max_length: JOURNAL_APPEAL_COMMENT_MAX_LENGTH,
        sla_hours: JOURNAL_APPEAL_SLA_HOURS,
      },
      appeals: (appealRows || []).map((row) => {
        const requestedScore = Number(row.requested_score);
        const resolvedScore = Number(row.resolved_score);
        const status = normalizeJournalAppealStatus(row.status);
        return {
          id: Number(row.id),
          requested_score: Number.isFinite(requestedScore) ? requestedScore : null,
          reason: row.reason || '',
          status,
          status_label: JOURNAL_APPEAL_STATUS_META[status]?.label || status,
          decision_comment: row.decision_comment || '',
          resolved_score: Number.isFinite(resolvedScore) ? resolvedScore : null,
          created_at: row.created_at || null,
          updated_at: row.updated_at || null,
          sla_due_at: row.sla_due_at || null,
          reviewed_at: row.reviewed_at || null,
          created_by_name: row.created_by_name || '',
          reviewed_by_name: row.reviewed_by_name || '',
          is_overdue: (
            ['pending', 'in_review'].includes(status)
            && row.sla_due_at
            && new Date(row.sla_due_at).getTime() < Date.now()
          ),
        };
      }),
    });
  } catch (err) {
    return res.status(500).json({ error: 'Database error' });
  }
});

app.post('/journal/grades/save', requireLogin, writeLimiter, async (req, res) => {
  const columnId = Number(req.body.column_id);
  const studentId = Number(req.body.student_id);
  const scoreRaw = req.body.score;
  const teacherComment = String(req.body.teacher_comment || '').trim();

  if (!Number.isFinite(columnId) || columnId < 1 || !Number.isFinite(studentId) || studentId < 1) {
    return res.redirect('/journal?err=Invalid%20grade%20target');
  }

  try {
    await ensureDbReady();
    const journalScope = await getJournalAccessScope(req);
    const teacherJournalMode = canUseTeacherJournalMode(req, journalScope);
    if (!journalScope.canUseJournal || !teacherJournalMode) {
      return res.status(403).send('Forbidden (journal)');
    }

    const column = await db.get(
      `
        SELECT
          jc.*,
          h.group_number AS homework_group_number,
          h.custom_due_date,
          h.class_date,
          h.description AS homework_description,
          h.day_of_week AS homework_day_of_week,
          h.class_number AS homework_class_number,
          h.meeting_url AS homework_meeting_url,
          h.link_url AS homework_link_url,
          h.file_path AS homework_file_path,
          h.is_custom_deadline AS homework_is_custom_deadline,
          h.is_control AS homework_is_control,
          h.is_credit AS homework_is_credit,
          h.is_teacher_homework AS homework_is_teacher_homework,
          h.created_at AS homework_created_at,
          h.created_by AS homework_created_by,
          h.created_by_id AS homework_created_by_id
        FROM journal_columns jc
        LEFT JOIN homework h ON h.id = jc.source_homework_id
        WHERE jc.id = ?
        LIMIT 1
      `,
      [columnId]
    );
    if (!column) {
      return res.redirect('/journal?err=Column%20not%20found');
    }
    if (isJournalColumnLocked(column)) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&err=Колонка%20заблокована%20для%20редагування`);
    }
    const subjectClosure = await getJournalSubjectClosureState(Number(column.subject_id));
    if (subjectClosure.is_closed) {
      return res.redirect(buildJournalClosedRedirectPath(column.subject_id));
    }
    const maxPoints = parsePositiveDecimal(column.max_points, 10);
    const parsedScore = Number(String(scoreRaw || '').replace(',', '.'));
    const score = Number.isFinite(parsedScore) ? Math.round(parsedScore * 100) / 100 : NaN;
    if (!Number.isFinite(score) || score < 0 || score > maxPoints) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&err=Score%20must%20be%20between%200%20and%20${encodeURIComponent(String(maxPoints))}`);
    }

    const studentRow = await getJournalStudentGroup(column.subject_id, studentId);
    if (!studentRow) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&err=Student%20is%20not%20assigned%20to%20subject`);
    }

    if (!journalScope.fullAccess) {
      const access = await getTeacherJournalSubjectAccess(Number(req.session.user.id), Number(column.subject_id));
      if (!access.hasRows) {
        return res.status(403).send('Forbidden (journal)');
      }
      const studentGroup = Number(studentRow.group_number || 0);
      if (!access.allowAll && !access.groups.has(studentGroup)) {
        return res.status(403).send('Forbidden (journal)');
      }
    }

    let submissionStatus = 'manual';
    if (column.source_homework_id) {
      const resolvedHomework = await resolveJournalColumnHomeworkForStudent(column, Number(studentRow.group_number || 0));
      const submission = await db.get(
        `
          SELECT submitted_at
          FROM homework_submissions
          WHERE homework_id = ? AND student_id = ?
          LIMIT 1
        `,
        [resolvedHomework.homework_id, studentId]
      );
      submissionStatus = resolveHomeworkSubmissionStatus(
        {
          custom_due_date: resolvedHomework.custom_due_date,
          class_date: resolvedHomework.class_date,
        },
        submission
      );
    }

    const beforeGradeRow = await db.get(
      `
        SELECT score, teacher_comment, submission_status, graded_by, graded_at, deleted_at, deleted_by
        FROM journal_grades
        WHERE column_id = ?
          AND student_id = ?
        LIMIT 1
      `,
      [columnId, studentId]
    );
    const beforeGradeState = buildGradeAuditState(beforeGradeRow);

    await db.run(
      `
        INSERT INTO journal_grades
          (column_id, student_id, score, teacher_comment, graded_by, graded_at, submission_status)
        VALUES (?, ?, ?, ?, ?, NOW(), ?)
        ON CONFLICT (column_id, student_id)
        DO UPDATE SET
          score = EXCLUDED.score,
          teacher_comment = EXCLUDED.teacher_comment,
          graded_by = EXCLUDED.graded_by,
          graded_at = EXCLUDED.graded_at,
          submission_status = EXCLUDED.submission_status,
          deleted_at = NULL,
          deleted_by = NULL
      `,
      [
        columnId,
        studentId,
        score,
        teacherComment || null,
        Number(req.session.user.id),
        submissionStatus,
      ]
    );
    const afterGradeRow = await db.get(
      `
        SELECT score, teacher_comment, submission_status, graded_by, graded_at, deleted_at, deleted_by
        FROM journal_grades
        WHERE column_id = ?
          AND student_id = ?
        LIMIT 1
      `,
      [columnId, studentId]
    );
    await appendJournalGradeHashAudit({
      columnId,
      studentId,
      subjectId: Number(column.subject_id || 0),
      courseId: Number(column.course_id || req.session.user.course_id || 1),
      semesterId: column.semester_id ? Number(column.semester_id) : null,
      actorUserId: Number(req.session.user.id),
      actionType: 'grade_save',
      beforeState: beforeGradeState,
      afterState: buildGradeAuditState(afterGradeRow),
    });
    await upsertJournalModerationPending({
      column,
      studentId,
      score,
      actorUserId: Number(req.session.user.id),
    });

    logActivity(
      db,
      req,
      'journal_grade_save',
      'journal_grade',
      columnId,
      {
        student_id: studentId,
        score,
        subject_id: Number(column.subject_id),
      },
      Number(column.course_id || req.session.user.course_id || 1),
      column.semester_id ? Number(column.semester_id) : null
    );
    return res.redirect(`/journal?subject_id=${column.subject_id}&ok=Оцінку%20збережено`);
  } catch (err) {
    return res.redirect('/journal?err=Database%20error');
  }
});

app.post('/journal/grades/bulk-save', requireLogin, writeLimiter, async (req, res) => {
  const subjectIdFromBody = Number(req.body.subject_id);
  const columnId = Number(req.body.column_id);
  const entriesRaw = String(req.body.entries_json || '').trim();
  if (!Number.isFinite(columnId) || columnId < 1 || !entriesRaw) {
    return res.redirect('/journal?err=Invalid%20bulk%20payload');
  }

  let entries = [];
  try {
    const parsed = JSON.parse(entriesRaw);
    entries = Array.isArray(parsed) ? parsed : [];
  } catch (err) {
    return res.redirect('/journal?err=Invalid%20bulk%20payload');
  }

  const normalizedEntries = entries
    .map((entry) => ({
      student_id: Number(entry?.student_id),
      score_raw: entry?.score,
      teacher_comment: String(entry?.teacher_comment || '').trim(),
    }))
    .filter((entry) => Number.isFinite(entry.student_id) && entry.student_id > 0);

  if (!normalizedEntries.length) {
    return res.redirect('/journal?err=No%20grades%20to%20save');
  }
  if (normalizedEntries.length > 500) {
    return res.redirect('/journal?err=Bulk%20limit%20exceeded');
  }
  if (!isStepUpPhraseValid(req.body.stepup_code, STEPUP_CODE_BULK)) {
    return res.redirect('/journal?err=Type%20BULK%20to%20confirm');
  }

  try {
    await ensureDbReady();
    const journalScope = await getJournalAccessScope(req);
    const teacherJournalMode = canUseTeacherJournalMode(req, journalScope);
    if (!journalScope.canUseJournal || !teacherJournalMode) {
      return res.status(403).send('Forbidden (journal)');
    }

    const column = await db.get(
      `
        SELECT
          jc.*,
          h.group_number AS homework_group_number,
          h.custom_due_date,
          h.class_date,
          h.description AS homework_description,
          h.day_of_week AS homework_day_of_week,
          h.class_number AS homework_class_number,
          h.meeting_url AS homework_meeting_url,
          h.link_url AS homework_link_url,
          h.file_path AS homework_file_path,
          h.is_custom_deadline AS homework_is_custom_deadline,
          h.is_control AS homework_is_control,
          h.is_credit AS homework_is_credit,
          h.is_teacher_homework AS homework_is_teacher_homework,
          h.created_at AS homework_created_at,
          h.created_by AS homework_created_by,
          h.created_by_id AS homework_created_by_id
        FROM journal_columns jc
        LEFT JOIN homework h ON h.id = jc.source_homework_id
        WHERE jc.id = ?
        LIMIT 1
      `,
      [columnId]
    );
    if (!column) {
      return res.redirect('/journal?err=Column%20not%20found');
    }
    if (isJournalColumnLocked(column)) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&err=Колонка%20заблокована%20для%20редагування`);
    }
    const subjectClosure = await getJournalSubjectClosureState(Number(column.subject_id));
    if (subjectClosure.is_closed) {
      return res.redirect(buildJournalClosedRedirectPath(column.subject_id));
    }

    if (!journalScope.fullAccess) {
      const access = await getTeacherJournalSubjectAccess(Number(req.session.user.id), Number(column.subject_id));
      if (!access.hasRows) {
        return res.status(403).send('Forbidden (journal)');
      }
      const homeworkGroup = Number(column.homework_group_number || 0);
      if (column.source_homework_id && homeworkGroup > 0 && !access.allowAll && !access.groups.has(homeworkGroup)) {
        return res.status(403).send('Forbidden (journal)');
      }
    }

    const maxPoints = parsePositiveDecimal(column.max_points, 10);
    const uniqueStudentIds = Array.from(new Set(normalizedEntries.map((entry) => entry.student_id)));
    const activeUserFilter = usersHasIsActive ? ' AND u.is_active = 1' : '';
    const studentRows = await db.all(
      `
        SELECT sg.student_id, sg.group_number
        FROM student_groups sg
        JOIN users u ON u.id = sg.student_id
        WHERE sg.subject_id = ?
          AND sg.student_id IN (${uniqueStudentIds.map(() => '?').join(',')})
          ${activeUserFilter}
      `,
      [column.subject_id, ...uniqueStudentIds]
    );
    const studentGroups = new Map(
      (studentRows || []).map((row) => [Number(row.student_id), Number(row.group_number || 0)])
    );
    if (!journalScope.fullAccess) {
      const access = await getTeacherJournalSubjectAccess(Number(req.session.user.id), Number(column.subject_id));
      for (const studentId of uniqueStudentIds) {
        const groupNumber = Number(studentGroups.get(studentId) || 0);
        if (!groupNumber) {
          return res.redirect(`/journal?subject_id=${column.subject_id}&err=Student%20is%20not%20assigned%20to%20subject`);
        }
        if (!access.allowAll && !access.groups.has(groupNumber)) {
          return res.status(403).send('Forbidden (journal)');
        }
      }
    } else {
      for (const studentId of uniqueStudentIds) {
        if (!studentGroups.has(studentId)) {
          return res.redirect(`/journal?subject_id=${column.subject_id}&err=Student%20is%20not%20assigned%20to%20subject`);
        }
      }
    }

    const submissionCache = new Map();
    const resolveSubmissionStatusForStudent = async (studentId) => {
      if (!column.source_homework_id) return 'manual';
      if (submissionCache.has(studentId)) return submissionCache.get(studentId);
      const groupNumber = Number(studentGroups.get(studentId) || 0);
      const resolvedHomework = await resolveJournalColumnHomeworkForStudent(column, groupNumber);
      const submission = resolvedHomework.homework_id
        ? await db.get(
            `
              SELECT submitted_at
              FROM homework_submissions
              WHERE homework_id = ? AND student_id = ?
              LIMIT 1
            `,
            [resolvedHomework.homework_id, studentId]
          )
        : null;
      const status = resolveHomeworkSubmissionStatus(
        {
          custom_due_date: resolvedHomework.custom_due_date,
          class_date: resolvedHomework.class_date,
        },
        submission
      );
      submissionCache.set(studentId, status);
      return status;
    };

    let updatedCount = 0;
    for (const entry of normalizedEntries) {
      const scoreText = String(entry.score_raw ?? '').trim();
      if (!scoreText) continue;
      const parsedScore = Number(scoreText.replace(',', '.'));
      const score = Number.isFinite(parsedScore) ? Math.round(parsedScore * 100) / 100 : NaN;
      if (!Number.isFinite(score) || score < 0 || score > maxPoints) {
        return res.redirect(
          `/journal?subject_id=${column.subject_id}&err=Bulk%20score%20must%20be%20between%200%20and%20${encodeURIComponent(String(maxPoints))}`
        );
      }
      if (entry.teacher_comment.length > 2000) {
        return res.redirect(`/journal?subject_id=${column.subject_id}&err=Comment%20is%20too%20long`);
      }
      const beforeGradeRow = await db.get(
        `
          SELECT score, teacher_comment, submission_status, graded_by, graded_at, deleted_at, deleted_by
          FROM journal_grades
          WHERE column_id = ?
            AND student_id = ?
          LIMIT 1
        `,
        [columnId, entry.student_id]
      );
      const submissionStatus = await resolveSubmissionStatusForStudent(entry.student_id);
      await db.run(
        `
          INSERT INTO journal_grades
            (column_id, student_id, score, teacher_comment, graded_by, graded_at, submission_status)
          VALUES (?, ?, ?, ?, ?, NOW(), ?)
          ON CONFLICT (column_id, student_id)
          DO UPDATE SET
            score = EXCLUDED.score,
            teacher_comment = EXCLUDED.teacher_comment,
            graded_by = EXCLUDED.graded_by,
            graded_at = EXCLUDED.graded_at,
            submission_status = EXCLUDED.submission_status,
            deleted_at = NULL,
            deleted_by = NULL
        `,
        [
          columnId,
          entry.student_id,
          score,
          entry.teacher_comment || null,
          Number(req.session.user.id),
          submissionStatus,
        ]
      );
      const afterGradeRow = await db.get(
        `
          SELECT score, teacher_comment, submission_status, graded_by, graded_at, deleted_at, deleted_by
          FROM journal_grades
          WHERE column_id = ?
            AND student_id = ?
          LIMIT 1
        `,
        [columnId, entry.student_id]
      );
      await appendJournalGradeHashAudit({
        columnId,
        studentId: entry.student_id,
        subjectId: Number(column.subject_id || 0),
        courseId: Number(column.course_id || req.session.user.course_id || 1),
        semesterId: column.semester_id ? Number(column.semester_id) : null,
        actorUserId: Number(req.session.user.id),
        actionType: 'grade_bulk_save',
        beforeState: buildGradeAuditState(beforeGradeRow),
        afterState: buildGradeAuditState(afterGradeRow),
      });
      await upsertJournalModerationPending({
        column,
        studentId: entry.student_id,
        score,
        actorUserId: Number(req.session.user.id),
      });
      updatedCount += 1;
    }

    if (updatedCount < 1) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&err=No%20grades%20to%20save`);
    }

    logActivity(
      db,
      req,
      'journal_grade_bulk_save',
      'journal_grade',
      columnId,
      {
        subject_id: Number(column.subject_id),
        updated_count: updatedCount,
      },
      Number(column.course_id || req.session.user.course_id || 1),
      column.semester_id ? Number(column.semester_id) : null
    );
    const subjectId = Number(column.subject_id || subjectIdFromBody || 0);
    return res.redirect(`/journal?subject_id=${subjectId}&ok=Масове%20оцінювання%20збережено%20(${updatedCount})`);
  } catch (err) {
    return res.redirect('/journal?err=Database%20error');
  }
});

app.post('/journal/grades/delete', requireLogin, writeLimiter, async (req, res) => {
  const columnId = Number(req.body.column_id);
  const studentId = Number(req.body.student_id);
  if (!Number.isFinite(columnId) || columnId < 1 || !Number.isFinite(studentId) || studentId < 1) {
    return res.redirect('/journal?err=Invalid%20grade%20target');
  }

  try {
    await ensureDbReady();
    const journalScope = await getJournalAccessScope(req);
    const teacherJournalMode = canUseTeacherJournalMode(req, journalScope);
    if (!journalScope.canUseJournal || !teacherJournalMode) {
      return res.status(403).send('Forbidden (journal)');
    }

    const column = await db.get(
      `
        SELECT
          jc.*,
          h.group_number AS homework_group_number
        FROM journal_columns jc
        LEFT JOIN homework h ON h.id = jc.source_homework_id
        WHERE jc.id = ?
        LIMIT 1
      `,
      [columnId]
    );
    if (!column) {
      return res.redirect('/journal?err=Column%20not%20found');
    }
    if (isJournalColumnLocked(column)) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&err=Колонка%20заблокована%20для%20редагування`);
    }
    const subjectClosure = await getJournalSubjectClosureState(Number(column.subject_id));
    if (subjectClosure.is_closed) {
      return res.redirect(buildJournalClosedRedirectPath(column.subject_id));
    }

    const studentRow = await getJournalStudentGroup(column.subject_id, studentId);
    if (!studentRow) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&err=Student%20is%20not%20assigned%20to%20subject`);
    }

    if (!journalScope.fullAccess) {
      const access = await getTeacherJournalSubjectAccess(Number(req.session.user.id), Number(column.subject_id));
      if (!access.hasRows) {
        return res.status(403).send('Forbidden (journal)');
      }
      const studentGroup = Number(studentRow.group_number || 0);
      if (!access.allowAll && !access.groups.has(studentGroup)) {
        return res.status(403).send('Forbidden (journal)');
      }
      const homeworkGroup = Number(column.homework_group_number || 0);
      if (column.source_homework_id && homeworkGroup > 0 && !access.allowAll && !access.groups.has(homeworkGroup)) {
        return res.status(403).send('Forbidden (journal)');
      }
    }

    const activeGrade = await db.get(
      `
        SELECT id, score, teacher_comment, submission_status, graded_by, graded_at, deleted_at, deleted_by
        FROM journal_grades
        WHERE column_id = ? AND student_id = ?
          AND deleted_at IS NULL
        LIMIT 1
      `,
      [columnId, studentId]
    );
    if (!activeGrade) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&err=Оцінка%20не%20знайдена`);
    }
    const beforeGradeState = buildGradeAuditState(activeGrade);

    await db.run(
      `
        UPDATE journal_grades
        SET deleted_at = NOW(),
            deleted_by = ?
        WHERE column_id = ? AND student_id = ?
          AND deleted_at IS NULL
      `,
      [Number(req.session.user.id), columnId, studentId]
    );
    await db.run(
      `
        DELETE FROM journal_grade_moderations
        WHERE column_id = ?
          AND student_id = ?
      `,
      [columnId, studentId]
    );
    const afterGradeRow = await db.get(
      `
        SELECT score, teacher_comment, submission_status, graded_by, graded_at, deleted_at, deleted_by
        FROM journal_grades
        WHERE column_id = ?
          AND student_id = ?
        LIMIT 1
      `,
      [columnId, studentId]
    );
    await appendJournalGradeHashAudit({
      columnId,
      studentId,
      subjectId: Number(column.subject_id || 0),
      courseId: Number(column.course_id || req.session.user.course_id || 1),
      semesterId: column.semester_id ? Number(column.semester_id) : null,
      actorUserId: Number(req.session.user.id),
      actionType: 'grade_delete',
      beforeState: beforeGradeState,
      afterState: buildGradeAuditState(afterGradeRow),
    });

    logActivity(
      db,
      req,
      'journal_grade_delete',
      'journal_grade',
      columnId,
      {
        student_id: studentId,
        subject_id: Number(column.subject_id),
      },
      Number(column.course_id || req.session.user.course_id || 1),
      column.semester_id ? Number(column.semester_id) : null
    );
    const undoUntil = Date.now() + (JOURNAL_GRADE_UNDO_SECONDS * 1000);
    return res.redirect(
      `/journal?subject_id=${column.subject_id}&ok=Оцінку%20видалено&undo_column_id=${columnId}&undo_student_id=${studentId}&undo_until=${undoUntil}`
    );
  } catch (err) {
    return res.redirect('/journal?err=Database%20error');
  }
});

app.post('/journal/grades/restore', requireLogin, writeLimiter, async (req, res) => {
  const columnId = Number(req.body.column_id);
  const studentId = Number(req.body.student_id);
  if (!Number.isFinite(columnId) || columnId < 1 || !Number.isFinite(studentId) || studentId < 1) {
    return res.redirect('/journal?err=Invalid%20grade%20target');
  }

  try {
    await ensureDbReady();
    const journalScope = await getJournalAccessScope(req);
    const teacherJournalMode = canUseTeacherJournalMode(req, journalScope);
    if (!journalScope.canUseJournal || !teacherJournalMode) {
      return res.status(403).send('Forbidden (journal)');
    }

    const column = await db.get(
      `
        SELECT
          jc.*,
          h.group_number AS homework_group_number
        FROM journal_columns jc
        LEFT JOIN homework h ON h.id = jc.source_homework_id
        WHERE jc.id = ?
        LIMIT 1
      `,
      [columnId]
    );
    if (!column) {
      return res.redirect('/journal?err=Column%20not%20found');
    }
    if (isJournalColumnLocked(column)) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&err=Колонка%20заблокована%20для%20редагування`);
    }
    const subjectClosure = await getJournalSubjectClosureState(Number(column.subject_id));
    if (subjectClosure.is_closed) {
      return res.redirect(buildJournalClosedRedirectPath(column.subject_id));
    }

    const studentRow = await getJournalStudentGroup(column.subject_id, studentId);
    if (!studentRow) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&err=Student%20is%20not%20assigned%20to%20subject`);
    }

    if (!journalScope.fullAccess) {
      const access = await getTeacherJournalSubjectAccess(Number(req.session.user.id), Number(column.subject_id));
      if (!access.hasRows) {
        return res.status(403).send('Forbidden (journal)');
      }
      const studentGroup = Number(studentRow.group_number || 0);
      if (!access.allowAll && !access.groups.has(studentGroup)) {
        return res.status(403).send('Forbidden (journal)');
      }
      const homeworkGroup = Number(column.homework_group_number || 0);
      if (column.source_homework_id && homeworkGroup > 0 && !access.allowAll && !access.groups.has(homeworkGroup)) {
        return res.status(403).send('Forbidden (journal)');
      }
    }

    const restorable = await db.get(
      `
        SELECT id, score, teacher_comment, submission_status, graded_by, graded_at, deleted_at, deleted_by
        FROM journal_grades
        WHERE column_id = ? AND student_id = ?
          AND deleted_at IS NOT NULL
          AND deleted_at >= (NOW() - (? * INTERVAL '1 second'))
        LIMIT 1
      `,
      [columnId, studentId, JOURNAL_GRADE_UNDO_SECONDS]
    );
    if (!restorable) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&err=Час%20на%20відновлення%20оцінки%20минув`);
    }
    const beforeGradeState = buildGradeAuditState(restorable);

    await db.run(
      `
        UPDATE journal_grades
        SET deleted_at = NULL,
            deleted_by = NULL
        WHERE column_id = ? AND student_id = ?
      `,
      [columnId, studentId]
    );
    const afterGradeRow = await db.get(
      `
        SELECT score, teacher_comment, submission_status, graded_by, graded_at, deleted_at, deleted_by
        FROM journal_grades
        WHERE column_id = ?
          AND student_id = ?
        LIMIT 1
      `,
      [columnId, studentId]
    );
    await appendJournalGradeHashAudit({
      columnId,
      studentId,
      subjectId: Number(column.subject_id || 0),
      courseId: Number(column.course_id || req.session.user.course_id || 1),
      semesterId: column.semester_id ? Number(column.semester_id) : null,
      actorUserId: Number(req.session.user.id),
      actionType: 'grade_restore',
      beforeState: beforeGradeState,
      afterState: buildGradeAuditState(afterGradeRow),
    });

    logActivity(
      db,
      req,
      'journal_grade_restore',
      'journal_grade',
      columnId,
      {
        student_id: studentId,
        subject_id: Number(column.subject_id),
      },
      Number(column.course_id || req.session.user.course_id || 1),
      column.semester_id ? Number(column.semester_id) : null
    );
    return res.redirect(`/journal?subject_id=${column.subject_id}&ok=Оцінку%20відновлено`);
  } catch (err) {
    return res.redirect('/journal?err=Database%20error');
  }
});

app.post('/journal/retakes/create', requireLogin, writeLimiter, async (req, res) => {
  const columnId = Number(req.body.column_id);
  const studentId = Number(req.body.student_id);
  const kind = normalizeJournalRetakeKind(req.body.kind);
  const dueDateRaw = String(req.body.due_date || '').trim();
  const note = normalizeJournalRetakeNote(req.body.note);

  if (!Number.isFinite(columnId) || columnId < 1 || !Number.isFinite(studentId) || studentId < 1) {
    return res.redirect('/journal?err=Invalid%20retake%20target');
  }
  if (dueDateRaw && !isValidDateString(dueDateRaw)) {
    return res.redirect('/journal?err=Invalid%20retake%20due%20date');
  }
  const dueDate = dueDateRaw && isValidDateString(dueDateRaw) ? dueDateRaw : null;

  try {
    await ensureDbReady();
    const journalScope = await getJournalAccessScope(req);
    const teacherJournalMode = canUseTeacherJournalMode(req, journalScope);
    if (!journalScope.canUseJournal || !teacherJournalMode) {
      return res.status(403).send('Forbidden (journal)');
    }

    const column = await db.get(
      `
        SELECT
          jc.*,
          h.group_number AS homework_group_number
        FROM journal_columns jc
        LEFT JOIN homework h ON h.id = jc.source_homework_id
        WHERE jc.id = ?
        LIMIT 1
      `,
      [columnId]
    );
    if (!column) {
      return res.redirect('/journal?err=Column%20not%20found');
    }
    if (isJournalColumnLocked(column)) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&err=Колонка%20заблокована%20для%20редагування`);
    }
    const subjectClosure = await getJournalSubjectClosureState(Number(column.subject_id));
    if (subjectClosure.is_closed) {
      return res.redirect(buildJournalClosedRedirectPath(column.subject_id));
    }

    const studentRow = await getJournalStudentGroup(column.subject_id, studentId);
    if (!studentRow) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&err=Student%20is%20not%20assigned%20to%20subject`);
    }

    if (!journalScope.fullAccess) {
      const access = await getTeacherJournalSubjectAccess(Number(req.session.user.id), Number(column.subject_id));
      if (!access.hasRows) {
        return res.status(403).send('Forbidden (journal)');
      }
      const studentGroup = Number(studentRow.group_number || 0);
      if (!access.allowAll && !access.groups.has(studentGroup)) {
        return res.status(403).send('Forbidden (journal)');
      }
      const homeworkGroup = Number(column.homework_group_number || 0);
      if (column.source_homework_id && homeworkGroup > 0 && !access.allowAll && !access.groups.has(homeworkGroup)) {
        return res.status(403).send('Forbidden (journal)');
      }
    }

    const attemptCounter = await db.get(
      `
        SELECT COALESCE(MAX(attempt_no), 0) AS max_attempt_no
        FROM journal_retake_attempts
        WHERE column_id = ? AND student_id = ?
      `,
      [columnId, studentId]
    );
    const attemptNo = Number(attemptCounter?.max_attempt_no || 0) + 1;

    await db.run(
      `
        INSERT INTO journal_retake_attempts
          (
            column_id, student_id, attempt_no, kind, status,
            due_date, approved_by, approved_at, note,
            count_in_final, created_at, updated_at
          )
        VALUES (?, ?, ?, ?, 'planned', ?, ?, NOW(), ?, 0, NOW(), NOW())
      `,
      [
        columnId,
        studentId,
        attemptNo,
        kind,
        dueDate,
        Number(req.session.user.id),
        note || null,
      ]
    );

    logActivity(
      db,
      req,
      'journal_retake_create',
      'journal_retake',
      null,
      {
        subject_id: Number(column.subject_id),
        column_id: columnId,
        student_id: studentId,
        attempt_no: attemptNo,
        kind,
      },
      Number(column.course_id || req.session.user.course_id || 1),
      column.semester_id ? Number(column.semester_id) : null
    );
    return res.redirect(
      `/journal?subject_id=${column.subject_id}&open_column_id=${columnId}&open_student_id=${studentId}&ok=${encodeURIComponent('Спробу додано')}`
    );
  } catch (err) {
    return res.redirect('/journal?err=Database%20error');
  }
});

app.post('/journal/retakes/update', requireLogin, writeLimiter, async (req, res) => {
  const attemptId = Number(req.body.attempt_id);
  const columnId = Number(req.body.column_id);
  const studentId = Number(req.body.student_id);
  const status = normalizeJournalRetakeStatus(req.body.status);
  const dueDateRaw = String(req.body.due_date || '').trim();
  const note = normalizeJournalRetakeNote(req.body.note);
  const teacherComment = normalizeJournalRetakeComment(req.body.teacher_comment);
  const countInFinal = parseBinaryFlag(req.body.count_in_final, 0) === 1 ? 1 : 0;
  const scoreText = String(req.body.score || '').trim();
  const parsedScore = scoreText ? Number(scoreText.replace(',', '.')) : NaN;
  const score = scoreText ? (Number.isFinite(parsedScore) ? Math.round(parsedScore * 100) / 100 : NaN) : null;

  if (!Number.isFinite(attemptId) || attemptId < 1 || !Number.isFinite(columnId) || columnId < 1 || !Number.isFinite(studentId) || studentId < 1) {
    return res.redirect('/journal?err=Invalid%20retake%20target');
  }
  if (dueDateRaw && !isValidDateString(dueDateRaw)) {
    return res.redirect('/journal?err=Invalid%20retake%20due%20date');
  }
  if (scoreText && !Number.isFinite(score)) {
    return res.redirect('/journal?err=Invalid%20retake%20score');
  }
  if (status === 'graded' && !Number.isFinite(score)) {
    return res.redirect('/journal?err=Для%20статусу%20Оцінено%20потрібно%20вказати%20бал');
  }
  if (countInFinal === 1 && (status !== 'graded' || !Number.isFinite(score))) {
    return res.redirect('/journal?err=Щоб%20врахувати%20у%20фіналі,%20потрібно%20вказати%20оцінений%20бал');
  }
  const dueDate = dueDateRaw && isValidDateString(dueDateRaw) ? dueDateRaw : null;

  try {
    await ensureDbReady();
    const journalScope = await getJournalAccessScope(req);
    const teacherJournalMode = canUseTeacherJournalMode(req, journalScope);
    if (!journalScope.canUseJournal || !teacherJournalMode) {
      return res.status(403).send('Forbidden (journal)');
    }

    const column = await db.get(
      `
        SELECT
          jc.*,
          h.group_number AS homework_group_number
        FROM journal_columns jc
        LEFT JOIN homework h ON h.id = jc.source_homework_id
        WHERE jc.id = ?
        LIMIT 1
      `,
      [columnId]
    );
    if (!column) {
      return res.redirect('/journal?err=Column%20not%20found');
    }
    if (isJournalColumnLocked(column)) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&err=Колонка%20заблокована%20для%20редагування`);
    }
    const subjectClosure = await getJournalSubjectClosureState(Number(column.subject_id));
    if (subjectClosure.is_closed) {
      return res.redirect(buildJournalClosedRedirectPath(column.subject_id));
    }
    const maxPoints = parsePositiveDecimal(column.max_points, 10);
    if (Number.isFinite(score) && (score < 0 || score > maxPoints)) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&err=Retake%20score%20must%20be%20between%200%20and%20${encodeURIComponent(String(maxPoints))}`);
    }

    const studentRow = await getJournalStudentGroup(column.subject_id, studentId);
    if (!studentRow) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&err=Student%20is%20not%20assigned%20to%20subject`);
    }

    if (!journalScope.fullAccess) {
      const access = await getTeacherJournalSubjectAccess(Number(req.session.user.id), Number(column.subject_id));
      if (!access.hasRows) {
        return res.status(403).send('Forbidden (journal)');
      }
      const studentGroup = Number(studentRow.group_number || 0);
      if (!access.allowAll && !access.groups.has(studentGroup)) {
        return res.status(403).send('Forbidden (journal)');
      }
      const homeworkGroup = Number(column.homework_group_number || 0);
      if (column.source_homework_id && homeworkGroup > 0 && !access.allowAll && !access.groups.has(homeworkGroup)) {
        return res.status(403).send('Forbidden (journal)');
      }
    }

    const existingAttempt = await db.get(
      `
        SELECT id, attempt_no
        FROM journal_retake_attempts
        WHERE id = ?
          AND column_id = ?
          AND student_id = ?
        LIMIT 1
      `,
      [attemptId, columnId, studentId]
    );
    if (!existingAttempt) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&err=Спроба%20не%20знайдена`);
    }

    const beforeGradeState = (countInFinal === 1 && Number.isFinite(score))
      ? buildGradeAuditState(
          await db.get(
            `
              SELECT score, teacher_comment, submission_status, graded_by, graded_at, deleted_at, deleted_by
              FROM journal_grades
              WHERE column_id = ?
                AND student_id = ?
              LIMIT 1
            `,
            [columnId, studentId]
          )
        )
      : null;

    const gradedBy = status === 'graded' && Number.isFinite(score) ? Number(req.session.user.id) : null;
    await withTransaction(async (client) => {
      const query = (sql, params = []) => client.query(convertPlaceholders(sql), params);
      await query(
        `
          UPDATE journal_retake_attempts
          SET status = ?,
              due_date = ?,
              note = ?,
              score = ?,
              teacher_comment = ?,
              graded_by = ?,
              graded_at = CASE WHEN ? IS NULL THEN NULL ELSE NOW() END,
              count_in_final = ?,
              updated_at = NOW()
          WHERE id = ?
        `,
        [
          status,
          dueDate,
          note || null,
          Number.isFinite(score) ? score : null,
          teacherComment || null,
          gradedBy,
          gradedBy,
          countInFinal,
          attemptId,
        ]
      );

      if (countInFinal === 1 && Number.isFinite(score)) {
        await query(
          `
            UPDATE journal_retake_attempts
            SET count_in_final = CASE WHEN id = ? THEN 1 ELSE 0 END,
                updated_at = NOW()
            WHERE column_id = ?
              AND student_id = ?
          `,
          [attemptId, columnId, studentId]
        );
        await query(
          `
            INSERT INTO journal_grades
              (column_id, student_id, score, teacher_comment, graded_by, graded_at, submission_status)
            VALUES (?, ?, ?, ?, ?, NOW(), 'manual')
            ON CONFLICT (column_id, student_id)
            DO UPDATE SET
              score = EXCLUDED.score,
              teacher_comment = EXCLUDED.teacher_comment,
              graded_by = EXCLUDED.graded_by,
              graded_at = EXCLUDED.graded_at,
              submission_status = EXCLUDED.submission_status,
              deleted_at = NULL,
              deleted_by = NULL
          `,
          [columnId, studentId, score, teacherComment || null, Number(req.session.user.id)]
        );
        if (isJournalModerationRequiredColumn(column)) {
          await query(
            `
              INSERT INTO journal_grade_moderations
              (
                subject_id,
                course_id,
                semester_id,
                column_id,
                student_id,
                status,
                original_score,
                moderated_score,
                moderation_comment,
                created_by,
                created_at,
                reviewed_by,
                reviewed_at,
                updated_at
              )
              VALUES (?, ?, ?, ?, ?, 'pending', ?, NULL, NULL, ?, NOW(), NULL, NULL, NOW())
              ON CONFLICT (column_id, student_id)
              DO UPDATE SET
                status = 'pending',
                original_score = EXCLUDED.original_score,
                moderated_score = NULL,
                moderation_comment = NULL,
                reviewed_by = NULL,
                reviewed_at = NULL,
                updated_at = NOW()
            `,
            [
              Number(column.subject_id || 0),
              Number(column.course_id || 0) || null,
              column.semester_id ? Number(column.semester_id) : null,
              columnId,
              studentId,
              score,
              Number(req.session.user.id),
            ]
          );
        }
      }
    });
    if (countInFinal === 1 && Number.isFinite(score)) {
      const afterGradeRow = await db.get(
        `
          SELECT score, teacher_comment, submission_status, graded_by, graded_at, deleted_at, deleted_by
          FROM journal_grades
          WHERE column_id = ?
            AND student_id = ?
          LIMIT 1
        `,
        [columnId, studentId]
      );
      await appendJournalGradeHashAudit({
        columnId,
        studentId,
        subjectId: Number(column.subject_id || 0),
        courseId: Number(column.course_id || req.session.user.course_id || 1),
        semesterId: column.semester_id ? Number(column.semester_id) : null,
        actorUserId: Number(req.session.user.id),
        actionType: 'grade_retake_apply',
        beforeState: beforeGradeState,
        afterState: buildGradeAuditState(afterGradeRow),
      });
    }

    logActivity(
      db,
      req,
      'journal_retake_update',
      'journal_retake',
      attemptId,
      {
        subject_id: Number(column.subject_id),
        column_id: columnId,
        student_id: studentId,
        status,
        count_in_final: countInFinal,
      },
      Number(column.course_id || req.session.user.course_id || 1),
      column.semester_id ? Number(column.semester_id) : null
    );
    return res.redirect(
      `/journal?subject_id=${column.subject_id}&open_column_id=${columnId}&open_student_id=${studentId}&ok=${encodeURIComponent('Спробу оновлено')}`
    );
  } catch (err) {
    return res.redirect('/journal?err=Database%20error');
  }
});

app.post('/journal/appeals/create', requireLogin, writeLimiter, async (req, res) => {
  const columnId = Number(req.body.column_id);
  const studentId = Number(req.body.student_id);
  const reason = normalizeJournalAppealReason(req.body.reason);
  const requestedScoreRaw = String(req.body.requested_score || '').trim();
  const parsedRequestedScore = requestedScoreRaw ? Number(requestedScoreRaw.replace(',', '.')) : NaN;
  const requestedScore = requestedScoreRaw
    ? (Number.isFinite(parsedRequestedScore) ? Math.round(parsedRequestedScore * 100) / 100 : NaN)
    : null;

  if (!Number.isFinite(columnId) || columnId < 1 || !Number.isFinite(studentId) || studentId < 1) {
    return res.redirect('/journal?err=Invalid%20appeal%20target');
  }
  if (!reason) {
    return res.redirect('/journal?err=Вкажіть%20причину%20апеляції');
  }
  if (requestedScoreRaw && !Number.isFinite(requestedScore)) {
    return res.redirect('/journal?err=Invalid%20requested%20score');
  }

  try {
    await ensureDbReady();
    const journalScope = await getJournalAccessScope(req);
    const teacherJournalMode = canUseTeacherJournalMode(req, journalScope);
    if (!journalScope.canUseJournal || teacherJournalMode) {
      return res.status(403).send('Forbidden (journal)');
    }
    if (Number(req.session.user.id) !== studentId) {
      return res.status(403).send('Forbidden (journal)');
    }

    const column = await db.get(
      `
        SELECT jc.*
        FROM journal_columns jc
        WHERE jc.id = ?
        LIMIT 1
      `,
      [columnId]
    );
    if (!column) {
      return res.redirect('/journal?err=Column%20not%20found');
    }
    const subjectClosure = await getJournalSubjectClosureState(Number(column.subject_id));
    if (subjectClosure.is_closed) {
      return res.redirect(buildJournalClosedRedirectPath(column.subject_id));
    }

    const studentRow = await getJournalStudentGroup(column.subject_id, studentId);
    if (!studentRow) {
      return res.status(403).send('Forbidden (journal)');
    }

    const maxPoints = parsePositiveDecimal(column.max_points, 10);
    if (Number.isFinite(requestedScore) && (requestedScore < 0 || requestedScore > maxPoints)) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&err=Requested%20score%20must%20be%20between%200%20and%20${encodeURIComponent(String(maxPoints))}`);
    }

    const existingGrade = await db.get(
      `
        SELECT score
        FROM journal_grades
        WHERE column_id = ? AND student_id = ?
          AND deleted_at IS NULL
        LIMIT 1
      `,
      [columnId, studentId]
    );
    if (!existingGrade || !Number.isFinite(Number(existingGrade.score))) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&open_column_id=${columnId}&open_student_id=${studentId}&err=${encodeURIComponent('Немає оцінки для апеляції')}`);
    }

    const activeAppeal = await db.get(
      `
        SELECT id
        FROM journal_grade_appeals
        WHERE column_id = ?
          AND student_id = ?
          AND status IN ('pending', 'in_review')
        LIMIT 1
      `,
      [columnId, studentId]
    );
    if (activeAppeal) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&open_column_id=${columnId}&open_student_id=${studentId}&err=${encodeURIComponent('Вже є активна апеляція для цієї клітинки')}`);
    }

    await db.run(
      `
        INSERT INTO journal_grade_appeals
          (
            subject_id, course_id, semester_id, column_id, student_id,
            requested_score, reason, status, created_by,
            created_at, updated_at, sla_due_at
          )
        VALUES (?, ?, ?, ?, ?, ?, ?, 'pending', ?, NOW(), NOW(), NOW() + (? * INTERVAL '1 hour'))
      `,
      [
        Number(column.subject_id),
        Number(column.course_id || req.session.user.course_id || 1),
        column.semester_id ? Number(column.semester_id) : null,
        columnId,
        studentId,
        Number.isFinite(requestedScore) ? requestedScore : null,
        reason,
        Number(req.session.user.id),
        JOURNAL_APPEAL_SLA_HOURS,
      ]
    );

    logActivity(
      db,
      req,
      'journal_appeal_create',
      'journal_grade_appeal',
      null,
      {
        subject_id: Number(column.subject_id),
        column_id: columnId,
        student_id: studentId,
      },
      Number(column.course_id || req.session.user.course_id || 1),
      column.semester_id ? Number(column.semester_id) : null
    );
    return res.redirect(
      `/journal?subject_id=${column.subject_id}&open_column_id=${columnId}&open_student_id=${studentId}&ok=${encodeURIComponent('Апеляцію подано')}`
    );
  } catch (err) {
    return res.redirect('/journal?err=Database%20error');
  }
});

app.post('/journal/appeals/update', requireLogin, writeLimiter, async (req, res) => {
  const appealId = Number(req.body.appeal_id);
  const columnId = Number(req.body.column_id);
  const studentId = Number(req.body.student_id);
  const status = normalizeJournalAppealStatus(req.body.status);
  const decisionComment = normalizeJournalAppealComment(req.body.decision_comment);
  const resolvedScoreRaw = String(req.body.resolved_score || '').trim();
  const parsedResolvedScore = resolvedScoreRaw ? Number(resolvedScoreRaw.replace(',', '.')) : NaN;
  const resolvedScore = resolvedScoreRaw
    ? (Number.isFinite(parsedResolvedScore) ? Math.round(parsedResolvedScore * 100) / 100 : NaN)
    : null;
  const applyResolvedScore = parseBinaryFlag(req.body.apply_resolved_score, 0) === 1;

  if (
    !Number.isFinite(appealId) || appealId < 1
    || !Number.isFinite(columnId) || columnId < 1
    || !Number.isFinite(studentId) || studentId < 1
  ) {
    return res.redirect('/journal?err=Invalid%20appeal%20target');
  }
  if (resolvedScoreRaw && !Number.isFinite(resolvedScore)) {
    return res.redirect('/journal?err=Invalid%20resolved%20score');
  }
  if (applyResolvedScore && !Number.isFinite(resolvedScore)) {
    return res.redirect('/journal?err=Щоб%20застосувати%20новий%20бал,%20вкажіть%20коректне%20значення');
  }

  try {
    await ensureDbReady();
    const journalScope = await getJournalAccessScope(req);
    const teacherJournalMode = canUseTeacherJournalMode(req, journalScope);
    if (!journalScope.canUseJournal || !teacherJournalMode) {
      return res.status(403).send('Forbidden (journal)');
    }

    const column = await db.get(
      `
        SELECT
          jc.*,
          h.group_number AS homework_group_number
        FROM journal_columns jc
        LEFT JOIN homework h ON h.id = jc.source_homework_id
        WHERE jc.id = ?
        LIMIT 1
      `,
      [columnId]
    );
    if (!column) {
      return res.redirect('/journal?err=Column%20not%20found');
    }
    if (isJournalColumnLocked(column)) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&err=Колонка%20заблокована%20для%20редагування`);
    }
    const subjectClosure = await getJournalSubjectClosureState(Number(column.subject_id));
    if (subjectClosure.is_closed) {
      return res.redirect(buildJournalClosedRedirectPath(column.subject_id));
    }

    const studentRow = await getJournalStudentGroup(column.subject_id, studentId);
    if (!studentRow) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&err=Student%20is%20not%20assigned%20to%20subject`);
    }

    if (!journalScope.fullAccess) {
      const access = await getTeacherJournalSubjectAccess(Number(req.session.user.id), Number(column.subject_id));
      if (!access.hasRows) {
        return res.status(403).send('Forbidden (journal)');
      }
      const studentGroup = Number(studentRow.group_number || 0);
      if (!access.allowAll && !access.groups.has(studentGroup)) {
        return res.status(403).send('Forbidden (journal)');
      }
      const homeworkGroup = Number(column.homework_group_number || 0);
      if (column.source_homework_id && homeworkGroup > 0 && !access.allowAll && !access.groups.has(homeworkGroup)) {
        return res.status(403).send('Forbidden (journal)');
      }
    }

    const appeal = await db.get(
      `
        SELECT id
        FROM journal_grade_appeals
        WHERE id = ?
          AND column_id = ?
          AND student_id = ?
        LIMIT 1
      `,
      [appealId, columnId, studentId]
    );
    if (!appeal) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&err=Апеляцію%20не%20знайдено`);
    }

    const maxPoints = parsePositiveDecimal(column.max_points, 10);
    if (Number.isFinite(resolvedScore) && (resolvedScore < 0 || resolvedScore > maxPoints)) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&err=Resolved%20score%20must%20be%20between%200%20and%20${encodeURIComponent(String(maxPoints))}`);
    }

    const isFinalStatus = ['approved', 'rejected'].includes(status);
    const willApplyResolvedScore = status === 'approved' && applyResolvedScore && Number.isFinite(resolvedScore);
    const beforeGradeState = willApplyResolvedScore
      ? buildGradeAuditState(
          await db.get(
            `
              SELECT score, teacher_comment, submission_status, graded_by, graded_at, deleted_at, deleted_by
              FROM journal_grades
              WHERE column_id = ?
                AND student_id = ?
              LIMIT 1
            `,
            [columnId, studentId]
          )
        )
      : null;
    await withTransaction(async (client) => {
      const query = (sql, params = []) => client.query(convertPlaceholders(sql), params);
      await query(
        `
          UPDATE journal_grade_appeals
          SET status = ?,
              decision_comment = ?,
              resolved_score = ?,
              reviewed_by = ?,
              reviewed_at = ?,
              updated_at = NOW()
          WHERE id = ?
        `,
        [
          status,
          decisionComment || null,
          Number.isFinite(resolvedScore) ? resolvedScore : null,
          isFinalStatus ? Number(req.session.user.id) : null,
          isFinalStatus ? new Date().toISOString() : null,
          appealId,
        ]
      );

      if (willApplyResolvedScore) {
        await query(
          `
            INSERT INTO journal_grades
              (column_id, student_id, score, teacher_comment, graded_by, graded_at, submission_status)
            VALUES (?, ?, ?, ?, ?, NOW(), 'manual')
            ON CONFLICT (column_id, student_id)
            DO UPDATE SET
              score = EXCLUDED.score,
              teacher_comment = EXCLUDED.teacher_comment,
              graded_by = EXCLUDED.graded_by,
              graded_at = EXCLUDED.graded_at,
              submission_status = EXCLUDED.submission_status,
              deleted_at = NULL,
              deleted_by = NULL
          `,
          [
            columnId,
            studentId,
            resolvedScore,
            decisionComment || null,
            Number(req.session.user.id),
          ]
        );
      }
    });
    if (willApplyResolvedScore) {
      const afterGradeRow = await db.get(
        `
          SELECT score, teacher_comment, submission_status, graded_by, graded_at, deleted_at, deleted_by
          FROM journal_grades
          WHERE column_id = ?
            AND student_id = ?
          LIMIT 1
        `,
        [columnId, studentId]
      );
      await appendJournalGradeHashAudit({
        columnId,
        studentId,
        subjectId: Number(column.subject_id || 0),
        courseId: Number(column.course_id || req.session.user.course_id || 1),
        semesterId: column.semester_id ? Number(column.semester_id) : null,
        actorUserId: Number(req.session.user.id),
        actionType: 'grade_appeal_apply',
        beforeState: beforeGradeState,
        afterState: buildGradeAuditState(afterGradeRow),
      });
    }

    logActivity(
      db,
      req,
      'journal_appeal_update',
      'journal_grade_appeal',
      appealId,
      {
        subject_id: Number(column.subject_id),
        column_id: columnId,
        student_id: studentId,
        status,
        apply_resolved_score: applyResolvedScore,
      },
      Number(column.course_id || req.session.user.course_id || 1),
      column.semester_id ? Number(column.semester_id) : null
    );
    return res.redirect(
      `/journal?subject_id=${column.subject_id}&open_column_id=${columnId}&open_student_id=${studentId}&ok=${encodeURIComponent('Апеляцію оновлено')}`
    );
  } catch (err) {
    return res.redirect('/journal?err=Database%20error');
  }
});

app.post('/journal/moderation/update', requireLogin, writeLimiter, async (req, res) => {
  const columnId = Number(req.body.column_id);
  const studentId = Number(req.body.student_id);
  const status = normalizeJournalModerationStatus(req.body.status);
  const moderationComment = normalizeJournalModerationComment(req.body.moderation_comment);
  const moderatedScoreRaw = String(req.body.moderated_score || '').trim();
  const parsedModeratedScore = moderatedScoreRaw ? Number(moderatedScoreRaw.replace(',', '.')) : NaN;
  const moderatedScore = moderatedScoreRaw
    ? (Number.isFinite(parsedModeratedScore) ? Math.round(parsedModeratedScore * 100) / 100 : NaN)
    : null;

  if (
    !Number.isFinite(columnId) || columnId < 1
    || !Number.isFinite(studentId) || studentId < 1
  ) {
    return res.redirect('/journal?err=Invalid%20moderation%20target');
  }
  if (moderatedScoreRaw && !Number.isFinite(moderatedScore)) {
    return res.redirect('/journal?err=Invalid%20moderation%20score');
  }
  if (status === 'adjusted' && !Number.isFinite(moderatedScore)) {
    return res.redirect('/journal?err=Для%20статусу%20Скориговано%20потрібно%20вказати%20новий%20бал');
  }

  try {
    await ensureDbReady();
    const journalScope = await getJournalAccessScope(req);
    const teacherJournalMode = canUseTeacherJournalMode(req, journalScope);
    if (!journalScope.canUseJournal || !teacherJournalMode) {
      return res.status(403).send('Forbidden (journal)');
    }

    const column = await db.get(
      `
        SELECT
          jc.*,
          h.group_number AS homework_group_number
        FROM journal_columns jc
        LEFT JOIN homework h ON h.id = jc.source_homework_id
        WHERE jc.id = ?
        LIMIT 1
      `,
      [columnId]
    );
    if (!column) {
      return res.redirect('/journal?err=Column%20not%20found');
    }
    if (isJournalColumnLocked(column)) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&err=Колонка%20заблокована%20для%20редагування`);
    }
    const subjectClosure = await getJournalSubjectClosureState(Number(column.subject_id));
    if (subjectClosure.is_closed) {
      return res.redirect(buildJournalClosedRedirectPath(column.subject_id));
    }
    if (!isJournalModerationRequiredColumn(column)) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&err=Модерація%20доступна%20лише%20для%20екзаменів%20та%20заліків`);
    }
    const maxPoints = parsePositiveDecimal(column.max_points, 10);
    if (Number.isFinite(moderatedScore) && (moderatedScore < 0 || moderatedScore > maxPoints)) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&err=Moderation%20score%20must%20be%20between%200%20and%20${encodeURIComponent(String(maxPoints))}`);
    }

    const studentRow = await getJournalStudentGroup(column.subject_id, studentId);
    if (!studentRow) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&err=Student%20is%20not%20assigned%20to%20subject`);
    }

    if (!journalScope.fullAccess) {
      const access = await getTeacherJournalSubjectAccess(Number(req.session.user.id), Number(column.subject_id));
      if (!access.hasRows) {
        return res.status(403).send('Forbidden (journal)');
      }
      const studentGroup = Number(studentRow.group_number || 0);
      if (!access.allowAll && !access.groups.has(studentGroup)) {
        return res.status(403).send('Forbidden (journal)');
      }
      const homeworkGroup = Number(column.homework_group_number || 0);
      if (column.source_homework_id && homeworkGroup > 0 && !access.allowAll && !access.groups.has(homeworkGroup)) {
        return res.status(403).send('Forbidden (journal)');
      }
    }

    const grade = await db.get(
      `
        SELECT score, graded_by
        FROM journal_grades
        WHERE column_id = ?
          AND student_id = ?
          AND deleted_at IS NULL
        LIMIT 1
      `,
      [columnId, studentId]
    );
    if (!grade || !Number.isFinite(Number(grade.score))) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&err=Немає%20оцінки%20для%20модерації`);
    }
    if (Number(req.session.user.id) === Number(grade.graded_by || 0)) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&err=Той%20самий%20викладач%20не%20може%20погодити%20власну%20оцінку`);
    }

    const moderatedScoreToStore = status === 'adjusted' && Number.isFinite(moderatedScore)
      ? moderatedScore
      : null;
    const originalScore = Math.round(Number(grade.score) * 100) / 100;
    await db.run(
      `
        INSERT INTO journal_grade_moderations
          (
            subject_id,
            course_id,
            semester_id,
            column_id,
            student_id,
            status,
            original_score,
            moderated_score,
            moderation_comment,
            created_by,
            created_at,
            reviewed_by,
            reviewed_at,
            updated_at
          )
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), ?, NOW(), NOW())
        ON CONFLICT (column_id, student_id)
        DO UPDATE SET
          status = EXCLUDED.status,
          original_score = EXCLUDED.original_score,
          moderated_score = EXCLUDED.moderated_score,
          moderation_comment = EXCLUDED.moderation_comment,
          reviewed_by = EXCLUDED.reviewed_by,
          reviewed_at = EXCLUDED.reviewed_at,
          updated_at = NOW()
      `,
      [
        Number(column.subject_id || 0),
        Number(column.course_id || 0) || null,
        column.semester_id ? Number(column.semester_id) : null,
        columnId,
        studentId,
        status,
        originalScore,
        moderatedScoreToStore,
        moderationComment || null,
        Number(grade.graded_by || req.session.user.id),
        Number(req.session.user.id),
      ]
    );

    logActivity(
      db,
      req,
      'journal_moderation_update',
      'journal_grade_moderation',
      null,
      {
        subject_id: Number(column.subject_id),
        column_id: columnId,
        student_id: studentId,
        status,
      },
      Number(column.course_id || req.session.user.course_id || 1),
      column.semester_id ? Number(column.semester_id) : null
    );
    return res.redirect(
      `/journal?subject_id=${column.subject_id}&open_column_id=${columnId}&open_student_id=${studentId}&ok=${encodeURIComponent('Модерацію оцінки оновлено')}`
    );
  } catch (err) {
    return res.redirect('/journal?err=Database%20error');
  }
});

app.post('/journal/competency/add', requireLogin, writeLimiter, async (req, res) => {
  const columnId = Number(req.body.column_id);
  const studentId = Number(req.body.student_id);
  const competencyKey = normalizeCompetencyKey(req.body.competency_key);
  const score = parseCompetencyScore(req.body.score);
  const note = normalizeCompetencyNote(req.body.note);

  if (
    !Number.isFinite(columnId) || columnId < 1
    || !Number.isFinite(studentId) || studentId < 1
  ) {
    return res.redirect('/journal?err=Invalid%20competency%20target');
  }
  if (!competencyKey) {
    return res.redirect('/journal?err=Invalid%20competency%20key');
  }
  if (!Number.isFinite(score)) {
    return res.redirect(`/journal?err=Competency%20score%20must%20be%20between%20${COMPETENCY_SCORE_MIN}%20and%20${COMPETENCY_SCORE_MAX}`);
  }

  try {
    await ensureDbReady();
    const journalScope = await getJournalAccessScope(req);
    const teacherJournalMode = canUseTeacherJournalMode(req, journalScope);
    if (!journalScope.canUseJournal || !teacherJournalMode) {
      return res.status(403).send('Forbidden (journal)');
    }

    const column = await db.get(
      `
        SELECT
          jc.*,
          h.group_number AS homework_group_number
        FROM journal_columns jc
        LEFT JOIN homework h ON h.id = jc.source_homework_id
        WHERE jc.id = ?
        LIMIT 1
      `,
      [columnId]
    );
    if (!column) {
      return res.redirect('/journal?err=Column%20not%20found');
    }
    if (isJournalColumnLocked(column)) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&err=Колонка%20заблокована%20для%20редагування`);
    }
    const subjectClosure = await getJournalSubjectClosureState(Number(column.subject_id));
    if (subjectClosure.is_closed) {
      return res.redirect(buildJournalClosedRedirectPath(column.subject_id));
    }

    const studentRow = await getJournalStudentGroup(column.subject_id, studentId);
    if (!studentRow) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&err=Student%20is%20not%20assigned%20to%20subject`);
    }

    if (!journalScope.fullAccess) {
      const access = await getTeacherJournalSubjectAccess(Number(req.session.user.id), Number(column.subject_id));
      if (!access.hasRows) {
        return res.status(403).send('Forbidden (journal)');
      }
      const studentGroup = Number(studentRow.group_number || 0);
      if (!access.allowAll && !access.groups.has(studentGroup)) {
        return res.status(403).send('Forbidden (journal)');
      }
      const homeworkGroup = Number(column.homework_group_number || 0);
      if (column.source_homework_id && homeworkGroup > 0 && !access.allowAll && !access.groups.has(homeworkGroup)) {
        return res.status(403).send('Forbidden (journal)');
      }
    }

    await db.run(
      `
        INSERT INTO competency_evaluations
          (
            course_id,
            semester_id,
            subject_id,
            column_id,
            student_id,
            competency_key,
            score,
            note,
            source_type,
            created_by,
            created_at,
            updated_at
          )
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, 'manual', ?, NOW(), NOW())
      `,
      [
        Number(column.course_id || 0) || null,
        column.semester_id ? Number(column.semester_id) : null,
        Number(column.subject_id || 0),
        columnId,
        studentId,
        competencyKey,
        score,
        note || null,
        Number(req.session.user.id),
      ]
    );

    logActivity(
      db,
      req,
      'journal_competency_add',
      'competency_evaluation',
      null,
      {
        subject_id: Number(column.subject_id),
        column_id: columnId,
        student_id: studentId,
        competency_key: competencyKey,
        score,
      },
      Number(column.course_id || req.session.user.course_id || 1),
      column.semester_id ? Number(column.semester_id) : null
    );
    return res.redirect(
      `/journal?subject_id=${column.subject_id}&open_column_id=${columnId}&open_student_id=${studentId}&ok=${encodeURIComponent('Компетентнісний сигнал додано')}`
    );
  } catch (err) {
    return res.redirect('/journal?err=Database%20error');
  }
});

app.post('/journal/competency/checklist/save', requireLogin, writeLimiter, async (req, res) => {
  const columnId = Number(req.body.column_id);
  const studentId = Number(req.body.student_id);
  const checkedKeysSet = new Set(normalizeCompetencyKeyArray(req.body.competency_keys));

  if (
    !Number.isFinite(columnId) || columnId < 1
    || !Number.isFinite(studentId) || studentId < 1
  ) {
    return res.redirect('/journal?err=Invalid%20competency%20target');
  }

  try {
    await ensureDbReady();
    const journalScope = await getJournalAccessScope(req);
    const teacherJournalMode = canUseTeacherJournalMode(req, journalScope);
    if (!journalScope.canUseJournal || !teacherJournalMode) {
      return res.status(403).send('Forbidden (journal)');
    }

    const column = await db.get(
      `
        SELECT
          jc.*,
          h.group_number AS homework_group_number
        FROM journal_columns jc
        LEFT JOIN homework h ON h.id = jc.source_homework_id
        WHERE jc.id = ?
        LIMIT 1
      `,
      [columnId]
    );
    if (!column) {
      return res.redirect('/journal?err=Column%20not%20found');
    }
    if (isJournalColumnLocked(column)) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&err=Колонка%20заблокована%20для%20редагування`);
    }
    const subjectClosure = await getJournalSubjectClosureState(Number(column.subject_id));
    if (subjectClosure.is_closed) {
      return res.redirect(buildJournalClosedRedirectPath(column.subject_id));
    }

    const studentRow = await getJournalStudentGroup(column.subject_id, studentId);
    if (!studentRow) {
      return res.redirect(`/journal?subject_id=${column.subject_id}&err=Student%20is%20not%20assigned%20to%20subject`);
    }

    if (!journalScope.fullAccess) {
      const access = await getTeacherJournalSubjectAccess(Number(req.session.user.id), Number(column.subject_id));
      if (!access.hasRows) {
        return res.status(403).send('Forbidden (journal)');
      }
      const studentGroup = Number(studentRow.group_number || 0);
      if (!access.allowAll && !access.groups.has(studentGroup)) {
        return res.status(403).send('Forbidden (journal)');
      }
      const homeworkGroup = Number(column.homework_group_number || 0);
      if (column.source_homework_id && homeworkGroup > 0 && !access.allowAll && !access.groups.has(homeworkGroup)) {
        return res.status(403).send('Forbidden (journal)');
      }
    }

    const competencyKeys = COMPETENCY_DEFINITIONS.map((item) => item.key);
    await withTransaction(async (client) => {
      const query = (sql, params = []) => client.query(convertPlaceholders(sql), params);
      await query(
        `
          DELETE FROM competency_evaluations
          WHERE subject_id = ?
            AND column_id = ?
            AND student_id = ?
            AND source_type = 'checklist'
        `,
        [Number(column.subject_id || 0), columnId, studentId]
      );
      for (const competencyKey of competencyKeys) {
        const score = checkedKeysSet.has(competencyKey) ? 1 : 0;
        await query(
          `
            INSERT INTO competency_evaluations
              (
                course_id,
                semester_id,
                subject_id,
                column_id,
                student_id,
                competency_key,
                score,
                note,
                source_type,
                created_by,
                created_at,
                updated_at
              )
            VALUES (?, ?, ?, ?, ?, ?, ?, NULL, 'checklist', ?, NOW(), NOW())
          `,
          [
            Number(column.course_id || 0) || null,
            column.semester_id ? Number(column.semester_id) : null,
            Number(column.subject_id || 0),
            columnId,
            studentId,
            competencyKey,
            score,
            Number(req.session.user.id),
          ]
        );
      }
    });

    logActivity(
      db,
      req,
      'journal_competency_checklist_save',
      'competency_evaluation',
      null,
      {
        subject_id: Number(column.subject_id),
        column_id: columnId,
        student_id: studentId,
        checked_keys: Array.from(checkedKeysSet),
        updated_keys_total: competencyKeys.length,
      },
      Number(column.course_id || req.session.user.course_id || 1),
      column.semester_id ? Number(column.semester_id) : null
    );
    return res.redirect(
      `/journal?subject_id=${column.subject_id}&open_column_id=${columnId}&open_student_id=${studentId}&ok=${encodeURIComponent('Компетентності збережено (+1/+0)')}`
    );
  } catch (err) {
    return res.redirect('/journal?err=Database%20error');
  }
});

app.post('/journal/columns/final-toggle', requireLogin, writeLimiter, async (req, res) => {
  const subjectId = Number(req.body.subject_id);
  const columnId = Number(req.body.column_id);
  const includeInFinal = parseBinaryFlag(req.body.include_in_final, 1) === 1 ? 1 : 0;
  if (!Number.isFinite(subjectId) || subjectId < 1 || !Number.isFinite(columnId) || columnId < 1) {
    return res.redirect('/journal?err=Invalid%20column%20target');
  }

  try {
    await ensureDbReady();
    const journalScope = await getJournalAccessScope(req);
    const teacherJournalMode = canUseTeacherJournalMode(req, journalScope);
    if (!journalScope.canUseJournal || !teacherJournalMode) {
      return res.status(403).send('Forbidden (journal)');
    }

    const column = await db.get(
      `
        SELECT
          jc.id,
          jc.subject_id,
          jc.course_id,
          jc.semester_id,
          jc.source_homework_id,
          h.group_number AS homework_group_number
        FROM journal_columns jc
        LEFT JOIN homework h ON h.id = jc.source_homework_id
        WHERE jc.id = ?
          AND jc.subject_id = ?
          AND COALESCE(jc.is_archived, 0) = 0
        LIMIT 1
      `,
      [columnId, subjectId]
    );
    if (!column) {
      return res.redirect(`/journal?subject_id=${subjectId}&err=Column%20not%20found`);
    }
    const subjectClosure = await getJournalSubjectClosureState(Number(column.subject_id));
    if (subjectClosure.is_closed) {
      return res.redirect(buildJournalClosedRedirectPath(column.subject_id));
    }

    if (!journalScope.fullAccess) {
      const access = await getTeacherJournalSubjectAccess(Number(req.session.user.id), subjectId);
      if (!access.hasRows) {
        return res.status(403).send('Forbidden (journal)');
      }
      const homeworkGroup = Number(column.homework_group_number || 0);
      if (column.source_homework_id && homeworkGroup > 0 && !access.allowAll && !access.groups.has(homeworkGroup)) {
        return res.status(403).send('Forbidden (journal)');
      }
    }

    await db.run(
      `
        UPDATE journal_columns
        SET include_in_final = ?,
            updated_at = NOW()
        WHERE id = ?
      `,
      [includeInFinal, columnId]
    );

    logActivity(
      db,
      req,
      'journal_column_toggle_final',
      'journal_column',
      columnId,
      {
        subject_id: subjectId,
        include_in_final: includeInFinal,
      },
      Number(column.course_id || req.session.user.course_id || 1),
      column.semester_id ? Number(column.semester_id) : null
    );
    return res.redirect(`/journal?subject_id=${subjectId}&ok=Налаштування%20колонки%20оновлено`);
  } catch (err) {
    return res.redirect('/journal?err=Database%20error');
  }
});

app.post('/journal/columns/lock-toggle', requireLogin, writeLimiter, async (req, res) => {
  const subjectId = Number(req.body.subject_id);
  const columnId = Number(req.body.column_id);
  const isLocked = parseBinaryFlag(req.body.is_locked, 0) === 1 ? 1 : 0;
  if (!Number.isFinite(subjectId) || subjectId < 1 || !Number.isFinite(columnId) || columnId < 1) {
    return res.redirect('/journal?err=Invalid%20column%20target');
  }

  try {
    await ensureDbReady();
    const journalScope = await getJournalAccessScope(req);
    const teacherJournalMode = canUseTeacherJournalMode(req, journalScope);
    if (!journalScope.canUseJournal || !teacherJournalMode) {
      return res.status(403).send('Forbidden (journal)');
    }

    const column = await db.get(
      `
        SELECT
          jc.id,
          jc.subject_id,
          jc.course_id,
          jc.semester_id,
          jc.source_homework_id,
          h.group_number AS homework_group_number
        FROM journal_columns jc
        LEFT JOIN homework h ON h.id = jc.source_homework_id
        WHERE jc.id = ?
          AND jc.subject_id = ?
          AND COALESCE(jc.is_archived, 0) = 0
        LIMIT 1
      `,
      [columnId, subjectId]
    );
    if (!column) {
      return res.redirect(`/journal?subject_id=${subjectId}&err=Column%20not%20found`);
    }
    const subjectClosure = await getJournalSubjectClosureState(Number(column.subject_id));
    if (subjectClosure.is_closed) {
      return res.redirect(buildJournalClosedRedirectPath(column.subject_id));
    }

    if (!journalScope.fullAccess) {
      const access = await getTeacherJournalSubjectAccess(Number(req.session.user.id), subjectId);
      if (!access.hasRows) {
        return res.status(403).send('Forbidden (journal)');
      }
      const homeworkGroup = Number(column.homework_group_number || 0);
      if (column.source_homework_id && homeworkGroup > 0 && !access.allowAll && !access.groups.has(homeworkGroup)) {
        return res.status(403).send('Forbidden (journal)');
      }
    }

    await db.run(
      `
        UPDATE journal_columns
        SET is_locked = ?,
            locked_by = CASE WHEN ? = 1 THEN ? ELSE NULL END,
            locked_at = CASE WHEN ? = 1 THEN NOW() ELSE NULL END,
            updated_at = NOW()
        WHERE id = ?
      `,
      [isLocked, isLocked, Number(req.session.user.id), isLocked, columnId]
    );

    logActivity(
      db,
      req,
      'journal_column_lock_toggle',
      'journal_column',
      columnId,
      {
        subject_id: subjectId,
        is_locked: isLocked,
      },
      Number(column.course_id || req.session.user.course_id || 1),
      column.semester_id ? Number(column.semester_id) : null
    );
    return res.redirect(`/journal?subject_id=${subjectId}&ok=${isLocked ? 'Колонку%20заблоковано' : 'Колонку%20розблоковано'}`);
  } catch (err) {
    return res.redirect('/journal?err=Database%20error');
  }
});

app.post('/journal/columns/create', requireLogin, writeLimiter, async (req, res) => {
  const subjectId = Number(req.body.subject_id);
  const title = String(req.body.title || '').trim();
  const typeRaw = normalizeColumnType(req.body.column_type);
  const requestedCredit = String(req.body.is_credit || '').toLowerCase();
  const includeInFinal = parseBinaryFlag(req.body.include_in_final, 1) === 1 ? 1 : 0;
  const isCredit = typeRaw === 'credit' || requestedCredit === '1' || requestedCredit === 'true' || requestedCredit === 'on';
  const columnType = isCredit ? 'credit' : typeRaw;

  if (!Number.isFinite(subjectId) || subjectId < 1 || !title) {
    return res.redirect('/journal?err=Invalid%20column%20data');
  }

  try {
    await ensureDbReady();
    const journalScope = await getJournalAccessScope(req);
    const teacherJournalMode = canUseTeacherJournalMode(req, journalScope);
    if (!journalScope.canUseJournal || !teacherJournalMode) {
      return res.status(403).send('Forbidden (journal)');
    }

    const subject = await db.get(
      `
        SELECT id, course_id
        FROM subjects
        WHERE id = ? AND visible = 1
        LIMIT 1
      `,
      [subjectId]
    );
    if (!subject) {
      return res.redirect('/journal?err=Subject%20not%20found');
    }
    const subjectClosure = await getJournalSubjectClosureState(subjectId);
    if (subjectClosure.is_closed) {
      return res.redirect(buildJournalClosedRedirectPath(subjectId));
    }
    if (!journalScope.fullAccess) {
      const access = await getTeacherJournalSubjectAccess(Number(req.session.user.id), subjectId);
      if (!access.hasRows) {
        return res.status(403).send('Forbidden (journal)');
      }
    }

    const courseId = Number(subject.course_id || req.session.user.course_id || 1);
    const activeSemester = await getActiveSemester(courseId);
    const semesterId = activeSemester ? Number(activeSemester.id) : null;
    const gradingSettings = await ensureSubjectGradingSettings(subjectId, courseId, semesterId, Number(req.session.user.id));
    const defaultMax = getDefaultMaxPointsByType(gradingSettings, columnType);
    const maxPoints = parsePositiveDecimal(req.body.max_points, defaultMax);
    if (!Number.isFinite(maxPoints) || maxPoints <= 0) {
      return res.redirect(`/journal?subject_id=${subjectId}&err=Invalid%20max%20points`);
    }

    const positionParams = [subjectId, courseId];
    let positionSql = `
      SELECT COALESCE(MAX(position), 0) AS max_position
      FROM journal_columns
      WHERE subject_id = ?
        AND course_id = ?
        AND COALESCE(is_archived, 0) = 0
        AND COALESCE(is_credit, 0) = ?
    `;
    if (semesterId) {
      positionSql += ' AND (semester_id = ? OR semester_id IS NULL)';
      positionParams.push(isCredit ? 1 : 0, semesterId);
    } else {
      positionSql += ' AND semester_id IS NULL';
      positionParams.push(isCredit ? 1 : 0);
    }
    const positionRow = await db.get(positionSql, positionParams);
    const nextPosition = Number(positionRow?.max_position || 0) + 10;

    await db.run(
      `
        INSERT INTO journal_columns
          (subject_id, course_id, semester_id, source_type, source_homework_id, title, column_type, max_points, position, is_credit, include_in_final, created_by, created_at, updated_at)
        VALUES (?, ?, ?, 'manual', NULL, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
      `,
      [
        subjectId,
        courseId,
        semesterId,
        title,
        columnType,
        maxPoints,
        nextPosition,
        isCredit ? 1 : 0,
        includeInFinal,
        Number(req.session.user.id),
      ]
    );

    logActivity(
      db,
      req,
      'journal_column_create',
      'journal_column',
      null,
      {
        subject_id: subjectId,
        column_type: columnType,
        max_points: maxPoints,
        is_credit: isCredit,
        include_in_final: includeInFinal,
      },
      courseId,
      semesterId
    );
    return res.redirect(`/journal?subject_id=${subjectId}&ok=Колонку%20додано`);
  } catch (err) {
    return res.redirect('/journal?err=Database%20error');
  }
});

app.post('/journal/template/import-previous', requireLogin, writeLimiter, async (req, res) => {
  const subjectId = Number(req.body.subject_id);
  if (!Number.isFinite(subjectId) || subjectId < 1) {
    return res.redirect('/journal?err=Invalid%20subject');
  }

  try {
    await ensureDbReady();
    const journalScope = await getJournalAccessScope(req);
    const teacherJournalMode = canUseTeacherJournalMode(req, journalScope);
    if (!journalScope.canUseJournal || !teacherJournalMode) {
      return res.status(403).send('Forbidden (journal)');
    }

    const subjectOptions = await getJournalSubjectOptionsForUser(req, journalScope, teacherJournalMode);
    const selectedSubject = (subjectOptions || []).find((subject) => Number(subject.subject_id) === subjectId);
    if (!selectedSubject) {
      return res.status(403).send('Forbidden (journal)');
    }

    const courseId = Number(selectedSubject.course_id || req.session.user.course_id || 1);
    const activeSemester = await getActiveSemester(courseId);
    const semesterId = activeSemester ? Number(activeSemester.id) : null;
    if (!Number.isFinite(semesterId) || semesterId < 1) {
      return res.redirect(`/journal?subject_id=${subjectId}&err=${encodeURIComponent('Активний семестр не знайдено')}`);
    }

    const subjectClosure = await getJournalSubjectClosureState(subjectId);
    if (subjectClosure.is_closed) {
      return res.redirect(buildJournalClosedRedirectPath(subjectId));
    }

    const previousSemester = await getPreviousSemesterForCourse(courseId, activeSemester);
    if (!previousSemester || !Number.isFinite(Number(previousSemester.id))) {
      return res.redirect(`/journal?subject_id=${subjectId}&err=${encodeURIComponent('Попередній семестр для імпорту не знайдено')}`);
    }
    const previousSemesterId = Number(previousSemester.id);

    const sourceColumns = await db.all(
      `
        SELECT
          id,
          title,
          column_type,
          max_points,
          include_in_final,
          is_credit,
          position
        FROM journal_columns
        WHERE subject_id = ?
          AND course_id = ?
          AND semester_id = ?
          AND source_type = 'manual'
          AND source_homework_id IS NULL
          AND COALESCE(is_archived, 0) = 0
        ORDER BY COALESCE(is_credit, 0) ASC, COALESCE(position, 0) ASC, id ASC
      `,
      [subjectId, courseId, previousSemesterId]
    );
    if (!Array.isArray(sourceColumns) || !sourceColumns.length) {
      return res.redirect(
        `/journal?subject_id=${subjectId}&err=${encodeURIComponent('У попередньому семестрі немає ручних колонок для імпорту')}`
      );
    }

    const currentColumns = await db.all(
      `
        SELECT
          id,
          title,
          column_type,
          max_points,
          include_in_final,
          is_credit,
          position
        FROM journal_columns
        WHERE subject_id = ?
          AND course_id = ?
          AND semester_id = ?
          AND source_type = 'manual'
          AND source_homework_id IS NULL
          AND COALESCE(is_archived, 0) = 0
      `,
      [subjectId, courseId, semesterId]
    );

    const normalizeTemplateColumnKey = (row) => {
      const title = String(row?.title || '').trim().toLowerCase().replace(/\s+/g, ' ');
      const columnType = normalizeColumnType(row?.column_type);
      const isCredit = Number(row?.is_credit || 0) === 1 ? 1 : 0;
      const includeInFinal = Number(row?.include_in_final ?? 1) === 1 ? 1 : 0;
      const maxPoints = parsePositiveDecimal(row?.max_points, 10);
      return [
        title,
        columnType,
        String(isCredit),
        String(includeInFinal),
        formatJournalClosureCsvNumber(maxPoints),
      ].join('|');
    };

    const existingKeys = new Set((currentColumns || []).map((row) => normalizeTemplateColumnKey(row)));
    let maxNonCreditPosition = 0;
    let maxCreditPosition = 0;
    (currentColumns || []).forEach((row) => {
      const position = Number(row?.position || 0);
      if (Number(row?.is_credit || 0) === 1) {
        if (position > maxCreditPosition) maxCreditPosition = position;
      } else if (position > maxNonCreditPosition) {
        maxNonCreditPosition = position;
      }
    });

    let insertedCount = 0;
    let skippedCount = 0;
    for (const sourceColumn of sourceColumns) {
      const dedupeKey = normalizeTemplateColumnKey(sourceColumn);
      if (existingKeys.has(dedupeKey)) {
        skippedCount += 1;
        continue;
      }
      const isCredit = Number(sourceColumn.is_credit || 0) === 1;
      const nextPosition = isCredit ? (maxCreditPosition + 10) : (maxNonCreditPosition + 10);
      if (isCredit) maxCreditPosition = nextPosition;
      else maxNonCreditPosition = nextPosition;

      await db.run(
        `
          INSERT INTO journal_columns
            (
              subject_id, course_id, semester_id, source_type, source_homework_id,
              title, column_type, max_points, position, is_credit, include_in_final,
              created_by, created_at, updated_at
            )
          VALUES (?, ?, ?, 'manual', NULL, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
        `,
        [
          subjectId,
          courseId,
          semesterId,
          String(sourceColumn.title || '').trim() || 'Колонка',
          normalizeColumnType(sourceColumn.column_type),
          parsePositiveDecimal(sourceColumn.max_points, 10),
          nextPosition,
          isCredit ? 1 : 0,
          Number(sourceColumn.include_in_final ?? 1) === 1 ? 1 : 0,
          Number(req.session.user.id),
        ]
      );
      existingKeys.add(dedupeKey);
      insertedCount += 1;
    }

    if (insertedCount < 1) {
      return res.redirect(
        `/journal?subject_id=${subjectId}&ok=${encodeURIComponent('Шаблон уже актуальний: нових колонок для імпорту немає')}`
      );
    }

    logActivity(
      db,
      req,
      'journal_template_import_previous',
      'journal_column',
      null,
      {
        subject_id: subjectId,
        source_semester_id: previousSemesterId,
        source_semester_title: String(previousSemester.title || ''),
        imported_columns_count: insertedCount,
        skipped_columns_count: skippedCount,
      },
      courseId,
      semesterId
    );
    return res.redirect(
      `/journal?subject_id=${subjectId}&ok=${encodeURIComponent(`Імпортовано ${insertedCount} колонок з попереднього семестру`)}`
    );
  } catch (err) {
    return res.redirect(`/journal?subject_id=${subjectId}&err=Database%20error`);
  }
});

app.post('/journal/config/save', requireLogin, writeLimiter, async (req, res) => {
  const subjectId = Number(req.body.subject_id);
  if (!Number.isFinite(subjectId) || subjectId < 1) {
    return res.redirect('/journal?err=Invalid%20subject');
  }

  try {
    await ensureDbReady();
    const journalScope = await getJournalAccessScope(req);
    const teacherJournalMode = canUseTeacherJournalMode(req, journalScope);
    if (!journalScope.canUseJournal || !teacherJournalMode) {
      return res.status(403).send('Forbidden (journal)');
    }

    const subject = await db.get(
      `
        SELECT id, course_id
        FROM subjects
        WHERE id = ? AND visible = 1
        LIMIT 1
      `,
      [subjectId]
    );
    if (!subject) {
      return res.redirect('/journal?err=Subject%20not%20found');
    }
    const subjectClosure = await getJournalSubjectClosureState(subjectId);
    if (subjectClosure.is_closed) {
      return res.redirect(buildJournalClosedRedirectPath(subjectId));
    }
    if (!journalScope.fullAccess) {
      const access = await getTeacherJournalSubjectAccess(Number(req.session.user.id), subjectId);
      if (!access.hasRows) {
        return res.status(403).send('Forbidden (journal)');
      }
    }

    const courseId = Number(subject.course_id || req.session.user.course_id || 1);
    const activeSemester = await getActiveSemester(courseId);
    const semesterId = activeSemester ? Number(activeSemester.id) : null;

    const nextSettings = {};
    let enabledTypesCount = 0;
    let enabledWeightTotal = 0;
    for (const typeKey of JOURNAL_SCORING_TYPES) {
      const enabledField = `${typeKey}_enabled`;
      const maxField = `${typeKey}_max_points`;
      const weightField = `${typeKey}_weight_points`;

      const enabled = parseBinaryFlag(req.body[enabledField], DEFAULT_SUBJECT_GRADING_SETTINGS[enabledField]);
      const maxPoints = parsePositiveDecimal(req.body[maxField], DEFAULT_SUBJECT_GRADING_SETTINGS[maxField]);
      const weightPoints = parseNonNegativeDecimal(req.body[weightField], DEFAULT_SUBJECT_GRADING_SETTINGS[weightField]);
      if (!Number.isFinite(maxPoints) || maxPoints <= 0 || !Number.isFinite(weightPoints) || weightPoints < 0) {
        return res.redirect(`/journal?subject_id=${subjectId}&err=Invalid%20grading%20config`);
      }

      nextSettings[enabledField] = enabled;
      nextSettings[maxField] = maxPoints;
      nextSettings[weightField] = weightPoints;

      if (enabled === 1) {
        enabledTypesCount += 1;
        enabledWeightTotal += weightPoints;
      }
    }

    if (enabledTypesCount < 1) {
      return res.redirect(`/journal?subject_id=${subjectId}&err=Enable%20at%20least%20one%20activity%20type`);
    }
    if (enabledWeightTotal > 100.0001) {
      return res.redirect(`/journal?subject_id=${subjectId}&err=Total%20enabled%20weight%20cannot%20exceed%20100`);
    }

    await db.run(
      `
        INSERT INTO subject_grading_settings
          (
            subject_id, course_id, semester_id,
            homework_enabled, seminar_enabled, exam_enabled, credit_enabled, custom_enabled,
            homework_max_points, seminar_max_points, exam_max_points, credit_max_points, custom_max_points,
            homework_weight_points, seminar_weight_points, exam_weight_points, credit_weight_points, custom_weight_points,
            final_max_points, created_by, created_at, updated_by, updated_at
          )
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 100, ?, NOW(), ?, NOW())
        ON CONFLICT (subject_id)
        DO UPDATE SET
          course_id = EXCLUDED.course_id,
          semester_id = EXCLUDED.semester_id,
          homework_enabled = EXCLUDED.homework_enabled,
          seminar_enabled = EXCLUDED.seminar_enabled,
          exam_enabled = EXCLUDED.exam_enabled,
          credit_enabled = EXCLUDED.credit_enabled,
          custom_enabled = EXCLUDED.custom_enabled,
          homework_max_points = EXCLUDED.homework_max_points,
          seminar_max_points = EXCLUDED.seminar_max_points,
          exam_max_points = EXCLUDED.exam_max_points,
          credit_max_points = EXCLUDED.credit_max_points,
          custom_max_points = EXCLUDED.custom_max_points,
          homework_weight_points = EXCLUDED.homework_weight_points,
          seminar_weight_points = EXCLUDED.seminar_weight_points,
          exam_weight_points = EXCLUDED.exam_weight_points,
          credit_weight_points = EXCLUDED.credit_weight_points,
          custom_weight_points = EXCLUDED.custom_weight_points,
          final_max_points = 100,
          updated_by = EXCLUDED.updated_by,
          updated_at = EXCLUDED.updated_at
      `,
      [
        subjectId,
        courseId,
        semesterId,
        nextSettings.homework_enabled,
        nextSettings.seminar_enabled,
        nextSettings.exam_enabled,
        nextSettings.credit_enabled,
        nextSettings.custom_enabled,
        nextSettings.homework_max_points,
        nextSettings.seminar_max_points,
        nextSettings.exam_max_points,
        nextSettings.credit_max_points,
        nextSettings.custom_max_points,
        nextSettings.homework_weight_points,
        nextSettings.seminar_weight_points,
        nextSettings.exam_weight_points,
        nextSettings.credit_weight_points,
        nextSettings.custom_weight_points,
        Number(req.session.user.id),
        Number(req.session.user.id),
      ]
    );

    logActivity(
      db,
      req,
      'journal_grading_config_update',
      'subject_grading_settings',
      subjectId,
      {
        ...nextSettings,
        enabled_weight_total: Math.round(enabledWeightTotal * 100) / 100,
        final_max_points: 100,
      },
      courseId,
      semesterId
    );
    return res.redirect(`/journal?subject_id=${subjectId}&ok=Налаштування%20оцінювання%20оновлено`);
  } catch (err) {
    return res.redirect('/journal?err=Database%20error');
  }
});

app.get('/subjects', requireLogin, async (req, res) => {
  const { id: userId, username, role, course_id: fallbackCourseId } = req.session.user;
  const requestedSubjectId = Number(req.query.subject_id);
  const selectedSubjectId = Number.isFinite(requestedSubjectId) && requestedSubjectId > 0
    ? requestedSubjectId
    : null;
  const isTeacherMode = hasSessionRole(req, 'teacher');

  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'subjects.init');
  }

  try {
    const subjectRows = isTeacherMode
      ? await db.all(
          `
            SELECT ts.subject_id, ts.group_number, s.name AS subject_name, s.group_count,
                   s.course_id, c.name AS course_name
            FROM teacher_subjects ts
            JOIN subjects s ON s.id = ts.subject_id
            JOIN courses c ON c.id = s.course_id
            WHERE ts.user_id = ? AND s.visible = 1
            ORDER BY c.id, s.name
          `,
          [userId]
        )
      : await db.all(
          `
            SELECT sg.subject_id, sg.group_number, s.name AS subject_name, s.group_count,
                   s.course_id, c.name AS course_name
            FROM student_groups sg
            JOIN subjects s ON s.id = sg.subject_id
            JOIN courses c ON c.id = s.course_id
            WHERE sg.student_id = ? AND s.visible = 1
            ORDER BY c.id, s.name
          `,
          [userId]
        );

    const subjectMap = new Map();
    (subjectRows || []).forEach((row) => {
      const subjectKey = Number(row.subject_id);
      if (!subjectMap.has(subjectKey)) {
        subjectMap.set(subjectKey, {
          subject_id: subjectKey,
          subject_name: row.subject_name,
          course_id: Number(row.course_id || fallbackCourseId || 1),
          course_name: row.course_name || '',
          group_count: Math.max(1, Number(row.group_count || 1)),
          has_all_groups: false,
          group_numbers: new Set(),
        });
      }
      const item = subjectMap.get(subjectKey);
      if (row.group_number === null || typeof row.group_number === 'undefined') {
        item.has_all_groups = true;
      } else {
        const groupNum = Number(row.group_number);
        if (Number.isInteger(groupNum) && groupNum > 0) {
          item.group_numbers.add(groupNum);
        }
      }
    });

    const subjects = Array.from(subjectMap.values())
      .map((item) => {
        const groups = Array.from(item.group_numbers).sort((a, b) => a - b);
        let groupLabel = 'Без групи';
        if (item.has_all_groups) {
          groupLabel = 'Усі групи';
        } else if (groups.length === 1) {
          groupLabel = `Група ${groups[0]}`;
        } else if (groups.length > 1) {
          groupLabel = `Групи ${groups.join(', ')}`;
        }
        return {
          ...item,
          group_numbers: groups,
          group_label: groupLabel,
        };
      })
      .sort((a, b) => a.course_id - b.course_id || a.subject_name.localeCompare(b.subject_name));

    const selectedSubject = selectedSubjectId
      ? (subjects.find((subject) => Number(subject.subject_id) === Number(selectedSubjectId)) || null)
      : (subjects[0] || null);

    let materials = [];
    let materialAudienceOptions = [];
    if (selectedSubject) {
      const selectedCourseId = Number(selectedSubject.course_id || fallbackCourseId || 1);
      const activeSemester = await getActiveSemester(selectedCourseId);
      const params = [selectedSubject.subject_id, selectedCourseId];
      let materialsSql = `
        SELECT sm.*, u.full_name AS created_by_name
        FROM subject_materials sm
        JOIN users u ON u.id = sm.created_by
        WHERE sm.subject_id = ? AND sm.course_id = ?
      `;

      if (activeSemester && activeSemester.id) {
        materialsSql += ' AND (sm.semester_id = ? OR sm.semester_id IS NULL)';
        params.push(activeSemester.id);
      } else {
        materialsSql += ' AND sm.semester_id IS NULL';
      }

      if (!isTeacherMode && !selectedSubject.has_all_groups) {
        if (selectedSubject.group_numbers.length) {
          const groupPlaceholders = selectedSubject.group_numbers.map(() => '?').join(',');
          materialsSql += ` AND (sm.group_number IS NULL OR sm.group_number IN (${groupPlaceholders}))`;
          params.push(...selectedSubject.group_numbers);
        } else {
          materialsSql += ' AND sm.group_number IS NULL';
        }
      }

      materialsSql += ' ORDER BY COALESCE(sm.is_syllabus, 0) DESC, sm.created_at DESC, sm.id DESC';
      const materialRows = await db.all(materialsSql, params);
      materials = (materialRows || []).map((row) => {
        const createdAt = row.created_at ? new Date(row.created_at) : null;
        const createdAtLabel = createdAt && !Number.isNaN(createdAt.getTime())
          ? createdAt.toLocaleString('uk-UA', {
              year: 'numeric',
              month: '2-digit',
              day: '2-digit',
              hour: '2-digit',
              minute: '2-digit',
            })
          : String(row.created_at || '');
        return {
          ...row,
          material_type: normalizeSubjectMaterialType(row.material_type),
          is_syllabus: Number(row.is_syllabus || 0) === 1,
          group_label: row.group_number ? `Група ${row.group_number}` : 'Усі групи',
          created_at_label: createdAtLabel,
          can_manage: Number(row.created_by) === Number(userId),
        };
      });

      if (isTeacherMode) {
        const baseGroups = selectedSubject.has_all_groups
          ? Array.from({ length: selectedSubject.group_count }, (_v, index) => index + 1)
          : selectedSubject.group_numbers;
        const sortedGroups = Array.from(new Set(baseGroups)).sort((a, b) => a - b);
        if (selectedSubject.has_all_groups || sortedGroups.length > 1) {
          materialAudienceOptions.push({
            value: 'all',
            label: selectedSubject.has_all_groups ? 'Усі групи' : 'Усі мої групи',
          });
        }
        sortedGroups.forEach((groupNum) => {
          materialAudienceOptions.push({ value: String(groupNum), label: `Група ${groupNum}` });
        });
        if (!materialAudienceOptions.length) {
          materialAudienceOptions.push({ value: 'all', label: 'Усі групи' });
        }
      }
    }

    return res.render('subjects', {
      subjects,
      selectedSubjectId: selectedSubject ? selectedSubject.subject_id : null,
      selectedSubject,
      materials,
      materialAudienceOptions,
      messages: res.locals.messages,
      username,
      role,
      isTeacherMode,
    });
  } catch (err) {
    return handleDbError(res, err, 'subjects.page');
  }
});

app.post('/subjects/materials', requireLogin, uploadLimiter, upload.single('attachment'), async (req, res) => {
  if (!hasSessionRole(req, 'teacher')) {
    if (req.file) {
      fs.unlink(req.file.path, () => {});
    }
    return res.redirect('/subjects?err=Only%20teachers%20can%20add%20materials');
  }

  const userId = Number(req.session.user.id);
  const subjectId = Number(req.body.subject_id);
  const title = String(req.body.title || '').trim();
  const description = String(req.body.description || '').trim();
  const { materialType, isSyllabus } = parseSubjectMaterialInputType(req.body.material_type);
  const audienceRaw = String(req.body.group_number || 'all').trim().toLowerCase();
  const rawLinkUrl = String(req.body.link_url || '').trim();
  const linkUrl = normalizeExternalUrl(rawLinkUrl);
  const filePath = req.file ? `/uploads/${req.file.filename}` : null;
  const fileName = req.file ? req.file.originalname : null;

  if (!Number.isFinite(subjectId) || subjectId < 1 || !title || title.length > 180) {
    if (req.file) {
      fs.unlink(req.file.path, () => {});
    }
    return res.redirect(`/subjects?subject_id=${Number.isFinite(subjectId) ? subjectId : ''}&err=Invalid%20material%20data`);
  }
  if (description.length > 4000) {
    if (req.file) {
      fs.unlink(req.file.path, () => {});
    }
    return res.redirect(`/subjects?subject_id=${subjectId}&err=Description%20is%20too%20long`);
  }
  if (rawLinkUrl && !linkUrl) {
    if (req.file) {
      fs.unlink(req.file.path, () => {});
    }
    return res.redirect(`/subjects?subject_id=${subjectId}&err=Invalid%20link%20URL`);
  }
  if (!description && !linkUrl && !req.file) {
    if (req.file) {
      fs.unlink(req.file.path, () => {});
    }
    return res.redirect(`/subjects?subject_id=${subjectId}&err=Add%20description,%20link%20or%20file`);
  }
  if (materialType === 'file' && !req.file) {
    return res.redirect(`/subjects?subject_id=${subjectId}&err=File%20is%20required%20for%20this%20type`);
  }
  if (materialType === 'link' && !linkUrl) {
    if (req.file) {
      fs.unlink(req.file.path, () => {});
    }
    return res.redirect(`/subjects?subject_id=${subjectId}&err=Link%20is%20required%20for%20this%20type`);
  }

  try {
    const subjectRow = await db.get(
      'SELECT id, group_count, course_id FROM subjects WHERE id = ? AND visible = 1',
      [subjectId]
    );
    if (!subjectRow) {
      if (req.file) {
        fs.unlink(req.file.path, () => {});
      }
      return res.redirect('/subjects?err=Invalid%20subject');
    }

    const selectedCourseId = Number(subjectRow.course_id || req.session.user.course_id || 1);
    const teacherRows = await db.all(
      'SELECT group_number FROM teacher_subjects WHERE user_id = ? AND subject_id = ?',
      [userId, subjectId]
    );
    const teacherAccess = buildTeacherSubjectAccess(teacherRows || [], Number(subjectRow.group_count || 1));
    if (!teacherAccess.hasRows) {
      if (req.file) {
        fs.unlink(req.file.path, () => {});
      }
      return res.redirect(`/subjects?subject_id=${subjectId}&err=No%20access%20to%20subject`);
    }

    let targetGroups = [];
    if (!audienceRaw || audienceRaw === 'all') {
      if (teacherAccess.allowAll) {
        targetGroups = [null];
      } else {
        targetGroups = Array.from(teacherAccess.groups || []).sort((a, b) => a - b);
      }
    } else {
      const targetGroupNumber = Number(audienceRaw);
      if (!Number.isInteger(targetGroupNumber) || targetGroupNumber < 1 || targetGroupNumber > Number(subjectRow.group_count || 1)) {
        if (req.file) {
          fs.unlink(req.file.path, () => {});
        }
        return res.redirect(`/subjects?subject_id=${subjectId}&err=Invalid%20target%20group`);
      }
      if (!teacherAccess.allowAll && !teacherAccess.groups.has(targetGroupNumber)) {
        if (req.file) {
          fs.unlink(req.file.path, () => {});
        }
        return res.redirect(`/subjects?subject_id=${subjectId}&err=No%20access%20to%20target%20group`);
      }
      targetGroups = [targetGroupNumber];
    }
    if (!targetGroups.length) {
      if (req.file) {
        fs.unlink(req.file.path, () => {});
      }
      return res.redirect(`/subjects?subject_id=${subjectId}&err=No%20available%20groups%20for%20material`);
    }

    const createdAt = new Date().toISOString();
    const activeSemester = await getActiveSemester(selectedCourseId);
    const createdIds = [];
    for (const groupNumber of targetGroups) {
      const inserted = await db.get(
        `
          INSERT INTO subject_materials
          (subject_id, group_number, title, description, material_type, is_syllabus, link_url, file_path, file_name, created_by, created_at, updated_at, course_id, semester_id)
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
          RETURNING id
        `,
        [
          subjectId,
          groupNumber,
          title,
          description || null,
          materialType,
          isSyllabus,
          linkUrl || null,
          filePath,
          fileName,
          userId,
          createdAt,
          createdAt,
          selectedCourseId,
          activeSemester ? activeSemester.id : null,
        ]
      );
      if (!inserted || !inserted.id) {
        throw new Error('Material insert failed');
      }
      createdIds.push(Number(inserted.id));
    }

    logAction(db, req, 'subject_material_create', {
      subject_id: subjectId,
      material_type: materialType,
      is_syllabus: isSyllabus === 1,
      copies: createdIds.length,
      has_file: Boolean(filePath),
      has_link: Boolean(linkUrl),
    });
    logActivity(
      db,
      req,
      'subject_material_create',
      'subject_material',
      createdIds[0] || null,
      {
        subject_id: subjectId,
        material_type: materialType,
        is_syllabus: isSyllabus === 1,
        copies: createdIds.length,
      },
      selectedCourseId,
      activeSemester ? activeSemester.id : null
    );
    broadcast('subject_materials_updated', { subject_id: subjectId });
    return res.redirect(`/subjects?subject_id=${subjectId}&ok=Матеріал%20додано`);
  } catch (err) {
    if (req.file) {
      fs.unlink(req.file.path, () => {});
    }
    console.error('Failed to create subject material', err);
    return res.redirect(`/subjects?subject_id=${subjectId}&err=Database%20error`);
  }
});

app.post('/subjects/materials/:id/delete', requireLogin, writeLimiter, async (req, res) => {
  if (!hasSessionRole(req, 'teacher') && !hasSessionRole(req, 'admin')) {
    return res.redirect('/subjects?err=Only%20teachers%20can%20delete%20materials');
  }

  const materialId = Number(req.params.id);
  if (!Number.isFinite(materialId) || materialId < 1) {
    return res.redirect('/subjects?err=Invalid%20material');
  }

  try {
    const material = await db.get(
      `
        SELECT id, subject_id, group_number, file_path, created_by, course_id, semester_id
        FROM subject_materials
        WHERE id = ?
      `,
      [materialId]
    );
    if (!material) {
      return res.redirect('/subjects?err=Material%20not%20found');
    }

    const userId = Number(req.session.user.id);
    const isAdmin = hasSessionRole(req, 'admin');
    if (!isAdmin && Number(material.created_by) !== userId) {
      return res.redirect(`/subjects?subject_id=${material.subject_id}&err=You%20can%20delete%20only%20your%20materials`);
    }
    if (!isAdmin) {
      const teacherAccess = await db.get(
        'SELECT 1 FROM teacher_subjects WHERE user_id = ? AND subject_id = ? LIMIT 1',
        [userId, material.subject_id]
      );
      if (!teacherAccess) {
        return res.redirect(`/subjects?subject_id=${material.subject_id}&err=No%20access%20to%20subject`);
      }
    }

    await db.run('DELETE FROM subject_materials WHERE id = ?', [materialId]);
    if (material.file_path) {
      const references = await db.get(
        'SELECT COUNT(*)::int AS count FROM subject_materials WHERE file_path = ?',
        [material.file_path]
      );
      if (Number(references?.count || 0) === 0) {
        const relativePath = String(material.file_path).replace(/^\/+/, '');
        const absolutePath = path.join(__dirname, relativePath);
        fs.unlink(absolutePath, () => {});
      }
    }

    logAction(db, req, 'subject_material_delete', {
      subject_id: material.subject_id,
      material_id: materialId,
    });
    logActivity(
      db,
      req,
      'subject_material_delete',
      'subject_material',
      materialId,
      { subject_id: material.subject_id, group_number: material.group_number },
      Number(material.course_id || req.session.user.course_id || 1),
      Number.isFinite(Number(material.semester_id)) ? Number(material.semester_id) : null
    );
    broadcast('subject_materials_updated', { subject_id: material.subject_id });
    return res.redirect(`/subjects?subject_id=${material.subject_id}&ok=Матеріал%20видалено`);
  } catch (err) {
    console.error('Failed to delete subject material', err);
    return res.redirect('/subjects?err=Database%20error');
  }
});

app.get('/teamwork', requireLogin, async (req, res) => {
  const { id: userId, username, role, course_id: fallbackCourseId } = req.session.user;
  const selectedSubjectIdRaw = req.query.subject_id ? Number(req.query.subject_id) : null;
  const selectedSubjectId = Number.isFinite(selectedSubjectIdRaw) ? selectedSubjectIdRaw : null;
  const isTeacherMode = hasSessionRole(req, 'teacher');
  const activeUserFilter = usersHasIsActive ? ' AND u.is_active = 1' : '';

  try {
    const subjectRows = isTeacherMode
      ? await db.all(
          `
            SELECT ts.subject_id, ts.group_number, s.name AS subject_name, s.group_count,
                   s.course_id, c.name AS course_name
            FROM teacher_subjects ts
            JOIN subjects s ON s.id = ts.subject_id
            JOIN courses c ON c.id = s.course_id
            WHERE ts.user_id = ? AND s.show_in_teamwork = 1 AND s.visible = 1
            ORDER BY c.id, s.name
          `,
          [userId]
        )
      : await db.all(
          `
            SELECT sg.subject_id, sg.group_number, s.name AS subject_name, s.group_count,
                   s.course_id, c.name AS course_name
            FROM student_groups sg
            JOIN subjects s ON s.id = sg.subject_id
            JOIN courses c ON c.id = s.course_id
            WHERE sg.student_id = ? AND s.show_in_teamwork = 1 AND s.visible = 1
            ORDER BY c.id, s.name
          `,
          [userId]
        );

    const subjectMap = new Map();
    (subjectRows || []).forEach((row) => {
      const subjectKey = Number(row.subject_id);
      if (!subjectMap.has(subjectKey)) {
        subjectMap.set(subjectKey, {
          subject_id: subjectKey,
          subject_name: row.subject_name,
          course_id: Number(row.course_id || fallbackCourseId || 1),
          course_name: row.course_name || '',
          group_count: Number(row.group_count || 1),
          has_all_groups: false,
          group_numbers: new Set(),
        });
      }
      const existing = subjectMap.get(subjectKey);
      if (row.group_number === null || typeof row.group_number === 'undefined') {
        existing.has_all_groups = true;
      } else {
        const groupNum = Number(row.group_number);
        if (!Number.isNaN(groupNum) && groupNum > 0) {
          existing.group_numbers.add(groupNum);
        }
      }
    });

    const subjects = Array.from(subjectMap.values())
      .map((item) => {
        const groups = Array.from(item.group_numbers).sort((a, b) => a - b);
        const groupLabel = item.has_all_groups
          ? 'Усі групи'
          : (groups.length ? `Група ${groups.join(', ')}` : '');
        return {
          ...item,
          group_numbers: groups,
          group_label: groupLabel,
        };
      })
      .sort((a, b) => a.course_id - b.course_id || a.subject_name.localeCompare(b.subject_name));

    const selectedSubject = selectedSubjectId
      ? subjects.find((subject) => Number(subject.subject_id) === Number(selectedSubjectId))
      : null;

    if (!selectedSubject) {
      return res.render('teamwork', {
        subjects,
        selectedSubjectId: null,
        selectedSubject: null,
        tasks: [],
        freeStudents: {},
        messages: res.locals.messages,
        username,
        role,
        isTeacherMode,
      });
    }

    const selectedCourseId = Number(selectedSubject.course_id || fallbackCourseId || 1);
    const activeSemester = await getActiveSemester(selectedCourseId);
    const taskFilters = ['t.subject_id = ?', 't.course_id = ?'];
    const taskParams = [selectedSubject.subject_id, selectedCourseId];
    const studentSubjectGroups = isTeacherMode
      ? []
      : (subjectRows || [])
          .filter((row) => Number(row.subject_id) === Number(selectedSubject.subject_id))
          .map((row) => Number(row.group_number))
          .filter((groupNum) => Number.isFinite(groupNum) && groupNum > 0);

    if (activeSemester && activeSemester.id) {
      taskFilters.push('t.semester_id = ?');
      taskParams.push(activeSemester.id);
    } else {
      taskFilters.push('t.semester_id IS NULL');
    }

    if (isTeacherMode) {
      taskFilters.push('t.created_by = ?');
      taskParams.push(userId);
    } else {
      if (!studentSubjectGroups.length) {
        return res.render('teamwork', {
          subjects,
          selectedSubjectId: selectedSubject.subject_id,
          selectedSubject,
          tasks: [],
          freeStudents: {},
          messages: res.locals.messages,
          username,
          role,
          isTeacherMode,
        });
      }

      const groupPlaceholders = studentSubjectGroups.map(() => '?').join(',');
      taskFilters.push(
        `
          EXISTS (
            SELECT 1
            FROM teacher_subjects ts
            WHERE ts.user_id = t.created_by
              AND ts.subject_id = t.subject_id
              AND (ts.group_number IS NULL OR ts.group_number IN (${groupPlaceholders}))
          )
        `
      );
      taskParams.push(...studentSubjectGroups);
    }

    const tasks = await db.all(
      `
        SELECT t.*, s.name AS subject_name, COALESCE(u.full_name, '') AS created_by_name
        FROM teamwork_tasks t
        JOIN subjects s ON s.id = t.subject_id
        LEFT JOIN users u ON u.id = t.created_by${activeUserFilter}
        WHERE ${taskFilters.join(' AND ')}
        ORDER BY t.created_at DESC
      `,
      taskParams
    );

    if (!tasks.length) {
      return res.render('teamwork', {
        subjects,
        selectedSubjectId: selectedSubject.subject_id,
        selectedSubject,
        tasks: [],
        freeStudents: {},
        messages: res.locals.messages,
        username,
        role,
        isTeacherMode,
      });
    }

    const taskIds = tasks.map((task) => task.id);
    const placeholders = taskIds.map(() => '?').join(',');
    const [groups, members, reactionRows, myReactionRows, students, visibilityRows] = await Promise.all([
      db.all(
        `
          SELECT g.*, COALESCE(u.full_name, '') AS leader_name
          FROM teamwork_groups g
          LEFT JOIN users u ON u.id = g.leader_id${activeUserFilter}
          WHERE g.task_id IN (${placeholders})
          ORDER BY g.task_id ASC, g.seminar_group_number NULLS FIRST, g.id ASC
        `,
        taskIds
      ),
      db.all(
        `
          SELECT m.*, u.full_name AS member_name
          FROM teamwork_members m
          JOIN users u ON u.id = m.user_id${activeUserFilter}
          WHERE m.task_id IN (${placeholders})
        `,
        taskIds
      ),
      db.all(
        `
          SELECT task_id, emoji, COUNT(*) AS count
          FROM teamwork_reactions
          WHERE task_id IN (${placeholders})
          GROUP BY task_id, emoji
        `,
        taskIds
      ),
      db.all(
        `
          SELECT task_id, emoji
          FROM teamwork_reactions
          WHERE task_id IN (${placeholders}) AND user_id = ?
        `,
        [...taskIds, userId]
      ),
      db.all(
        `
          SELECT u.id, u.full_name, sg.group_number
          FROM users u
          JOIN student_groups sg ON sg.student_id = u.id
          WHERE sg.subject_id = ? AND u.course_id = ?${activeUserFilter}
          ORDER BY u.full_name ASC
        `,
        [selectedSubject.subject_id, selectedCourseId]
      ),
      db.all(
        `
          SELECT t.id AS task_id, ts.group_number
          FROM teamwork_tasks t
          LEFT JOIN teacher_subjects ts
            ON ts.user_id = t.created_by
           AND ts.subject_id = t.subject_id
          WHERE t.id IN (${placeholders})
        `,
        taskIds
      ),
    ]);

    const groupsByTask = {};
    (groups || []).forEach((group) => {
      if (!groupsByTask[group.task_id]) groupsByTask[group.task_id] = [];
      groupsByTask[group.task_id].push({
        ...group,
        leader_name: String(group.leader_name || '').trim() || '—',
        members: [],
      });
    });

    const membersByTask = {};
    (members || []).forEach((member) => {
      if (!membersByTask[member.task_id]) membersByTask[member.task_id] = new Set();
      membersByTask[member.task_id].add(member.user_id);
      const list = groupsByTask[member.task_id] || [];
      const targetGroup = list.find((group) => Number(group.id) === Number(member.group_id));
      if (targetGroup) {
        targetGroup.members.push(member);
      }
    });

    const reactionMap = {};
    (reactionRows || []).forEach((row) => {
      if (!reactionMap[row.task_id]) reactionMap[row.task_id] = {};
      reactionMap[row.task_id][row.emoji] = Number(row.count || 0);
    });

    const reactedMap = {};
    (myReactionRows || []).forEach((row) => {
      if (!reactedMap[row.task_id]) reactedMap[row.task_id] = {};
      reactedMap[row.task_id][row.emoji] = true;
    });

    const selectedSubjectGroupCount = Math.max(1, Number(selectedSubject.group_count || 1));
    const visibilityRowsByTask = {};
    (visibilityRows || []).forEach((row) => {
      if (!visibilityRowsByTask[row.task_id]) visibilityRowsByTask[row.task_id] = [];
      visibilityRowsByTask[row.task_id].push(row);
    });

    const visibilityByTask = {};
    taskIds.forEach((taskId) => {
      visibilityByTask[taskId] = buildTeacherSubjectAccess(visibilityRowsByTask[taskId] || [], selectedSubjectGroupCount);
    });

    const freeStudents = {};
    const taskData = tasks
      .map((task) => {
        const access = visibilityByTask[task.id] || { hasRows: false, allowAll: true, groups: new Set() };
        const audience = buildTeamworkTaskAudience(task, access, selectedSubjectGroupCount);
        if (!isTeacherMode && !audience.allowAll) {
          const canViewTask = studentSubjectGroups.some((groupNum) => audience.groups.has(Number(groupNum)));
          if (!canViewTask) {
            return null;
          }
        }

        const used = membersByTask[task.id] || new Set();
        const allowedStudentsByAudience = (students || []).filter((student) => {
          if (audience.allowAll) return true;
          return audience.groups.has(Number(student.group_number));
        });
        const studentSeminarGroupSet = new Set(studentSubjectGroups.map((groupNum) => Number(groupNum)));
        const allowedStudents = !isTeacherMode && audience.lessonScope === 'seminar'
          ? allowedStudentsByAudience.filter((student) => studentSeminarGroupSet.has(Number(student.group_number)))
          : allowedStudentsByAudience;
        freeStudents[task.id] = allowedStudents.filter((student) => !used.has(student.id));

        const rawTaskGroups = (groupsByTask[task.id] || []).map((group) => ({
          ...group,
          is_leader: Number(group.leader_id) === Number(userId),
          is_member: group.members.some((member) => Number(member.user_id) === Number(userId)),
        }));
        const currentUserGroup = rawTaskGroups.find((group) => group.is_member);
        const taskGroups = !isTeacherMode && audience.lessonScope === 'seminar'
          ? rawTaskGroups.filter((group) => {
              if (group.is_member) return true;
              const seminarGroupNumber = Number(group.seminar_group_number);
              if (!Number.isInteger(seminarGroupNumber) || seminarGroupNumber < 1) return true;
              return studentSeminarGroupSet.has(seminarGroupNumber);
            })
          : rawTaskGroups;

        const parsedGroupCount = Number(task.group_count || 0);
        const normalizedGroupCount = Number.isFinite(parsedGroupCount) && parsedGroupCount > 0 ? parsedGroupCount : 1;
        const lockEnabled = Number(task.group_lock_enabled) === 1 || task.group_lock_enabled === true;
        const seminarTargetGroupCount = audience.lessonScope === 'seminar'
          ? Math.max(1, Number(audience.groups?.size || 0))
          : 1;
        const maxConfiguredGroupsTotal = normalizedGroupCount * seminarTargetGroupCount;

        return {
          ...task,
          created_by_name: String(task.created_by_name || '').trim() || '—',
          groups: taskGroups,
          random_distribution: Number(task.random_distribution) === 1 || task.random_distribution === true,
          member_limits_enabled: Number(task.member_limits_enabled) === 1 || task.member_limits_enabled === true,
          group_lock_enabled: lockEnabled,
          lesson_scope: audience.lessonScope,
          audience_label: audience.label,
          group_count: normalizedGroupCount,
          current_user_group_id: currentUserGroup ? Number(currentUserGroup.id) : null,
          is_owner: Number(task.created_by) === Number(userId),
          can_create_groups: Number(task.created_by) === Number(userId)
            && (!parsedGroupCount || rawTaskGroups.length < maxConfiguredGroupsTotal),
          reactions: reactionMap[task.id] || {},
          reacted: reactedMap[task.id] || {},
        };
      })
      .filter(Boolean);

    return res.render('teamwork', {
      subjects,
      selectedSubjectId: selectedSubject.subject_id,
      selectedSubject,
      tasks: taskData,
      freeStudents,
      messages: res.locals.messages,
      username,
      role,
      isTeacherMode,
    });
  } catch (err) {
    return res.status(500).send('Database error');
  }
});

app.post('/teamwork/task/create', requireLogin, writeLimiter, async (req, res) => {
  if (!hasSessionRole(req, 'teacher')) {
    return res.redirect('/teamwork?err=Only%20teachers%20can%20create%20tasks');
  }

  const {
    title,
    subject_id,
    due_date,
    random_distribution,
    group_count,
    limit_members_enabled,
    min_members,
    max_members,
    lesson_scope,
    seminar_group_numbers,
    group_lock_enabled,
  } = req.body;
  const subjectId = Number(subject_id);
  const groupCount = Number(group_count);
  const lessonScope = normalizeTeamworkLessonScope(lesson_scope);
  const randomDistributionEnabled = String(random_distribution || '').toLowerCase() === 'on'
    || String(random_distribution || '').toLowerCase() === '1'
    || String(random_distribution || '').toLowerCase() === 'true';
  const limitsEnabled = String(limit_members_enabled || '').toLowerCase() === 'on'
    || String(limit_members_enabled || '').toLowerCase() === '1'
    || String(limit_members_enabled || '').toLowerCase() === 'true';
  const groupLockEnabled = String(group_lock_enabled || '').toLowerCase() === 'on'
    || String(group_lock_enabled || '').toLowerCase() === '1'
    || String(group_lock_enabled || '').toLowerCase() === 'true';
  const minMembers = limitsEnabled ? Number(min_members) : null;
  const maxMembers = limitsEnabled ? Number(max_members) : null;

  if (!title || Number.isNaN(subjectId) || Number.isNaN(groupCount) || groupCount < 1 || groupCount > 12) {
    return res.redirect('/teamwork?err=Missing%20fields');
  }
  if (limitsEnabled && (Number.isNaN(minMembers) || Number.isNaN(maxMembers) || minMembers < 1 || maxMembers < minMembers)) {
    return res.redirect(`/teamwork?subject_id=${subjectId}&err=Invalid%20members%20range`);
  }
  const dueDate = due_date ? String(due_date).slice(0, 10) : null;
  if (dueDate && !/^\d{4}-\d{2}-\d{2}$/.test(dueDate)) {
    return res.redirect('/teamwork?err=Invalid%20date');
  }
  const { id: userId } = req.session.user;
  const createdAt = new Date().toISOString();
  try {
    const subjectRow = await db.get(
      'SELECT id, course_id, group_count FROM subjects WHERE id = ? AND show_in_teamwork = 1 AND visible = 1',
      [subjectId]
    );
    if (!subjectRow) {
      return res.redirect('/teamwork?err=Subject%20not%20available');
    }

    const teacherRows = await db.all(
      'SELECT group_number FROM teacher_subjects WHERE user_id = ? AND subject_id = ?',
      [userId, subjectId]
    );
    if (!teacherRows || !teacherRows.length) {
      return res.redirect('/teamwork?err=Subject%20access%20denied');
    }

    const maxSubjectGroups = Math.max(1, Number(subjectRow.group_count || 1));
    const teacherAccess = buildTeacherSubjectAccess(teacherRows, maxSubjectGroups);
    const baseTargetGroups = teacherAccess.allowAll
      ? Array.from({ length: maxSubjectGroups }, (_value, index) => index + 1)
      : Array.from(teacherAccess.groups || []).sort((a, b) => a - b);
    if (!baseTargetGroups.length) {
      return res.redirect('/teamwork?err=No%20target%20groups');
    }

    let targetGroups = [...baseTargetGroups];
    let seminarGroupNumbersValue = null;
    if (lessonScope === 'seminar') {
      const parsedSeminarGroups = parseTeamworkGroupNumbers(seminar_group_numbers, maxSubjectGroups);
      const requestedSeminarGroups = parsedSeminarGroups.all || !parsedSeminarGroups.groups.length
        ? [...baseTargetGroups]
        : parsedSeminarGroups.groups.filter((groupNum) => baseTargetGroups.includes(groupNum));
      const normalizedSeminarGroups = Array.from(new Set(requestedSeminarGroups)).sort((a, b) => a - b);
      if (!normalizedSeminarGroups.length) {
        return res.redirect(`/teamwork?subject_id=${subjectId}&err=Invalid%20seminar%20groups`);
      }
      targetGroups = normalizedSeminarGroups;
      const coversAllAllowedGroups = targetGroups.length === baseTargetGroups.length
        && targetGroups.every((groupNum, index) => groupNum === baseTargetGroups[index]);
      seminarGroupNumbersValue = coversAllAllowedGroups ? 'all' : serializeTeamworkGroupNumbers(targetGroups);
    }

    const activeSemester = await getActiveSemester(subjectRow.course_id || 1);
    if (!activeSemester) {
      return res.redirect('/teamwork?err=No%20active%20semester');
    }

    const groupPlaceholders = targetGroups.map(() => '?').join(',');
    const activeUserFilter = usersHasIsActive ? ' AND u.is_active = 1' : '';
    const students = await db.all(
      `
        SELECT DISTINCT u.id, u.full_name, sg.group_number
        FROM users u
        JOIN student_groups sg ON sg.student_id = u.id
        WHERE sg.subject_id = ? AND u.course_id = ?${activeUserFilter} AND sg.group_number IN (${groupPlaceholders})
        ORDER BY u.id ASC
      `,
      [subjectId, subjectRow.course_id || 1, ...targetGroups]
    );

    const seminarGroupOrder = lessonScope === 'seminar'
      ? [...targetGroups].sort((a, b) => a - b)
      : [];
    const studentsBySeminarGroup = new Map();
    if (lessonScope === 'seminar') {
      seminarGroupOrder.forEach((seminarGroup) => {
        studentsBySeminarGroup.set(seminarGroup, []);
      });
      students.forEach((student) => {
        const seminarGroup = Number(student.group_number);
        if (!studentsBySeminarGroup.has(seminarGroup)) return;
        studentsBySeminarGroup.get(seminarGroup).push(student);
      });
    }

    if (limitsEnabled) {
      if (lessonScope === 'seminar') {
        for (const seminarGroup of seminarGroupOrder) {
          const seminarStudents = studentsBySeminarGroup.get(seminarGroup) || [];
          const seminarStudentCount = seminarStudents.length;
          if (maxMembers * groupCount < seminarStudentCount) {
            return res.redirect(`/teamwork?subject_id=${subjectId}&err=Group%20capacity%20too%20low%20for%20seminar%20group%20${seminarGroup}`);
          }
          if (randomDistributionEnabled && seminarStudentCount > 0 && minMembers * groupCount > seminarStudentCount) {
            return res.redirect(`/teamwork?subject_id=${subjectId}&err=Too%20few%20students%20for%20minimum%20in%20seminar%20group%20${seminarGroup}`);
          }
        }
      } else {
        if (maxMembers * groupCount < students.length) {
          return res.redirect(`/teamwork?subject_id=${subjectId}&err=Group%20capacity%20too%20low`);
        }
        if (randomDistributionEnabled && minMembers * groupCount > students.length) {
          return res.redirect(`/teamwork?subject_id=${subjectId}&err=Too%20few%20students%20for%20minimum`);
        }
      }
    }

    const lectureDistribution = randomDistributionEnabled && lessonScope !== 'seminar'
      ? buildTeamworkRandomDistribution({
          students,
          bucketCount: groupCount,
          limitsEnabled,
          minMembers,
          maxMembers,
        })
      : null;
    if (randomDistributionEnabled && lessonScope !== 'seminar' && !lectureDistribution) {
      return res.redirect(`/teamwork?subject_id=${subjectId}&err=Unable%20to%20distribute%20students`);
    }

    const seminarDistributionByGroup = new Map();
    if (randomDistributionEnabled && lessonScope === 'seminar') {
      for (const seminarGroup of seminarGroupOrder) {
        const seminarStudents = studentsBySeminarGroup.get(seminarGroup) || [];
        const seminarDistribution = buildTeamworkRandomDistribution({
          students: seminarStudents,
          bucketCount: groupCount,
          limitsEnabled,
          minMembers,
          maxMembers,
        });
        if (!seminarDistribution) {
          return res.redirect(`/teamwork?subject_id=${subjectId}&err=Unable%20to%20distribute%20seminar%20group%20${seminarGroup}`);
        }
        seminarDistributionByGroup.set(seminarGroup, seminarDistribution);
      }
    }

    const taskRow = await db.get(
      `INSERT INTO teamwork_tasks
        (subject_id, title, created_by, created_at, due_date, course_id, semester_id,
         random_distribution, group_count, member_limits_enabled, min_members, max_members,
         group_lock_enabled, lesson_scope, seminar_group_numbers)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
       RETURNING id`,
      [
        subjectId,
        title.trim(),
        userId,
        createdAt,
        dueDate,
        subjectRow.course_id || 1,
        activeSemester.id,
        randomDistributionEnabled ? 1 : 0,
        groupCount,
        limitsEnabled ? 1 : 0,
        limitsEnabled ? minMembers : null,
        limitsEnabled ? maxMembers : null,
        groupLockEnabled ? 1 : 0,
        lessonScope,
        lessonScope === 'seminar' ? seminarGroupNumbersValue : null,
      ]
    );
    if (!taskRow || !taskRow.id) {
      return res.redirect('/teamwork?err=Database%20error');
    }

    const createdGroupsBySeminar = new Map();
    const createdLectureGroups = [];
    if (lessonScope === 'seminar') {
      for (const seminarGroup of seminarGroupOrder) {
        createdGroupsBySeminar.set(seminarGroup, []);
        for (let groupIndex = 0; groupIndex < groupCount; groupIndex += 1) {
          const groupRow = await db.get(
            `INSERT INTO teamwork_groups
              (task_id, name, leader_id, max_members, created_at, seminar_group_number)
             VALUES (?, ?, ?, ?, ?, ?)
             RETURNING id`,
            [
              taskRow.id,
              `Команда ${groupIndex + 1}`,
              userId,
              limitsEnabled ? maxMembers : null,
              createdAt,
              seminarGroup,
            ]
          );
          if (!groupRow || !groupRow.id) {
            return res.redirect(`/teamwork?subject_id=${subjectId}&err=Group%20create%20failed`);
          }
          createdGroupsBySeminar.get(seminarGroup).push(groupRow.id);
          logActivity(
            db,
            req,
            'teamwork_group_create',
            'teamwork_group',
            groupRow.id,
            { task_id: taskRow.id, seminar_group_number: seminarGroup },
            subjectRow.course_id || 1,
            activeSemester.id
          );
        }
      }
    } else {
      for (let groupIndex = 0; groupIndex < groupCount; groupIndex += 1) {
        const groupRow = await db.get(
          `INSERT INTO teamwork_groups
            (task_id, name, leader_id, max_members, created_at, seminar_group_number)
           VALUES (?, ?, ?, ?, ?, ?)
           RETURNING id`,
          [
            taskRow.id,
            `Команда ${groupIndex + 1}`,
            userId,
            limitsEnabled ? maxMembers : null,
            createdAt,
            null,
          ]
        );
        if (!groupRow || !groupRow.id) {
          return res.redirect(`/teamwork?subject_id=${subjectId}&err=Group%20create%20failed`);
        }
        createdLectureGroups.push(groupRow.id);
        logActivity(
          db,
          req,
          'teamwork_group_create',
          'teamwork_group',
          groupRow.id,
          { task_id: taskRow.id },
          subjectRow.course_id || 1,
          activeSemester.id
        );
      }
    }

    if (randomDistributionEnabled) {
      if (lessonScope === 'seminar') {
        for (const seminarGroup of seminarGroupOrder) {
          const seminarGroupIds = createdGroupsBySeminar.get(seminarGroup) || [];
          const seminarDistribution = seminarDistributionByGroup.get(seminarGroup) || [];
          for (let groupIndex = 0; groupIndex < seminarGroupIds.length; groupIndex += 1) {
            const groupId = seminarGroupIds[groupIndex];
            const groupMembers = seminarDistribution[groupIndex] || [];
            for (const student of groupMembers) {
              await db.run(
                'INSERT INTO teamwork_members (task_id, group_id, user_id, joined_at) VALUES (?, ?, ?, ?)',
                [taskRow.id, groupId, student.id, createdAt]
              );
            }
          }
        }
      } else {
        for (let groupIndex = 0; groupIndex < createdLectureGroups.length; groupIndex += 1) {
          const groupId = createdLectureGroups[groupIndex];
          const groupMembers = lectureDistribution[groupIndex] || [];
          for (const student of groupMembers) {
            await db.run(
              'INSERT INTO teamwork_members (task_id, group_id, user_id, joined_at) VALUES (?, ?, ?, ?)',
              [taskRow.id, groupId, student.id, createdAt]
            );
          }
        }
      }
    }

    logActivity(
      db,
      req,
      'teamwork_task_create',
      'teamwork_task',
      taskRow.id,
      {
        subject_id: subjectId,
        group_count: groupCount,
        random_distribution: randomDistributionEnabled,
        member_limits_enabled: limitsEnabled,
        group_lock_enabled: groupLockEnabled,
        lesson_scope: lessonScope,
        seminar_groups: lessonScope === 'seminar' ? (seminarGroupNumbersValue || 'all') : null,
      },
      subjectRow.course_id || 1,
      activeSemester.id
    );

    return res.redirect(`/teamwork?subject_id=${subjectId}`);
  } catch (err) {
    return res.redirect('/teamwork?err=Database%20error');
  }
});

app.post('/teamwork/group/create', requireLogin, writeLimiter, async (req, res) => {
  if (!hasSessionRole(req, 'teacher')) {
    return res.redirect('/teamwork?err=Only%20teachers%20can%20create%20groups');
  }
  const { task_id, name, max_members } = req.body;
  const taskId = Number(task_id);
  const requestedMaxMembers = max_members ? Number(max_members) : null;
  if (Number.isNaN(taskId)) {
    return res.redirect('/teamwork?err=Invalid%20task');
  }
  const { id: userId } = req.session.user;
  const createdAt = new Date().toISOString();
  try {
    const taskRow = await db.get(
      `SELECT t.id, t.subject_id, t.created_by, t.group_count, t.member_limits_enabled, t.max_members,
              t.lesson_scope, t.seminar_group_numbers, s.group_count AS subject_group_count
       FROM teamwork_tasks t
       JOIN subjects s ON s.id = t.subject_id
       WHERE t.id = ?`,
      [taskId]
    );
    if (!taskRow) {
      return res.redirect('/teamwork?err=Task%20not%20found');
    }
    if (Number(taskRow.created_by) !== Number(userId)) {
      return res.redirect(`/teamwork?subject_id=${taskRow.subject_id}&err=Only%20task%20owner%20can%20create%20group`);
    }

    const countRow = await db.get('SELECT COUNT(*) AS cnt FROM teamwork_groups WHERE task_id = ?', [taskId]);
    const nextIndex = (countRow && countRow.cnt ? Number(countRow.cnt) : 0) + 1;
    const lessonScope = normalizeTeamworkLessonScope(taskRow.lesson_scope);
    let maxConfiguredGroups = Number(taskRow.group_count || 0);
    let seminarGroupNumberForNew = null;
    let seminarGroupLocalIndex = nextIndex;
    if (lessonScope === 'seminar') {
      const teacherRows = await db.all(
        'SELECT group_number FROM teacher_subjects WHERE user_id = ? AND subject_id = ?',
        [taskRow.created_by, taskRow.subject_id]
      );
      const teacherAccess = buildTeacherSubjectAccess(teacherRows || [], taskRow.subject_group_count || 1);
      const audience = buildTeamworkTaskAudience(taskRow, teacherAccess, taskRow.subject_group_count || 1);
      const seminarGroups = Array.from(audience.groups || []).sort((a, b) => a - b);
      if (!seminarGroups.length) {
        return res.redirect(`/teamwork?subject_id=${taskRow.subject_id}&err=No%20seminar%20groups%20configured`);
      }
      maxConfiguredGroups = maxConfiguredGroups * seminarGroups.length;

      const existingBySeminar = await db.all(
        `
          SELECT seminar_group_number, COUNT(*) AS cnt
          FROM teamwork_groups
          WHERE task_id = ?
          GROUP BY seminar_group_number
        `,
        [taskId]
      );
      const seminarCounts = new Map();
      seminarGroups.forEach((groupNum) => {
        seminarCounts.set(groupNum, 0);
      });
      (existingBySeminar || []).forEach((row) => {
        const groupNum = Number(row.seminar_group_number);
        if (!seminarCounts.has(groupNum)) return;
        seminarCounts.set(groupNum, Number(row.cnt || 0));
      });

      seminarGroupNumberForNew = seminarGroups[0];
      seminarGroups.forEach((groupNum) => {
        const bestCount = Number(seminarCounts.get(seminarGroupNumberForNew) || 0);
        const currentCount = Number(seminarCounts.get(groupNum) || 0);
        if (currentCount < bestCount) {
          seminarGroupNumberForNew = groupNum;
        }
      });
      seminarGroupLocalIndex = Number(seminarCounts.get(seminarGroupNumberForNew) || 0) + 1;
    }

    if (maxConfiguredGroups > 0 && nextIndex > maxConfiguredGroups) {
      return res.redirect(`/teamwork?subject_id=${taskRow.subject_id}&err=Group%20limit%20reached`);
    }

    const groupName = name && name.trim().length ? name.trim() : `Команда ${seminarGroupLocalIndex}`;
    const limitsEnabled = Number(taskRow.member_limits_enabled) === 1 || taskRow.member_limits_enabled === true;
    let resolvedMaxMembers = null;
    if (limitsEnabled) {
      resolvedMaxMembers = taskRow.max_members ? Number(taskRow.max_members) : null;
    } else if (requestedMaxMembers && !Number.isNaN(requestedMaxMembers) && requestedMaxMembers > 0) {
      resolvedMaxMembers = requestedMaxMembers;
    }

    const groupRow = await db.get(
      `INSERT INTO teamwork_groups
        (task_id, name, leader_id, max_members, created_at, seminar_group_number)
       VALUES (?, ?, ?, ?, ?, ?)
       RETURNING id`,
      [taskId, groupName, userId, resolvedMaxMembers, createdAt, seminarGroupNumberForNew]
    );
    if (!groupRow || !groupRow.id) {
      return res.redirect(`/teamwork?subject_id=${taskRow.subject_id}&err=Group%20create%20failed`);
    }
    logActivity(db, req, 'teamwork_group_create', 'teamwork_group', groupRow.id, { task_id: taskId });
    return res.redirect(`/teamwork?subject_id=${taskRow.subject_id}`);
  } catch (err) {
    return res.redirect('/teamwork?err=Database%20error');
  }
});

app.post('/teamwork/group/join', requireLogin, writeLimiter, async (req, res) => {
  if (hasSessionRole(req, 'teacher')) {
    return res.redirect('/teamwork?err=Teachers%20cannot%20join%20student%20groups');
  }

  const { group_id } = req.body;
  const groupId = Number(group_id);
  if (Number.isNaN(groupId)) {
    return res.redirect('/teamwork?err=Invalid%20group');
  }

  const { id: userId } = req.session.user;
  const joinedAt = new Date().toISOString();
  const activeUserFilter = usersHasIsActive ? ' AND u.is_active = 1' : '';
  try {
    const grpRow = await db.get(
      `
        SELECT g.task_id,
               g.max_members,
               g.seminar_group_number,
               t.subject_id,
               t.created_by,
               t.group_lock_enabled,
               t.lesson_scope,
               t.seminar_group_numbers,
               s.group_count AS subject_group_count
        FROM teamwork_groups g
        JOIN teamwork_tasks t ON t.id = g.task_id
        JOIN subjects s ON s.id = t.subject_id
        WHERE g.id = ?
      `,
      [groupId]
    );

    if (!grpRow) {
      return res.redirect('/teamwork?err=Group%20not%20found');
    }

    const sgRow = await db.get(
      'SELECT group_number FROM student_groups WHERE student_id = ? AND subject_id = ?',
      [userId, grpRow.subject_id]
    );
    if (!sgRow) {
      return res.redirect(`/teamwork?subject_id=${grpRow.subject_id}&err=Access%20denied`);
    }

    const teacherRows = await db.all(
      'SELECT group_number FROM teacher_subjects WHERE user_id = ? AND subject_id = ?',
      [grpRow.created_by, grpRow.subject_id]
    );
    if (!teacherRows || !teacherRows.length) {
      return res.redirect(`/teamwork?subject_id=${grpRow.subject_id}&err=Access%20denied`);
    }

    const teacherAccess = buildTeacherSubjectAccess(teacherRows, grpRow.subject_group_count || 1);
    const audience = buildTeamworkTaskAudience(grpRow, teacherAccess, grpRow.subject_group_count || 1);
    if (!audience.allowAll && !audience.groups.has(Number(sgRow.group_number))) {
      return res.redirect(`/teamwork?subject_id=${grpRow.subject_id}&err=Access%20denied`);
    }
    if (normalizeTeamworkLessonScope(grpRow.lesson_scope) === 'seminar') {
      const studentSeminarGroup = Number(sgRow.group_number);
      const targetSeminarGroup = Number(grpRow.seminar_group_number);
      if (Number.isInteger(targetSeminarGroup) && targetSeminarGroup > 0 && targetSeminarGroup !== studentSeminarGroup) {
        return res.redirect(`/teamwork?subject_id=${grpRow.subject_id}&err=This%20group%20belongs%20to%20another%20seminar%20group`);
      }
    }

    const memRow = await db.get(
      'SELECT id FROM teamwork_members WHERE task_id = ? AND user_id = ?',
      [grpRow.task_id, userId]
    );
    if (memRow) {
      const lockEnabled = Number(grpRow.group_lock_enabled) === 1 || grpRow.group_lock_enabled === true;
      if (lockEnabled) {
        return res.redirect(`/teamwork?subject_id=${grpRow.subject_id}&err=Group%20changes%20locked`);
      }
      return res.redirect(`/teamwork?subject_id=${grpRow.subject_id}&err=Already%20in%20group`);
    }

    if (grpRow.max_members) {
      const cntRow = await db.get(
        `
          SELECT COUNT(*) AS cnt
          FROM teamwork_members tm
          JOIN users u ON u.id = tm.user_id
          WHERE tm.group_id = ?${activeUserFilter}
        `,
        [groupId]
      );
      if (Number(cntRow?.cnt || 0) >= Number(grpRow.max_members)) {
        return res.redirect(`/teamwork?subject_id=${grpRow.subject_id}&err=Group%20is%20full`);
      }
    }

    await db.run(
      'INSERT INTO teamwork_members (task_id, group_id, user_id, joined_at) VALUES (?, ?, ?, ?)',
      [grpRow.task_id, groupId, userId, joinedAt]
    );
    return res.redirect(`/teamwork?subject_id=${grpRow.subject_id}`);
  } catch (err) {
    return res.redirect('/teamwork?err=Database%20error');
  }
});

app.post('/teamwork/group/leave', requireLogin, writeLimiter, async (req, res) => {
  const { group_id } = req.body;
  const groupId = Number(group_id);
  if (Number.isNaN(groupId)) {
    return res.redirect('/teamwork?err=Invalid%20group');
  }
  const { id: userId } = req.session.user;
  try {
    const grpRow = await db.get(
      `
        SELECT g.task_id, g.leader_id, t.subject_id, t.group_lock_enabled
        FROM teamwork_groups g
        JOIN teamwork_tasks t ON t.id = g.task_id
        WHERE g.id = ?
      `,
      [groupId]
    );
    if (!grpRow) {
      return res.redirect('/teamwork?err=Group%20not%20found');
    }
    if (grpRow.leader_id === userId) {
      return res.redirect(`/teamwork?subject_id=${grpRow.subject_id}&err=Leader%20cannot%20leave`);
    }

    const lockEnabled = Number(grpRow.group_lock_enabled) === 1 || grpRow.group_lock_enabled === true;
    if (lockEnabled) {
      return res.redirect(`/teamwork?subject_id=${grpRow.subject_id}&err=Group%20changes%20locked`);
    }

    await db.run('DELETE FROM teamwork_members WHERE group_id = ? AND user_id = ?', [groupId, userId]);
    return res.redirect(`/teamwork?subject_id=${grpRow.subject_id}`);
  } catch (err) {
    return res.redirect('/teamwork?err=Database%20error');
  }
});

app.post('/teamwork/group/move-member', requireLogin, writeLimiter, async (req, res) => {
  if (!hasSessionRole(req, 'teacher')) {
    return res.redirect('/teamwork?err=Only%20teachers%20can%20move%20members');
  }

  const taskId = Number(req.body.task_id);
  const userIdToMove = Number(req.body.user_id);
  const targetGroupId = Number(req.body.target_group_id);
  if (Number.isNaN(taskId) || Number.isNaN(userIdToMove) || Number.isNaN(targetGroupId)) {
    return res.redirect('/teamwork?err=Invalid%20move%20request');
  }

  const { id: actorUserId } = req.session.user;
  const activeUserFilter = usersHasIsActive ? ' AND u.is_active = 1' : '';
  try {
    const taskRow = await db.get('SELECT id, subject_id, created_by FROM teamwork_tasks WHERE id = ?', [taskId]);
    if (!taskRow) {
      return res.redirect('/teamwork?err=Task%20not%20found');
    }
    if (Number(taskRow.created_by) !== Number(actorUserId)) {
      return res.redirect(`/teamwork?subject_id=${taskRow.subject_id}&err=Only%20task%20owner%20can%20move%20members`);
    }

    const memberRow = await db.get(
      'SELECT id, group_id FROM teamwork_members WHERE task_id = ? AND user_id = ?',
      [taskId, userIdToMove]
    );
    if (!memberRow) {
      return res.redirect(`/teamwork?subject_id=${taskRow.subject_id}&err=Member%20not%20found`);
    }

    const targetGroupRow = await db.get(
      'SELECT id, max_members FROM teamwork_groups WHERE id = ? AND task_id = ?',
      [targetGroupId, taskId]
    );
    if (!targetGroupRow) {
      return res.redirect(`/teamwork?subject_id=${taskRow.subject_id}&err=Target%20group%20not%20found`);
    }

    if (Number(memberRow.group_id) === Number(targetGroupId)) {
      return res.redirect(`/teamwork?subject_id=${taskRow.subject_id}`);
    }

    if (targetGroupRow.max_members) {
      const countRow = await db.get(
        `
          SELECT COUNT(*) AS cnt
          FROM teamwork_members tm
          JOIN users u ON u.id = tm.user_id
          WHERE tm.group_id = ?${activeUserFilter}
        `,
        [targetGroupId]
      );
      if (Number(countRow?.cnt || 0) >= Number(targetGroupRow.max_members)) {
        return res.redirect(`/teamwork?subject_id=${taskRow.subject_id}&err=Target%20group%20is%20full`);
      }
    }

    await db.run('UPDATE teamwork_members SET group_id = ? WHERE id = ?', [targetGroupId, memberRow.id]);
    return res.redirect(`/teamwork?subject_id=${taskRow.subject_id}`);
  } catch (err) {
    return res.redirect('/teamwork?err=Database%20error');
  }
});

app.post('/teamwork/group/disband', requireLogin, writeLimiter, (req, res) => {
  const { group_id } = req.body;
  const groupId = Number(group_id);
  if (Number.isNaN(groupId)) {
    return res.redirect('/teamwork?err=Invalid%20group');
  }
  const { id: userId } = req.session.user;
  db.get(
    `
      SELECT g.task_id, g.leader_id, t.subject_id
      FROM teamwork_groups g
      JOIN teamwork_tasks t ON t.id = g.task_id
      WHERE g.id = ?
    `,
    [groupId],
    (grpErr, grpRow) => {
      if (grpErr || !grpRow) {
        return res.redirect('/teamwork?err=Group%20not%20found');
      }
      if (grpRow.leader_id !== userId) {
        return res.redirect(`/teamwork?subject_id=${grpRow.subject_id}&err=Only%20leader%20can%20disband`);
      }
      db.run('DELETE FROM teamwork_members WHERE group_id = ?', [groupId], () => {
        db.run('DELETE FROM teamwork_groups WHERE id = ?', [groupId], () => {
          res.redirect(`/teamwork?subject_id=${grpRow.subject_id}`);
        });
      });
    }
  );
});

app.post('/teamwork/group/update', requireLogin, writeLimiter, (req, res) => {
  const { group_id, name, max_members } = req.body;
  const groupId = Number(group_id);
  const requestedMaxMembers = max_members ? Number(max_members) : null;
  if (Number.isNaN(groupId)) {
    return res.redirect('/teamwork?err=Invalid%20group');
  }
  const { id: userId } = req.session.user;
  db.get(
    `
      SELECT g.task_id, g.leader_id, t.subject_id, t.member_limits_enabled, t.max_members AS task_max_members
      FROM teamwork_groups g
      JOIN teamwork_tasks t ON t.id = g.task_id
      WHERE g.id = ?
    `,
    [groupId],
    (grpErr, grpRow) => {
      if (grpErr || !grpRow) {
        return res.redirect('/teamwork?err=Group%20not%20found');
      }
      if (grpRow.leader_id !== userId) {
        return res.redirect(`/teamwork?subject_id=${grpRow.subject_id}&err=Only%20leader%20can%20edit`);
      }
      const newName = name && name.trim().length ? name.trim() : null;
      const limitsEnabled = Number(grpRow.member_limits_enabled) === 1 || grpRow.member_limits_enabled === true;
      let resolvedMaxMembers = null;
      if (limitsEnabled) {
        resolvedMaxMembers = grpRow.task_max_members ? Number(grpRow.task_max_members) : null;
      } else if (requestedMaxMembers && !Number.isNaN(requestedMaxMembers) && requestedMaxMembers > 0) {
        resolvedMaxMembers = requestedMaxMembers;
      }
      db.run(
        'UPDATE teamwork_groups SET name = COALESCE(?, name), max_members = ? WHERE id = ?',
        [newName, resolvedMaxMembers, groupId],
        () => res.redirect(`/teamwork?subject_id=${grpRow.subject_id}`)
      );
    }
  );
});

app.post('/admin/teamwork/delete/:id', requireTeamworkSectionAccess, (req, res) => {
  const taskId = Number(req.params.id);
  if (Number.isNaN(taskId)) {
    return res.redirect('/admin?err=Invalid%20task');
  }
  db.run('DELETE FROM teamwork_members WHERE task_id = ?', [taskId], () => {
    db.run('DELETE FROM teamwork_groups WHERE task_id = ?', [taskId], () => {
      db.run('DELETE FROM teamwork_tasks WHERE id = ?', [taskId], () => {
        logAction(db, req, 'teamwork_task_delete', { id: taskId });
        res.redirect('/admin?ok=Task%20deleted');
      });
    });
  });
});

app.post('/admin/messages/send', requireMessagesSectionAccess, writeLimiter, async (req, res) => {
  if (!settingsCache.allow_messages) {
    return res.redirect('/admin?err=Messages%20disabled');
  }
  const { target_type, target_all, subject_id, group_number, body, user_ids, status, scheduled_at } = req.body;
  if (!body || !body.trim()) {
    return res.redirect('/admin?err=Message%20is%20empty');
  }
  const createdAt = new Date().toISOString();
  const createdBy = req.session.user.id;
  const isAdmin = hasSessionRole(req, 'admin');
  const baseCourseId = isAdmin ? getAdminCourse(req) : Number(req.session.user.course_id || 1);
  const activeSemester = await getActiveSemester(baseCourseId);
  const target = target_type || (String(target_all) === '1' ? 'all' : 'subject');
  const isAllCourses = target === 'all_courses';
  const isAll = target === 'all' || isAllCourses;
  let messageStatus = (status || 'published').toLowerCase();
  if (!['draft', 'scheduled', 'published'].includes(messageStatus)) {
    messageStatus = 'published';
  }
  let scheduledAt = null;
  let publishedAt = createdAt;
  if (messageStatus === 'scheduled') {
    const parsed = scheduled_at ? new Date(scheduled_at) : null;
    if (!parsed || Number.isNaN(parsed.getTime())) {
      return res.redirect('/admin?err=Schedule%20date%20required');
    }
    scheduledAt = parsed.toISOString();
    publishedAt = null;
  }
  if (messageStatus === 'draft') {
    publishedAt = null;
  }
  const subjectId = subject_id ? Number(subject_id) : null;
  const groupNum = group_number ? Number(group_number) : null;
  const users = Array.isArray(user_ids) ? user_ids : user_ids ? [user_ids] : [];
  if (target === 'subject' && (Number.isNaN(subjectId) || Number.isNaN(groupNum))) {
    return res.redirect('/admin?err=Select%20subject%20and%20group');
  }
  if (target === 'users' && !users.length) {
    return res.redirect('/admin?err=Select%20users');
  }
  if (isAllCourses && !isAdmin) {
    return res.redirect('/admin?err=Not%20allowed');
  }
  try {
    if (isAllCourses) {
      const row = await db.get(
        `
          INSERT INTO messages (subject_id, group_number, target_all, body, created_by_id, created_at, course_id, semester_id, status, scheduled_at, published_at)
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id
        `,
        [
          null,
          null,
          1,
          body.trim(),
          createdBy,
          createdAt,
          null,
          null,
          messageStatus,
          scheduledAt,
          publishedAt,
        ]
      );
      if (!row || !row.id) {
        return res.redirect('/admin?err=Database%20error');
      }
      logAction(db, req, 'message_send', {
        target_type: target,
        target_all: true,
        course_scope: 'all',
        course_id: null,
      });
      return res.redirect('/admin?ok=Message%20sent');
    }

    const row = await db.get(
      `
        INSERT INTO messages (subject_id, group_number, target_all, body, created_by_id, created_at, course_id, semester_id, status, scheduled_at, published_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id
      `,
      [
        isAll || target === 'users' ? null : subjectId,
        isAll || target === 'users' ? null : groupNum,
        isAll ? 1 : 0,
        body.trim(),
        createdBy,
        createdAt,
        baseCourseId,
        activeSemester ? activeSemester.id : null,
        messageStatus,
        scheduledAt,
        publishedAt,
      ]
    );
    if (!row || !row.id) {
      return res.redirect('/admin?err=Database%20error');
    }
    const messageId = row.id;
    if (target === 'users' && users.length) {
      await Promise.all(users.map((id) => db.run('INSERT INTO message_targets (message_id, user_id) VALUES (?, ?)', [
        messageId,
        Number(id),
      ])));
      logAction(db, req, 'message_send', {
        target_type: target,
        target_all: isAll,
        subject_id: subjectId,
        group_number: groupNum,
        user_ids: users,
      });
      return res.redirect('/admin?ok=Message%20sent');
    }
    logAction(db, req, 'message_send', {
      target_type: target,
      target_all: isAll,
      subject_id: subjectId,
      group_number: groupNum,
    });
    return res.redirect('/admin?ok=Message%20sent');
  } catch (err) {
    return res.redirect('/admin?err=Database%20error');
  }
});

app.post('/admin/messages/delete/:id', requireMessagesSectionAccess, writeLimiter, (req, res) => {
  if (!settingsCache.allow_messages) {
    return res.redirect('/admin?err=Messages%20disabled');
  }
  const id = Number(req.params.id);
  if (Number.isNaN(id)) {
    return res.redirect('/admin?err=Invalid%20message');
  }
  db.get(
    `
      SELECT id, body, created_by_id, created_at, subject_id, group_number, target_all, status, scheduled_at
      FROM messages
      WHERE id = ?
    `,
    [id],
    (findErr, message) => {
      if (findErr || !message) {
        return res.redirect('/admin?err=Message%20not%20found');
      }
      const deleteIds = [id];
      const isBroadcast =
        Number(message.target_all) === 1 &&
        (message.subject_id === null || typeof message.subject_id === 'undefined') &&
        (message.group_number === null || typeof message.group_number === 'undefined');
      if (!isBroadcast) {
        const placeholders = deleteIds.map(() => '?').join(',');
        const remove = () => {
          db.run(`DELETE FROM message_reads WHERE message_id IN (${placeholders})`, deleteIds, () => {
            db.run(`DELETE FROM message_targets WHERE message_id IN (${placeholders})`, deleteIds, () => {
              db.run(`DELETE FROM message_reactions WHERE message_id IN (${placeholders})`, deleteIds, () => {
                db.run(`DELETE FROM messages WHERE id IN (${placeholders})`, deleteIds, (err) => {
                  if (err) {
                    return res.redirect('/admin?err=Database%20error');
                  }
                  logAction(db, req, 'message_delete', { id, deleted_count: deleteIds.length });
                  return res.redirect('/admin?ok=Message%20deleted');
                });
              });
            });
          });
        };
        return remove();
      }
      const statusKey = message.status || 'published';
      const scheduledKey = message.scheduled_at ? String(message.scheduled_at) : '';
      db.all(
        `
          SELECT id
          FROM messages
          WHERE target_all = 1
            AND subject_id IS NULL
            AND group_number IS NULL
            AND body = ?
            AND created_by_id = ?
            AND created_at = ?
            AND COALESCE(status, 'published') = ?
            AND COALESCE(scheduled_at, '') = ?
        `,
        [
          message.body,
          message.created_by_id,
          message.created_at,
          statusKey,
          scheduledKey,
        ],
        (listErr, rows) => {
          if (!listErr && rows && rows.length) {
            rows.forEach((row) => {
              if (!deleteIds.includes(row.id)) deleteIds.push(row.id);
            });
          }
          const placeholders = deleteIds.map(() => '?').join(',');
          db.run(`DELETE FROM message_reads WHERE message_id IN (${placeholders})`, deleteIds, () => {
            db.run(`DELETE FROM message_targets WHERE message_id IN (${placeholders})`, deleteIds, () => {
              db.run(`DELETE FROM message_reactions WHERE message_id IN (${placeholders})`, deleteIds, () => {
                db.run(`DELETE FROM messages WHERE id IN (${placeholders})`, deleteIds, (err) => {
                  if (err) {
                    return res.redirect('/admin?err=Database%20error');
                  }
                  logAction(db, req, 'message_delete', {
                    id,
                    deleted_count: deleteIds.length,
                    broadcast: true,
                  });
                  return res.redirect('/admin?ok=Message%20deleted');
                });
              });
            });
          });
        }
      );
    }
  );
});

app.get('/messages.json', requireLogin, readLimiter, async (req, res) => {
  if (!settingsCache.allow_messages) {
    return res.json({ messages: [], unread_count: 0 });
  }
  const { id: userId, course_id: courseId } = req.session.user;
  const activeSemester = await getActiveSemester(courseId || 1);
  const filterSubjectId = req.query.subject_id ? Number(req.query.subject_id) : null;
  db.all(
    `
      SELECT sg.subject_id, sg.group_number
      FROM student_groups sg
      JOIN subjects s ON s.id = sg.subject_id
      WHERE sg.student_id = ? AND s.course_id = ?
    `,
    [userId, courseId || 1],
    (sgErr, groups) => {
      if (sgErr) {
        return res.status(500).json({ error: 'Database error' });
      }
      const conditions = [];
      const params = [];
      conditions.push('m.target_all = 1');
      if (groups.length) {
        const groupConditions = groups.map(() => '(m.subject_id = ? AND m.group_number = ?)').join(' OR ');
        groups.forEach((g) => params.push(g.subject_id, g.group_number));
        conditions.push(groupConditions);
      }
      conditions.push('EXISTS (SELECT 1 FROM message_targets mt WHERE mt.message_id = m.id AND mt.user_id = ?)');
      params.push(userId);
      const baseWhere = conditions.length ? `WHERE ${conditions.map((c) => `(${c})`).join(' OR ')}` : '';
      const globalBroadcastScope = '(m.target_all = 1 AND m.subject_id IS NULL AND m.group_number IS NULL)';
      const courseFilter = ` AND (m.course_id = ? OR (${globalBroadcastScope} AND m.course_id IS NULL))`;
      const semesterFilter = activeSemester
        ? ` AND (m.semester_id = ? OR (${globalBroadcastScope} AND m.semester_id IS NULL))`
        : '';
      const statusFilter = " AND COALESCE(m.status, 'published') = 'published' AND (m.scheduled_at IS NULL OR m.scheduled_at <= ?)";
      const subjectFilter = !Number.isNaN(filterSubjectId) ? ' AND m.subject_id = ?' : '';
      const finalParams = [...params, courseId || 1];
      if (activeSemester) {
        finalParams.push(activeSemester.id);
      }
      if (!Number.isNaN(filterSubjectId)) {
        finalParams.push(filterSubjectId);
      }
      finalParams.push(new Date().toISOString());
      db.all(
        `
          SELECT m.*, s.name AS subject_name, u.full_name AS created_by, mr.id AS read_id
          FROM messages m
          LEFT JOIN subjects s ON s.id = m.subject_id
          LEFT JOIN users u ON u.id = m.created_by_id
          LEFT JOIN message_reads mr ON mr.message_id = m.id AND mr.user_id = ?
          ${baseWhere}${courseFilter}${semesterFilter}${subjectFilter}${statusFilter}
          ORDER BY m.created_at DESC
          LIMIT 50
        `,
        [userId, ...finalParams],
        (msgErr, rows) => {
          if (msgErr) {
            return res.status(500).json({ error: 'Database error' });
          }
          const unreadCount = rows.filter((r) => !r.read_id).length;
          if (!rows.length) {
            return res.json({ messages: rows, unread_count: unreadCount });
          }
          const messageIds = rows.map((r) => r.id);
          const placeholders = messageIds.map(() => '?').join(',');
          db.all(
            `SELECT message_id, emoji, COUNT(*) AS count
             FROM message_reactions
             WHERE message_id IN (${placeholders})
             GROUP BY message_id, emoji`,
            messageIds,
            (reactErr, reactRows) => {
              const reactionMap = {};
              if (!reactErr && reactRows) {
                reactRows.forEach((row) => {
                  if (!reactionMap[row.message_id]) reactionMap[row.message_id] = {};
                  reactionMap[row.message_id][row.emoji] = Number(row.count || 0);
                });
              }
              db.all(
                `SELECT message_id, emoji
                 FROM message_reactions
                 WHERE message_id IN (${placeholders}) AND user_id = ?`,
                [...messageIds, userId],
                (myErr, myRows) => {
                  const reactedMap = {};
                  if (!myErr && myRows) {
                    myRows.forEach((row) => {
                      if (!reactedMap[row.message_id]) reactedMap[row.message_id] = {};
                      reactedMap[row.message_id][row.emoji] = true;
                    });
                  }
                  rows.forEach((row) => {
                    row.reactions = reactionMap[row.id] || {};
                    row.reacted = reactedMap[row.id] || {};
                  });
                  return res.json({ messages: rows, unread_count: unreadCount });
                }
              );
            }
          );
        }
      );
    }
  );
});

app.post('/messages/read', requireLogin, writeLimiter, (req, res) => {
  if (!settingsCache.allow_messages) {
    return res.status(403).json({ error: 'Messages disabled' });
  }
  const { message_ids } = req.body;
  const ids = Array.isArray(message_ids) ? message_ids : message_ids ? [message_ids] : [];
  const { id: userId } = req.session.user;
  if (!ids.length) {
    return res.json({ ok: true });
  }
  const readAt = new Date().toISOString();
  const stmt = db.prepare(
    'INSERT INTO message_reads (message_id, user_id, read_at) VALUES (?, ?, ?) ON CONFLICT(message_id, user_id) DO NOTHING'
  );
  ids.forEach((mid) => {
    stmt.run(Number(mid), userId, readAt);
  });
  stmt.finalize(() => res.json({ ok: true }));
});

app.get('/admin/api/messages/:id/reads', requireMessagesSectionAccess, readLimiter, async (req, res) => {
  if (!settingsCache.allow_messages) {
    return res.status(403).json({ error: 'Messages disabled' });
  }
  try {
    await ensureDbReady();
  } catch (err) {
    return res.status(500).json({ error: 'Database error' });
  }
  const messageId = Number(req.params.id);
  if (Number.isNaN(messageId)) {
    return res.status(400).json({ error: 'Invalid message' });
  }
  const courseId = hasSessionRole(req, 'admin') ? getAdminCourse(req) : Number(req.session.user.course_id || 1);
  let activeSemester = null;
  try {
    activeSemester = await getActiveSemester(courseId);
  } catch (err) {
    return res.status(500).json({ error: 'Database error' });
  }
  try {
    const globalBroadcastScope = 'target_all = 1 AND subject_id IS NULL AND group_number IS NULL';
    const message = await db.get(
      `SELECT id, subject_id, group_number, target_all, course_id, semester_id
       FROM messages
       WHERE id = ?
         AND (
           course_id = ?
           OR (${globalBroadcastScope} AND course_id IS NULL)
         )${activeSemester
          ? ` AND (
              semester_id = ?
              OR (${globalBroadcastScope} AND semester_id IS NULL)
            )`
          : ''}`,
      activeSemester ? [messageId, courseId, activeSemester.id] : [messageId, courseId]
    );
    if (!message) {
      return res.status(404).json({ error: 'Not found' });
    }
    const activeFilter = usersHasIsActive ? ' AND u.is_active = 1' : '';
    let recipients = [];
    if (message.target_all === 1) {
      recipients = await db.all(
        `SELECT u.id, u.full_name
         FROM users u
         WHERE u.course_id = ? AND u.role = 'student'${activeFilter}
         ORDER BY u.full_name`,
        [courseId]
      );
    } else if (message.subject_id) {
      recipients = await db.all(
        `SELECT DISTINCT u.id, u.full_name
         FROM student_groups sg
         JOIN users u ON u.id = sg.student_id
         WHERE sg.subject_id = ? AND sg.group_number = ? AND u.course_id = ?${activeFilter}
         ORDER BY u.full_name`,
        [message.subject_id, message.group_number, courseId]
      );
    } else {
      recipients = await db.all(
        `SELECT u.id, u.full_name
         FROM message_targets mt
         JOIN users u ON u.id = mt.user_id
         WHERE mt.message_id = ? AND u.course_id = ?${activeFilter}
         ORDER BY u.full_name`,
        [message.id, courseId]
      );
    }
    const recipientIds = new Set((recipients || []).map((row) => String(row.id)));
    const readRows = await db.all(
      `SELECT mr.user_id, mr.read_at, u.full_name
       FROM message_reads mr
       JOIN users u ON u.id = mr.user_id
       WHERE mr.message_id = ?
       ORDER BY mr.read_at DESC`,
      [message.id]
    );
    const reads = (readRows || [])
      .filter((row) => recipientIds.has(String(row.user_id)))
      .map((row) => ({
        user_id: row.user_id,
        full_name: row.full_name,
        read_at: row.read_at,
      }));
    const readIdSet = new Set(reads.map((row) => String(row.user_id)));
    const unread = (recipients || [])
      .filter((row) => !readIdSet.has(String(row.id)))
      .map((row) => ({ user_id: row.id, full_name: row.full_name }));
    return res.json({
      message_id: message.id,
      target_count: recipients.length,
      read_count: reads.length,
      reads,
      unread,
    });
  } catch (err) {
    return res.status(500).json({ error: 'Database error' });
  }
});

const allowedReactions = new Set(['🔥', '👍']);

app.post('/homework/react', requireLogin, writeLimiter, async (req, res) => {
  const homeworkId = Number(req.body.homework_id);
  const emoji = req.body.emoji;
  const { id: userId } = req.session.user;
  if (Number.isNaN(homeworkId) || !allowedReactions.has(emoji)) {
    return res.status(400).json({ error: 'Invalid data' });
  }
  try {
    const existing = await db.get(
      'SELECT 1 FROM homework_reactions WHERE homework_id = ? AND user_id = ? AND emoji = ?',
      [homeworkId, userId, emoji]
    );
    if (existing) {
      await db.run('DELETE FROM homework_reactions WHERE homework_id = ? AND user_id = ? AND emoji = ?', [
        homeworkId,
        userId,
        emoji,
      ]);
    } else {
      await db.run(
        'INSERT INTO homework_reactions (homework_id, user_id, emoji, created_at) VALUES (?, ?, ?, ?)',
        [homeworkId, userId, emoji, new Date().toISOString()]
      );
    }
    const reactionRows = await db.all(
      'SELECT emoji, COUNT(*) AS count FROM homework_reactions WHERE homework_id = ? GROUP BY emoji',
      [homeworkId]
    );
    const reactedRows = await db.all(
      'SELECT emoji FROM homework_reactions WHERE homework_id = ? AND user_id = ?',
      [homeworkId, userId]
    );
    const reactions = {};
    reactionRows.forEach((row) => {
      reactions[row.emoji] = Number(row.count || 0);
    });
    const reacted = {};
    reactedRows.forEach((row) => {
      reacted[row.emoji] = true;
    });
    return res.json({ ok: true, reactions, reacted });
  } catch (err) {
    return res.status(500).json({ error: 'Database error' });
  }
});

app.post('/messages/react', requireLogin, writeLimiter, async (req, res) => {
  if (!settingsCache.allow_messages) {
    return res.status(403).json({ error: 'Messages disabled' });
  }
  const messageId = Number(req.body.message_id);
  const emoji = req.body.emoji;
  const { id: userId } = req.session.user;
  if (Number.isNaN(messageId) || !allowedReactions.has(emoji)) {
    return res.status(400).json({ error: 'Invalid data' });
  }
  try {
    const existing = await db.get(
      'SELECT 1 FROM message_reactions WHERE message_id = ? AND user_id = ? AND emoji = ?',
      [messageId, userId, emoji]
    );
    if (existing) {
      await db.run('DELETE FROM message_reactions WHERE message_id = ? AND user_id = ? AND emoji = ?', [
        messageId,
        userId,
        emoji,
      ]);
    } else {
      await db.run(
        'INSERT INTO message_reactions (message_id, user_id, emoji, created_at) VALUES (?, ?, ?, ?)',
        [messageId, userId, emoji, new Date().toISOString()]
      );
    }
    const reactionRows = await db.all(
      'SELECT emoji, COUNT(*) AS count FROM message_reactions WHERE message_id = ? GROUP BY emoji',
      [messageId]
    );
    const reactedRows = await db.all(
      'SELECT emoji FROM message_reactions WHERE message_id = ? AND user_id = ?',
      [messageId, userId]
    );
    const reactions = {};
    reactionRows.forEach((row) => {
      reactions[row.emoji] = Number(row.count || 0);
    });
    const reacted = {};
    reactedRows.forEach((row) => {
      reacted[row.emoji] = true;
    });
    return res.json({ ok: true, reactions, reacted });
  } catch (err) {
    return res.status(500).json({ error: 'Database error' });
  }
});

app.post('/teamwork/react', requireLogin, writeLimiter, async (req, res) => {
  const taskId = Number(req.body.task_id);
  const emoji = req.body.emoji;
  const { id: userId } = req.session.user;
  if (Number.isNaN(taskId) || !allowedReactions.has(emoji)) {
    return res.status(400).json({ error: 'Invalid data' });
  }
  try {
    const existing = await db.get(
      'SELECT 1 FROM teamwork_reactions WHERE task_id = ? AND user_id = ? AND emoji = ?',
      [taskId, userId, emoji]
    );
    if (existing) {
      await db.run('DELETE FROM teamwork_reactions WHERE task_id = ? AND user_id = ? AND emoji = ?', [
        taskId,
        userId,
        emoji,
      ]);
    } else {
      await db.run(
        'INSERT INTO teamwork_reactions (task_id, user_id, emoji, created_at) VALUES (?, ?, ?, ?)',
        [taskId, userId, emoji, new Date().toISOString()]
      );
    }
    const reactionRows = await db.all(
      'SELECT emoji, COUNT(*) AS count FROM teamwork_reactions WHERE task_id = ? GROUP BY emoji',
      [taskId]
    );
    const reactedRows = await db.all(
      'SELECT emoji FROM teamwork_reactions WHERE task_id = ? AND user_id = ?',
      [taskId, userId]
    );
    const reactions = {};
    reactionRows.forEach((row) => {
      reactions[row.emoji] = Number(row.count || 0);
    });
    const reacted = {};
    reactedRows.forEach((row) => {
      reacted[row.emoji] = true;
    });
    return res.json({ ok: true, reactions, reacted });
  } catch (err) {
    return res.status(500).json({ error: 'Database error' });
  }
});

app.get('/admin', requireAdminPanelAccess, async (req, res, next) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'init');
  }
  const isAdminPanelOwner = hasSessionRole(req, 'admin');
  const allowedSections = isAdminPanelOwner
    ? null
    : (Array.isArray(req.allowedAdminSections) ? req.allowedAdminSections : []);
  if (!isAdminPanelOwner && !allowedSections.length) {
    return res.status(403).send('Forbidden (update page)');
  }
  const adminViewRole = isAdminPanelOwner
    ? 'admin'
    : (hasSessionRole(req, 'deanery')
      ? 'deanery'
      : (hasSessionRole(req, 'starosta')
        ? 'starosta'
        : normalizeRoleKey(req.session.role || 'student')));
  const courseId = getAdminCourse(req);
  const {
    group_number,
    day,
    subject,
    q,
    sort_schedule,
    sort_homework,
    history_actor,
    history_action,
    history_q,
    history_from,
    history_to,
    users_q,
    users_group,
    homework_from,
    homework_to,
    homework_tag,
    teamwork_subject,
    teamwork_from,
    teamwork_to,
    schedule_date,
  } = req.query;
  const resolvedUsersStatus = 'active';
  const scheduleFilters = [];
  const scheduleParams = [];
  let activeSemester = null;
  try {
    activeSemester = await getActiveSemester(courseId);
  } catch (err) {
    return handleDbError(res, err, 'admin.semester');
  }
  let activeScheduleDays = [];
  try {
    const studyDays = await getCourseStudyDays(courseId);
    activeScheduleDays = (studyDays || [])
      .filter((d) => d.is_active)
      .map((d) => d.day_name)
      .filter(Boolean);
  } catch (err) {
    console.error('Failed to load study days', err);
  }
  if (!activeScheduleDays.length) {
    activeScheduleDays = [...daysOfWeek];
  }

  scheduleFilters.push('se.course_id = ?');
  scheduleParams.push(courseId);
  if (activeSemester) {
    scheduleFilters.push('se.semester_id = ?');
    scheduleParams.push(activeSemester.id);
  }

  if (group_number) {
    scheduleFilters.push('se.group_number = ?');
    scheduleParams.push(group_number);
  }
  if (day) {
    scheduleFilters.push('se.day_of_week = ?');
    scheduleParams.push(day);
  }
  if (subject) {
    scheduleFilters.push('s.name LIKE ?');
    scheduleParams.push(`%${subject}%`);
  }
  if (schedule_date && activeSemester && activeSemester.start_date) {
    const mapped = getWeekDayForDate(schedule_date, activeSemester.start_date);
    if (mapped) {
      scheduleFilters.push('se.week_number = ?');
      scheduleParams.push(mapped.weekNumber);
      scheduleFilters.push('se.day_of_week = ?');
      scheduleParams.push(mapped.dayName);
    }
  }

  const scheduleWhere = scheduleFilters.length ? `WHERE ${scheduleFilters.join(' AND ')}` : '';
  const scheduleSql = `
    SELECT se.*, s.name AS subject_name
    FROM schedule_entries se
    JOIN subjects s ON s.id = se.subject_id
    ${scheduleWhere}
    ORDER BY se.week_number, se.day_of_week, se.class_number
  `;

  let courses = [];
  let semesters = [];
  let teacherRequests = [];
  try {
    courses = await getCoursesCached();
    semesters = await getSemestersCached(courseId);
    teacherRequests = await db.all(
      `
        SELECT tr.user_id, tr.status, tr.created_at,
               u.full_name,
               COALESCE(
                 array_agg(DISTINCT (s.name || ' (' || c.name || ')'))
                   FILTER (WHERE s.id IS NOT NULL),
                 ARRAY[]::text[]
               ) AS subjects
        FROM teacher_requests tr
        JOIN users u ON u.id = tr.user_id
        LEFT JOIN teacher_subjects ts ON ts.user_id = tr.user_id
        LEFT JOIN subjects s ON s.id = ts.subject_id
        LEFT JOIN courses c ON c.id = s.course_id
        GROUP BY tr.user_id, tr.status, tr.created_at, u.full_name
        ORDER BY tr.created_at DESC
      `
    );
  } catch (err) {
    return handleDbError(res, err, 'admin.reference');
  }
  db.all(scheduleSql, scheduleParams, (scheduleErr, scheduleRows) => {
    if (scheduleErr) {
      return handleDbError(res, scheduleErr, 'admin.schedule');
    }
    const schedule = sortSchedule(scheduleRows, sort_schedule);

    const homeworkFilters = [];
    const homeworkParams = [];
    homeworkFilters.push('h.course_id = ?');
    homeworkParams.push(courseId);
  if (activeSemester) {
    homeworkFilters.push('h.semester_id = ?');
    homeworkParams.push(activeSemester.id);
  }
    if (group_number) {
      homeworkFilters.push('h.group_number = ?');
      homeworkParams.push(group_number);
    }
    if (subject) {
      homeworkFilters.push('h.subject LIKE ?');
      homeworkParams.push(`%${subject}%`);
    }
    if (q) {
      homeworkFilters.push('(h.description LIKE ? OR h.created_by LIKE ?)');
      homeworkParams.push(`%${q}%`, `%${q}%`);
    }
    if (homework_from) {
      const start = new Date(homework_from);
      if (!Number.isNaN(start.getTime())) {
        start.setHours(0, 0, 0, 0);
        homeworkFilters.push('h.created_at >= ?');
        homeworkParams.push(start.toISOString());
      }
    }
    if (homework_to) {
      const end = new Date(homework_to);
      if (!Number.isNaN(end.getTime())) {
        end.setHours(23, 59, 59, 999);
        homeworkFilters.push('h.created_at <= ?');
        homeworkParams.push(end.toISOString());
      }
    }
    if (homework_tag) {
      homeworkFilters.push(
        `EXISTS (
          SELECT 1
          FROM homework_tag_map ht
          JOIN homework_tags t ON t.id = ht.tag_id
          WHERE ht.homework_id = h.id AND t.name = ?
        )`
      );
      homeworkParams.push(homework_tag);
    }

    const homeworkWhere = homeworkFilters.length ? `WHERE ${homeworkFilters.join(' AND ')}` : '';
    const homeworkSql = `
      SELECT h.*, subj.name AS subject_name,
             COALESCE(taglist.tags, ARRAY[]::text[]) AS tags
      FROM homework h
      JOIN subjects subj ON subj.id = h.subject_id
      LEFT JOIN LATERAL (
        SELECT array_agg(t.name ORDER BY t.name) AS tags
        FROM homework_tag_map ht
        JOIN homework_tags t ON t.id = ht.tag_id
        WHERE ht.homework_id = h.id
      ) taglist ON true
      ${homeworkWhere}
      ORDER BY h.created_at DESC
    `;

    db.all(homeworkSql, homeworkParams, (homeworkErr, homeworkRows) => {
      if (homeworkErr) {
        return handleDbError(res, homeworkErr, 'admin.homework');
      }
      const homework = sortHomework(homeworkRows, sort_homework);
      db.all('SELECT name FROM homework_tags ORDER BY name', (tagErr, tagRows) => {
        if (tagErr) {
          console.error('Error fetching homework_tags:', tagErr);
          return handleDbError(res, tagErr, 'admin.homework.tags');
        }
        if (res.headersSent) {
          return;
        }
        const homeworkTags = Array.isArray(tagRows) ? tagRows.map((row) => row.name) : [];
        ensureUsersSchema(() => {
        const userFilters = ['u.course_id = ?'];
        const userParams = [courseId];
        if (usersHasIsActive) {
          userFilters.push('u.is_active = 1');
        }
        if (users_q) {
          userFilters.push('u.full_name ILIKE ?');
          userParams.push(`%${users_q}%`);
        }
        if (users_group) {
          userFilters.push('u.schedule_group = ?');
          userParams.push(users_group);
        }
        const userWhere = userFilters.length ? `WHERE ${userFilters.join(' AND ')}` : '';
        db.all(
          `
            SELECT
              u.id,
              u.full_name,
              u.role,
              u.schedule_group,
              u.course_id,
              ${usersHasIsActive ? 'u.is_active,' : ''}
              COALESCE(NULLIF(u.last_login_ip, ''), NULLIF(reg.ip, '')) AS last_login_ip,
              COALESCE(NULLIF(u.last_user_agent, ''), NULLIF(reg.user_agent, '')) AS last_user_agent,
              u.last_login_at,
              COALESCE(usc.risk_level, 'normal') AS security_risk_level,
              COALESCE(usc.status, 'open') AS security_case_status,
              COALESCE(usc.risk_score, 0)::int AS security_risk_score,
              usc.updated_at AS security_case_updated_at
            FROM users u
            LEFT JOIN LATERAL (
              SELECT re.ip, re.user_agent
              FROM user_registration_events re
              WHERE re.user_id = u.id
              ORDER BY re.created_at DESC
              LIMIT 1
            ) reg ON true
            LEFT JOIN user_security_cases usc ON usc.user_id = u.id
            ${userWhere}
            ORDER BY u.full_name
          `,
          userParams,
          (userErr, users) => {
            if (userErr) {
              return handleDbError(res, userErr, 'admin.users');
            }
            if (res.headersSent) {
              return;
            }
            getSubjectsCached(courseId)
              .then((subjects) => {
                db.all(
                  `
                    SELECT sg.student_id, sg.subject_id, sg.group_number, s.name AS subject_name
                    FROM student_groups sg
                    JOIN subjects s ON s.id = sg.subject_id
                    WHERE s.course_id = ?
                  `,
                  [courseId],
                  (sgErr, studentGroups) => {
                    if (sgErr) {
                      return handleDbError(res, sgErr, 'admin.studentGroups');
                    }
                    if (res.headersSent) {
                      return;
                    }
                  const historyFilters = [];
                  const historyParams = [];
                  historyFilters.push('course_id = ?');
                  historyParams.push(courseId);
                  if (history_actor) {
                    historyFilters.push('actor_name LIKE ?');
                    historyParams.push(`%${history_actor}%`);
                  }
                  if (history_action) {
                    historyFilters.push('action LIKE ?');
                    historyParams.push(`%${history_action}%`);
                  }
                  if (history_q) {
                    historyFilters.push('details LIKE ?');
                    historyParams.push(`%${history_q}%`);
                  }
                  if (history_from) {
                    historyFilters.push('created_at >= ?');
                    historyParams.push(new Date(history_from).toISOString());
                  }
                  if (history_to) {
                    const end = new Date(history_to);
                    end.setHours(23, 59, 59, 999);
                    historyFilters.push('created_at <= ?');
                    historyParams.push(end.toISOString());
                  }
                  const historyWhere = historyFilters.length ? `WHERE ${historyFilters.join(' AND ')}` : '';
  db.all(
    `SELECT * FROM history_log ${historyWhere} ORDER BY created_at DESC LIMIT 500`,
    historyParams,
    (logErr, logs) => {
      if (logErr) {
        return handleDbError(res, logErr, 'admin.history');
      }
      if (res.headersSent) {
        return;
      }
      const activityFilters = [];
      const activityParams = [];
      activityFilters.push('course_id = ?');
      activityParams.push(courseId);
      if (req.query.activity_user) {
        activityFilters.push('user_name ILIKE ?');
        activityParams.push(`%${req.query.activity_user}%`);
      }
      if (req.query.activity_action) {
        activityFilters.push('action_type = ?');
        activityParams.push(req.query.activity_action);
      }
      if (req.query.activity_from) {
        const start = new Date(req.query.activity_from);
        start.setHours(0, 0, 0, 0);
        activityFilters.push('created_at >= ?');
        activityParams.push(start.toISOString());
      }
      if (req.query.activity_to) {
        const end = new Date(req.query.activity_to);
        end.setHours(23, 59, 59, 999);
        activityFilters.push('created_at <= ?');
        activityParams.push(end.toISOString());
      }
      if (activeSemester) {
        activityFilters.push('semester_id = ?');
        activityParams.push(activeSemester.id);
      }
      const activityWhere = activityFilters.length ? `WHERE ${activityFilters.join(' AND ')}` : '';
      db.all(
        `SELECT * FROM activity_log ${activityWhere} ORDER BY created_at DESC LIMIT 500`,
        activityParams,
        (actErr, activityLogs) => {
          if (actErr) {
            return handleDbError(res, actErr, 'admin.activity');
          }
          if (res.headersSent) {
            return;
          }
          const topParams = activeSemester ? [courseId, activeSemester.id] : [courseId];
          db.all(
            `
              SELECT user_id, user_name,
                     SUM(${ACTIVITY_POINTS_CASE}) AS points,
                     COUNT(*) AS actions_count
              FROM activity_log
              WHERE course_id = ?${activeSemester ? ' AND semester_id = ?' : ''}
              GROUP BY user_id, user_name
              HAVING SUM(${ACTIVITY_POINTS_CASE}) > 0
              ORDER BY points DESC, actions_count DESC, user_name ASC
              LIMIT 5
            `,
            topParams,
            (topErr, activityTop) => {
              if (topErr) {
                return handleDbError(res, topErr, 'admin.activityTop');
              }
              if (res.headersSent) {
                return;
              }
          const teamworkFilters = ['t.course_id = ?'];
          const teamworkParams = [courseId];
          if (activeSemester) {
            teamworkFilters.push('t.semester_id = ?');
            teamworkParams.push(activeSemester.id);
          }
          if (teamwork_subject) {
            teamworkFilters.push('s.name ILIKE ?');
            teamworkParams.push(`%${teamwork_subject}%`);
          }
          if (teamwork_from) {
            const start = new Date(teamwork_from);
            if (!Number.isNaN(start.getTime())) {
              start.setHours(0, 0, 0, 0);
              teamworkFilters.push('t.created_at >= ?');
              teamworkParams.push(start.toISOString());
            }
          }
          if (teamwork_to) {
            const end = new Date(teamwork_to);
            if (!Number.isNaN(end.getTime())) {
              end.setHours(23, 59, 59, 999);
              teamworkFilters.push('t.created_at <= ?');
              teamworkParams.push(end.toISOString());
            }
          }
          const teamworkWhere = teamworkFilters.length ? `WHERE ${teamworkFilters.join(' AND ')}` : '';
          db.all(
                        `
                          SELECT t.id, t.title, t.created_at, s.name AS subject_name,
                                 COUNT(DISTINCT g.id) AS group_count,
                                 COUNT(DISTINCT m.user_id) AS member_count
                          FROM teamwork_tasks t
                          JOIN subjects s ON s.id = t.subject_id
                          LEFT JOIN teamwork_groups g ON g.task_id = t.id
                          LEFT JOIN teamwork_members m ON m.task_id = t.id
                          ${teamworkWhere}
                          GROUP BY t.id, t.title, t.created_at, s.name
                          ORDER BY t.created_at DESC
                        `,
                        teamworkParams,
                        (taskErr, teamworkTasks) => {
                          if (taskErr) {
                            return handleDbError(res, taskErr, 'admin.teamwork');
                          }
                          if (res.headersSent) {
                            return;
                          }
                          db.all(
                            `
                              SELECT m.*, s.name AS subject_name, u.full_name AS created_by,
                                     COALESCE(reads.read_count, 0) AS read_count,
                                     COALESCE(targets.target_count, 0) AS target_count
                              FROM messages m
                              LEFT JOIN subjects s ON s.id = m.subject_id
                              LEFT JOIN users u ON u.id = m.created_by_id
                              LEFT JOIN LATERAL (
                                SELECT COUNT(*) AS read_count
                                FROM message_reads mr
                                WHERE mr.message_id = m.id
                              ) reads ON true
                              LEFT JOIN LATERAL (
                                SELECT CASE
                                  WHEN m.target_all = 1 THEN (
                                    SELECT COUNT(*)
                                    FROM users u2
                                    WHERE u2.role = 'student' AND u2.is_active = 1
                                      AND (
                                        (m.course_id IS NULL AND m.subject_id IS NULL AND m.group_number IS NULL)
                                        OR u2.course_id = m.course_id
                                      )
                                  )
                                  WHEN m.subject_id IS NOT NULL THEN (
                                    SELECT COUNT(DISTINCT sg.student_id)
                                    FROM student_groups sg
                                    JOIN users u3 ON u3.id = sg.student_id
                                    WHERE sg.subject_id = m.subject_id AND sg.group_number = m.group_number
                                      AND u3.course_id = m.course_id AND u3.is_active = 1
                                  )
                                  ELSE (
                                    SELECT COUNT(*)
                                    FROM message_targets mt
                                    JOIN users u4 ON u4.id = mt.user_id
                                    WHERE mt.message_id = m.id AND u4.course_id = m.course_id AND u4.is_active = 1
                                  )
                                END AS target_count
                              ) targets ON true
                              WHERE (
                                m.course_id = ?
                                OR (m.target_all = 1 AND m.subject_id IS NULL AND m.group_number IS NULL AND m.course_id IS NULL)
                              )${activeSemester
                                ? ` AND (
                                    m.semester_id = ?
                                    OR (m.target_all = 1 AND m.subject_id IS NULL AND m.group_number IS NULL AND m.semester_id IS NULL)
                                  )`
                                : ''}
                              ORDER BY m.created_at DESC
                              LIMIT 200
                            `,
                            activeSemester ? [courseId, activeSemester.id] : [courseId],
                            (msgErr, messages) => {
                              if (msgErr) {
                                return handleDbError(res, msgErr, 'admin.messages');
                              }
                              if (res.headersSent) {
                                return;
                              }
                              const statsParams = activeSemester ? [courseId, activeSemester.id] : [courseId];
                              (async () => {
                                try {
                                  const [
                                    usersRow,
                                    subjectsRow,
                                    homeworkRow,
                                    teamworkTasksRow,
                                    teamworkGroupsRow,
                                    teamworkMembersRow,
                                    allSemestersRows,
                                    settingsUpdateRow,
                                  ] = await Promise.all([
                                    db.get('SELECT COUNT(*) AS count FROM users WHERE course_id = ?', [courseId]),
                                    db.get('SELECT COUNT(*) AS count FROM subjects WHERE course_id = ?', [courseId]),
                                    db.get(
                                      `SELECT COUNT(*) AS count FROM homework WHERE course_id = ?${
                                        activeSemester ? ' AND semester_id = ?' : ''
                                      }`,
                                      statsParams
                                    ),
                                    db.get(
                                      `SELECT COUNT(*) AS count FROM teamwork_tasks WHERE course_id = ?${
                                        activeSemester ? ' AND semester_id = ?' : ''
                                      }`,
                                      statsParams
                                    ),
                                    db.get(
                                      `SELECT COUNT(*) AS count
                                       FROM teamwork_groups g
                                       JOIN teamwork_tasks t ON t.id = g.task_id
                                       WHERE t.course_id = ?${activeSemester ? ' AND t.semester_id = ?' : ''}`,
                                      statsParams
                                    ),
                                    db.get(
                                      `SELECT COUNT(*) AS count
                                       FROM teamwork_members m
                                       JOIN teamwork_tasks t ON t.id = m.task_id
                                       WHERE t.course_id = ?${activeSemester ? ' AND t.semester_id = ?' : ''}`,
                                      statsParams
                                    ),
                                    db.all('SELECT id, title, weeks_count, course_id, start_date FROM semesters ORDER BY start_date DESC'),
                                    db.get(
                                      'SELECT actor_name, created_at FROM history_log WHERE action = ? ORDER BY created_at DESC LIMIT 1',
                                      ['system_settings_update']
                                    ),
                                  ]);

    const dashboardStats = {
      users: Number(usersRow?.count || 0),
      subjects: Number(subjectsRow?.count || 0),
      homework: Number(homeworkRow?.count || 0),
      teamworkTasks: Number(teamworkTasksRow?.count || 0),
      teamworkGroups: Number(teamworkGroupsRow?.count || 0),
      teamworkMembers: Number(teamworkMembersRow?.count || 0),
    };

    const semestersByCourse = {};
    (allSemestersRows || []).forEach((row) => {
      if (!semestersByCourse[row.course_id]) {
        semestersByCourse[row.course_id] = [];
      }
      semestersByCourse[row.course_id].push(row);
    });
    const settingsMeta = settingsUpdateRow
      ? { updated_at: settingsUpdateRow.created_at, updated_by: settingsUpdateRow.actor_name }
      : null;

    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const weekStart = new Date(today);
    weekStart.setDate(weekStart.getDate() - 6);
    const weeklyLabels = [];
    for (let i = 0; i < 7; i += 1) {
      const d = new Date(weekStart);
      d.setDate(weekStart.getDate() + i);
      weeklyLabels.push(d.toISOString().slice(0, 10));
    }
    let weeklyHomework = weeklyLabels.map(() => 0);
    let weeklyTeamwork = weeklyLabels.map(() => 0);
    let weeklyUserRoles = ['student', 'starosta', 'deanery', 'admin'];
    let weeklyUserSeries = weeklyUserRoles.map(() => weeklyLabels.map(() => 0));
    let coursePulse = {
      generated_at: new Date().toISOString(),
      course_id: Number(courseId || 0),
      semester_id: activeSemester ? Number(activeSemester.id) : null,
      summary: {
        students_total: 0,
        students_at_risk: 0,
        high_risk_students: 0,
        risk_students_share: 0,
        overdue_homework_total: 0,
        sla_submissions_total: 0,
        sla_ungraded_total: 0,
        sla_overdue_ungraded_total: 0,
        sla_overdue_share: 0,
        attendance_absent_share: 0,
        attendance_late_share: 0,
      },
      subjects: [],
    };
    try {
      const weeklyParams = activeSemester
        ? [courseId, weekStart.toISOString(), activeSemester.id]
        : [courseId, weekStart.toISOString()];
      const [weeklyHomeworkRows, weeklyTeamworkRows, weeklyUsersRows] = await Promise.all([
        db.all(
          `SELECT DATE(created_at::timestamp) AS day, COUNT(*) AS count
           FROM homework
           WHERE course_id = ? AND created_at::timestamp >= ?${activeSemester ? ' AND semester_id = ?' : ''}
           GROUP BY DATE(created_at::timestamp)
           ORDER BY day`,
          weeklyParams
        ),
        db.all(
          `SELECT DATE(created_at::timestamp) AS day, COUNT(*) AS count
           FROM teamwork_tasks
           WHERE course_id = ? AND created_at::timestamp >= ?${activeSemester ? ' AND semester_id = ?' : ''}
           GROUP BY DATE(created_at::timestamp)
           ORDER BY day`,
          weeklyParams
        ),
        db.all(
          `SELECT DATE(created_at) AS day, role, COUNT(*) AS count
           FROM users
           WHERE course_id = ? AND created_at >= ?
           GROUP BY DATE(created_at), role
           ORDER BY day`,
          [courseId, weekStart.toISOString()]
        ),
      ]);

      const homeworkMap = {};
      (weeklyHomeworkRows || []).forEach((row) => {
        const key = String(row.day);
        homeworkMap[key] = Number(row.count || 0);
      });
      const teamworkMap = {};
      (weeklyTeamworkRows || []).forEach((row) => {
        const key = String(row.day);
        teamworkMap[key] = Number(row.count || 0);
      });

      weeklyHomework = weeklyLabels.map((key) => homeworkMap[key] || 0);
      weeklyTeamwork = weeklyLabels.map((key) => teamworkMap[key] || 0);

      const roleOrder = ['student', 'teacher', 'starosta', 'deanery', 'admin'];
      const roleMap = {};
      (weeklyUsersRows || []).forEach((row) => {
        const key = String(row.day);
        if (!roleMap[row.role]) {
          roleMap[row.role] = {};
        }
        roleMap[row.role][key] = Number(row.count || 0);
      });
      weeklyUserRoles = roleOrder.filter((role) => roleMap[role]);
      if (!weeklyUserRoles.length) {
        weeklyUserRoles.push(...roleOrder);
      }
      weeklyUserSeries = weeklyUserRoles.map((role) =>
        weeklyLabels.map((key) => (roleMap[role] && roleMap[role][key]) || 0)
      );
    } catch (weeklyErr) {
      console.error('Database error (admin.overview.weekly)', weeklyErr);
    }

    let rbacRoles = [];
    let roleKeysByUser = {};
    let primaryRoleByUser = {};
    try {
      const userIds = (users || []).map((user) => Number(user.id)).filter((id) => Number.isFinite(id));
      const [rolesDetailed, assignment] = await Promise.all([
        getRbacRolesDetailed(),
        getUserRoleAssignmentsForUserIds(userIds),
      ]);
      rbacRoles = rolesDetailed || [];
      roleKeysByUser = assignment.roleKeysByUser || {};
      primaryRoleByUser = assignment.primaryRoleByUser || {};
    } catch (rbacErr) {
      console.error('Database error (admin.rbac)', rbacErr);
    }
    const usersWithRoles = (users || []).map((user) => {
      const userId = Number(user.id);
      const roleKeys = roleKeysByUser[userId] || [normalizeRoleKey(user.role || 'student')];
      const primaryRole = primaryRoleByUser[userId] || normalizeRoleKey(user.role || roleKeys[0] || 'student');
      return {
        ...user,
        role_keys: roleKeys,
        primary_role: primaryRole,
      };
    });

    try {
        res.render('admin', {
          username: req.session.user.username,
          userId: req.session.user.id,
          role: adminViewRole,
                                      schedule,
                                      homework,
                                      homeworkTags,
                                      users: usersWithRoles,
                                      subjects,
                                      studentGroups,
                                      logs,
                                      activityLogs,
                                      activityTop,
                                      dashboardStats,
                                      teamworkTasks,
                                      adminMessages: messages,
                                      courses,
                                      teacherRequests,
        semesters,
        semestersByCourse,
        activeSemester,
        selectedCourseId: courseId,
        limitedStaffView: !isAdminPanelOwner,
        allowedSections,
        weeklyLabels,
        weeklyHomework,
        weeklyTeamwork,
        weeklyUserRoles,
        weeklyUserSeries,
                                      settings: settingsCache,
                                      settingsMeta,
                                      rolePermissions: settingsCache.role_permissions || { ...DEFAULT_ROLE_PERMISSIONS },
                                      defaultRolePermissions: DEFAULT_ROLE_PERMISSIONS,
                                      adminSectionOptions: ADMIN_SECTION_OPTIONS,
                                      rbacRoles,
                                      rbacPermissionOptions: RBAC_PERMISSION_OPTIONS,
                                      courseKindOptions: COURSE_KIND_OPTIONS,
                                      userRoleAssignments: roleKeysByUser,
                                      userPrimaryRoleMap: primaryRoleByUser,
        activeScheduleDays,
        filters: {
          group_number: group_number || '',
          day: day || '',
          subject: subject || '',
                                        q: q || '',
                                        schedule_date: schedule_date || '',
                                      homework_from: homework_from || '',
                                      homework_to: homework_to || '',
                                      homework_tag: homework_tag || '',
                                      users_q: users_q || '',
                                      users_group: users_group || '',
                                        teamwork_subject: teamwork_subject || '',
                                        teamwork_from: teamwork_from || '',
                                        teamwork_to: teamwork_to || '',
                                      },
                                      usersStatus: resolvedUsersStatus,
                                      sorts: {
                                        schedule: sort_schedule || '',
                                        homework: sort_homework || '',
                                      },
                                      historyFilters: {
                                        actor: history_actor || '',
                                        action: history_action || '',
                                        q: history_q || '',
                                        from: history_from || '',
                                        to: history_to || '',
                                      },
                                      activityFilters: {
                                        user: req.query.activity_user || '',
                                        action: req.query.activity_action || '',
                                        from: req.query.activity_from || '',
                                        to: req.query.activity_to || '',
                                      },
                                      messages: {
                                        error: req.query.err || '',
                                        success: req.query.ok || '',
                                        operationId: req.query.op || '',
                                      },
                                    });
                                  } catch (renderErr) {
                                    return handleDbError(res, renderErr, 'admin.render');
                                  }
                                } catch (statsErr) {
                                  return handleDbError(res, statsErr, 'admin.dashboard');
                                }
                              })();
                  }
                );
              })
              .catch((subjectErr) => handleDbError(res, subjectErr, 'admin.subjects'));
            }
          );
                    }
                  );
                }
              );
            });
          });
        }
      );
});

app.post('/admin/activity/reset-points', requireActivitySectionAccess, writeLimiter, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return res.redirect('/admin?err=Database%20error');
  }
  const courseId = hasSessionRole(req, 'admin')
    ? getAdminCourse(req)
    : Number(req.session.user.course_id || 1);
  let activeSemester = null;
  try {
    activeSemester = await getActiveSemester(courseId);
  } catch (err) {
    return res.redirect('/admin?err=Database%20error');
  }
  const semesterId = activeSemester ? Number(activeSemester.id) : null;
  const actorId = Number(req.session.user.id);
  const actorName = req.session.user.username || 'admin';
  const resetScope = String(req.body.reset_scope || '').trim().toLowerCase();
  const createdAt = new Date().toISOString();

  const resolveUserPoints = async (targetUserId) => {
    const row = await db.get(
      `
        SELECT COALESCE(SUM(${ACTIVITY_POINTS_CASE}), 0) AS points
        FROM activity_log
        WHERE user_id = ? AND course_id = ?${activeSemester ? ' AND semester_id = ?' : ''}
      `,
      activeSemester ? [targetUserId, courseId, activeSemester.id] : [targetUserId, courseId]
    );
    return row ? Number(row.points || 0) : 0;
  };

  const createPointsResetEntry = async (targetUserId, targetUserName, previousPoints, reasonKey) => {
    const normalizedPrevious = Math.round(Number(previousPoints || 0) * 100) / 100;
    const delta = Math.round((0 - normalizedPrevious) * 100) / 100;
    if (!Number.isFinite(delta) || Math.abs(delta) < 0.0001) {
      return null;
    }
    const details = {
      reason: reasonKey,
      delta,
      previous_points: normalizedPrevious,
      reset_by_id: actorId,
      reset_by: actorName,
    };
    await db.run(
      `
        INSERT INTO activity_log (user_id, user_name, action_type, target_type, target_id, details, created_at, course_id, semester_id)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
      `,
      [
        targetUserId,
        targetUserName || `User ${targetUserId}`,
        'activity_points_adjust',
        'user',
        targetUserId,
        JSON.stringify(details),
        createdAt,
        courseId,
        semesterId,
      ]
    );
    return details;
  };

  try {
    if (resetScope === 'course') {
      const users = await db.all(
        `
          SELECT id, full_name
          FROM users
          WHERE course_id = ?${usersHasIsActive ? ' AND is_active = 1' : ''}
          ORDER BY full_name
        `,
        [courseId]
      );
      let affectedUsers = 0;
      let totalResetPoints = 0;
      for (const user of users || []) {
        const userId = Number(user.id);
        if (!Number.isFinite(userId) || userId < 1) continue;
        const currentPoints = await resolveUserPoints(userId);
        const details = await createPointsResetEntry(
          userId,
          user.full_name || `User ${userId}`,
          currentPoints,
          'course_reset'
        );
        if (!details) continue;
        affectedUsers += 1;
        totalResetPoints += Math.abs(Number(details.previous_points || 0));
      }
      logAction(db, req, 'activity_points_reset_course', {
        course_id: courseId,
        semester_id: semesterId,
        affected_users: affectedUsers,
        total_points_reset: Math.round(totalResetPoints * 100) / 100,
      });
      if (affectedUsers < 1) {
        return res.redirect('/admin?ok=No%20activity%20points%20to%20reset%20for%20this%20course');
      }
      return res.redirect(`/admin?ok=${encodeURIComponent(`Activity points reset for ${affectedUsers} users`)}`);
    }

    if (resetScope === 'user') {
      const targetUserId = Number(req.body.user_id);
      if (!Number.isFinite(targetUserId) || targetUserId < 1) {
        return res.redirect('/admin?err=Select%20a%20user');
      }
      const targetUser = await db.get(
        `
          SELECT id, full_name
          FROM users
          WHERE id = ? AND course_id = ?${usersHasIsActive ? ' AND is_active = 1' : ''}
          LIMIT 1
        `,
        [targetUserId, courseId]
      );
      if (!targetUser) {
        return res.redirect('/admin?err=User%20not%20found%20in%20current%20course');
      }
      const currentPoints = await resolveUserPoints(targetUserId);
      const details = await createPointsResetEntry(
        targetUserId,
        targetUser.full_name || `User ${targetUserId}`,
        currentPoints,
        'user_reset'
      );
      logAction(db, req, 'activity_points_reset_user', {
        target_user_id: targetUserId,
        target_user_name: targetUser.full_name || null,
        course_id: courseId,
        semester_id: semesterId,
        previous_points: Math.round(currentPoints * 100) / 100,
      });
      if (!details) {
        return res.redirect('/admin?ok=User%20already%20has%200%20activity%20points');
      }
      const targetUserName = targetUser.full_name || `User ${targetUserId}`;
      return res.redirect(`/admin?ok=${encodeURIComponent(`Activity points reset for ${targetUserName}`)}`);
    }

    return res.redirect('/admin?err=Invalid%20reset%20scope');
  } catch (err) {
    return res.redirect('/admin?err=Database%20error');
  }
});

app.get('/admin/schedule-list', requireScheduleSectionAccess, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleList.init');
  }
  const roleKeys = getSessionRoleList(req);
  const isAdmin = roleKeys.includes('admin');
  let courses = [];
  let courseId = getStaffCourse(req);
  let allowCourseSelect = isAdmin;
  try {
    courses = await getCoursesCached();
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleList.courses');
  }
  if (!isAdmin) {
    const baseCourseId = Number(req.session.user.course_id || 1);
    const { allowedCourseIds, allowedCourses } = await buildStaffCourseAccess(baseCourseId, courses, roleKeys);
    if (!allowedCourses.length) {
      return res.status(403).send('Forbidden (course access)');
    }
    courses = allowedCourses;
    const requestedCourse = Number(req.query.course);
    if (allowedCourseIds.has(requestedCourse)) {
      courseId = requestedCourse;
    } else if (!allowedCourseIds.has(courseId)) {
      courseId = Number(allowedCourses[0].id);
    }
    req.session.adminCourse = courseId;
    allowCourseSelect = allowedCourses.length > 1;
  }
  const {
    group_number,
    day,
    subject,
    schedule_date,
    sort_schedule,
    page,
  } = req.query;

  let activeSemester = null;
  try {
    activeSemester = await getActiveSemester(courseId);
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleList.semester');
  }
  let activeScheduleDays = [];
  try {
    const studyDays = await getCourseStudyDays(courseId);
    activeScheduleDays = (studyDays || [])
      .filter((d) => d.is_active)
      .map((d) => d.day_name)
      .filter(Boolean);
  } catch (err) {
    console.error('Failed to load study days', err);
  }
  if (!activeScheduleDays.length) {
    activeScheduleDays = [...daysOfWeek];
  }

  const scheduleFilters = ['se.course_id = ?'];
  const scheduleParams = [courseId];
  if (activeSemester) {
    scheduleFilters.push('se.semester_id = ?');
    scheduleParams.push(activeSemester.id);
  }
  if (group_number) {
    scheduleFilters.push('se.group_number = ?');
    scheduleParams.push(group_number);
  }
  if (day) {
    scheduleFilters.push('se.day_of_week = ?');
    scheduleParams.push(day);
  }
  if (subject) {
    scheduleFilters.push('s.name LIKE ?');
    scheduleParams.push(`%${subject}%`);
  }
  if (schedule_date && activeSemester && activeSemester.start_date) {
    const mapped = getWeekDayForDate(schedule_date, activeSemester.start_date);
    if (mapped) {
      scheduleFilters.push('se.week_number = ?');
      scheduleParams.push(mapped.weekNumber);
      scheduleFilters.push('se.day_of_week = ?');
      scheduleParams.push(mapped.dayName);
    }
  }

  const scheduleWhere = scheduleFilters.length ? `WHERE ${scheduleFilters.join(' AND ')}` : '';
  let orderClause = 'se.week_number, se.day_of_week, se.class_number';
  if (sort_schedule === 'group') {
    orderClause = 'se.group_number, se.day_of_week, se.class_number';
  } else if (sort_schedule === 'day') {
    orderClause = 'se.day_of_week, se.class_number, se.group_number';
  } else if (sort_schedule === 'time') {
    orderClause = 'se.class_number, se.day_of_week, se.group_number';
  }

  const perPage = 30;
  const rawPage = Number(page || 1);
  let currentPage = Number.isNaN(rawPage) || rawPage < 1 ? 1 : rawPage;

  try {
    const countRow = await db.get(
      `
        SELECT COUNT(*) AS count
        FROM schedule_entries se
        JOIN subjects s ON s.id = se.subject_id
        ${scheduleWhere}
      `,
      scheduleParams
    );
    const totalCount = Number(countRow?.count || 0);
    const totalPages = Math.max(1, Math.ceil(totalCount / perPage));
    if (currentPage > totalPages) currentPage = totalPages;
    const offset = (currentPage - 1) * perPage;
    const rows = await db.all(
      `
        SELECT se.*,
          s.name AS subject_name,
          (
            SELECT COUNT(*)
            FROM schedule_entries se2
            WHERE se2.subject_id = se.subject_id
              AND se2.day_of_week = se.day_of_week
              AND se2.class_number = se.class_number
              AND se2.week_number = se.week_number
              AND COALESCE(se2.semester_id, 0) = COALESCE(se.semester_id, 0)
              AND COALESCE(se2.course_id, 0) = COALESCE(se.course_id, 0)
              AND COALESCE(se2.lesson_type, '') = COALESCE(se.lesson_type, '')
          ) AS slot_group_count,
          (
            SELECT string_agg(DISTINCT se2.group_number::text, ', ' ORDER BY se2.group_number::text)
            FROM schedule_entries se2
            WHERE se2.subject_id = se.subject_id
              AND se2.day_of_week = se.day_of_week
              AND se2.class_number = se.class_number
              AND se2.week_number = se.week_number
              AND COALESCE(se2.semester_id, 0) = COALESCE(se.semester_id, 0)
              AND COALESCE(se2.course_id, 0) = COALESCE(se.course_id, 0)
              AND COALESCE(se2.lesson_type, '') = COALESCE(se.lesson_type, '')
          ) AS slot_group_list
        FROM schedule_entries se
        JOIN subjects s ON s.id = se.subject_id
        ${scheduleWhere}
        ORDER BY ${orderClause}
        LIMIT ? OFFSET ?
      `,
      [...scheduleParams, perPage, offset]
    );

    const semesters = await getSemestersCached(courseId);
    const subjects = await getSubjectsCached(courseId);

    const queryParams = new URLSearchParams();
    if (courseId) queryParams.set('course', courseId);
    if (group_number) queryParams.set('group_number', group_number);
    if (day) queryParams.set('day', day);
    if (subject) queryParams.set('subject', subject);
    if (schedule_date) queryParams.set('schedule_date', schedule_date);
    if (sort_schedule) queryParams.set('sort_schedule', sort_schedule);
    const baseQuery = queryParams.toString();
    const pageBase = baseQuery ? `?${baseQuery}&page=` : '?page=';

    return res.render('admin-schedule-list', {
      username: req.session.user.username,
      role: normalizeRoleKey(req.session.role || 'student'),
      adminHomeHref: getStaffPanelBase(req, courseId),
      courses,
      subjects,
      semesters,
      activeSemester,
      selectedCourseId: courseId,
      allowCourseSelect,
      activeScheduleDays,
      schedule: rows || [],
      perPage,
      filters: {
        group_number: group_number || '',
        day: day || '',
        subject: subject || '',
        schedule_date: schedule_date || '',
      },
      sorts: {
        schedule: sort_schedule || '',
      },
      pagination: {
        page: currentPage,
        totalPages,
        pageBase,
      },
    });
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleList');
  }
});

app.post('/admin/schedule-windows', requireScheduleSectionAccess, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleWindows.init');
  }
  const courseIdsRaw = req.body.course_ids || req.body.course_id || [];
  const courseIds = (Array.isArray(courseIdsRaw) ? courseIdsRaw : [courseIdsRaw])
    .map((value) => Number(value))
    .filter((value) => Number.isFinite(value) && value > 0);
  const weekNumber = Number(req.body.week_number || req.body.week);
  if (!courseIds.length || !Number.isFinite(weekNumber) || weekNumber < 1) {
    return res.status(400).json({ ok: false, error: 'Invalid input' });
  }
  try {
    const roleKeys = getSessionRoleList(req);
    const isAdmin = roleKeys.includes('admin');
    const courses = await getCoursesCached();
    let scopedCourseIds = courseIds;
    if (!isAdmin) {
      const baseCourseId = Number(req.session.user.course_id || 1);
      const { allowedCourseIds } = await buildStaffCourseAccess(baseCourseId, courses, roleKeys);
      scopedCourseIds = courseIds.filter((courseId) => allowedCourseIds.has(Number(courseId)));
      if (!scopedCourseIds.length) {
        return res.status(403).json({ ok: false, error: 'Forbidden (course access)' });
      }
    }
    const courseMap = new Map((courses || []).map((c) => [Number(c.id), c]));
    const warnings = [];
    const freeSets = [];
    const validCourses = [];
    for (const courseId of scopedCourseIds) {
      const course = courseMap.get(Number(courseId));
      if (!course) {
        warnings.push(`Курс ${courseId} не знайдено.`);
        continue;
      }
      const semester = await getActiveSemester(courseId);
      if (!semester) {
        warnings.push(`${course.name}: немає активного семестру.`);
        continue;
      }
      if (Number(weekNumber) > Number(semester.weeks_count || 0)) {
        warnings.push(`${course.name}: тиждень ${weekNumber} поза межами семестру (${semester.weeks_count}).`);
      }
      let activeDays = [];
      try {
        const studyDays = await getCourseStudyDays(courseId);
        activeDays = (studyDays || [])
          .filter((d) => d.is_active)
          .map((d) => normalizeWeekdayName(d.day_name))
          .filter(Boolean);
      } catch (dayErr) {
        activeDays = [];
      }
      if (!activeDays.length) {
        activeDays = [...daysOfWeek];
      }
      const rows = await db.all(
        `
          SELECT day_of_week, class_number
          FROM schedule_entries
          WHERE course_id = ? AND semester_id = ? AND week_number = ?
        `,
        [courseId, semester.id, weekNumber]
      );
      const busy = new Set(
        (rows || [])
          .map((row) => {
            const day = normalizeWeekdayName(row.day_of_week);
            const classNum = Number(row.class_number);
            if (!day || !Number.isFinite(classNum)) return null;
            return `${day}|${classNum}`;
          })
          .filter(Boolean)
      );
      const free = new Set();
      activeDays.forEach((day) => {
        for (let classNum = 1; classNum <= 7; classNum += 1) {
          const key = `${day}|${classNum}`;
          if (!busy.has(key)) free.add(key);
        }
      });
      freeSets.push(free);
      validCourses.push({ id: courseId, name: course.name });
    }
    if (!freeSets.length) {
      return res.status(200).json({ ok: false, error: 'No valid courses', warnings });
    }
    let commonSet = null;
    freeSets.forEach((set) => {
      if (!commonSet) {
        commonSet = new Set(set);
      } else {
        commonSet = new Set([...commonSet].filter((key) => set.has(key)));
      }
    });
    const dayOrder = fullWeekDays || daysOfWeek;
    const dayIndex = new Map(dayOrder.map((day, idx) => [day, idx]));
    const slots = [...(commonSet || [])]
      .map((key) => {
        const [day, classNumRaw] = key.split('|');
        const classNum = Number(classNumRaw);
        const time = bellSchedule[classNum]
          ? `${bellSchedule[classNum].start}–${bellSchedule[classNum].end}`
          : `${classNum} пара`;
        return { day, class_number: classNum, time };
      })
      .sort((a, b) => {
        const idxA = dayIndex.get(a.day) ?? 99;
        const idxB = dayIndex.get(b.day) ?? 99;
        if (idxA !== idxB) return idxA - idxB;
        return a.class_number - b.class_number;
      });
    const windows = [];
    const grouped = new Map();
    slots.forEach((slot) => {
      if (!grouped.has(slot.day)) grouped.set(slot.day, []);
      grouped.get(slot.day).push(slot);
    });
    dayOrder.forEach((day) => {
      if (!grouped.has(day)) return;
      windows.push({ day, slots: grouped.get(day) });
    });
    const summaryCourses = validCourses.map((c) => c.name).join(' · ');
    const summary = `Курси: ${summaryCourses} · Тиждень ${weekNumber} · Спільних вікон: ${slots.length}`;
    return res.json({
      ok: true,
      summary,
      warnings,
      windows,
    });
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleWindows');
  }
});

app.get('/admin/schedule-summary', requireScheduleSectionAccess, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleSummary.init');
  }
  const roleKeys = getSessionRoleList(req);
  const isAdmin = roleKeys.includes('admin');
  let courses = [];
  let courseId = getStaffCourse(req);
  let allowCourseSelect = isAdmin;
  try {
    courses = await getCoursesCached();
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleSummary.courses');
  }
  if (!isAdmin) {
    const baseCourseId = Number(req.session.user.course_id || 1);
    const { allowedCourseIds, allowedCourses } = await buildStaffCourseAccess(baseCourseId, courses, roleKeys);
    if (!allowedCourses.length) {
      return res.status(403).send('Forbidden (course access)');
    }
    courses = allowedCourses;
    const requestedCourse = Number(req.query.course);
    if (allowedCourseIds.has(requestedCourse)) {
      courseId = requestedCourse;
    } else if (!allowedCourseIds.has(courseId)) {
      courseId = Number(allowedCourses[0].id);
    }
    req.session.adminCourse = courseId;
    allowCourseSelect = allowedCourses.length > 1;
  }
  let activeSemester = null;
  try {
    const semesterList = await getSemestersCached(courseId);
    const requestedSemesterId = Number(req.query.semester_id);
    if (Number.isFinite(requestedSemesterId) && requestedSemesterId > 0) {
      activeSemester = semesterList.find((sem) => Number(sem.id) === requestedSemesterId) || null;
    }
    if (!activeSemester) {
      activeSemester = await getActiveSemester(courseId);
    }
    const summaryRows = activeSemester
      ? await db.all(
          `
            SELECT s.name AS subject_name,
                   COALESCE(se.lesson_type, '') AS lesson_type,
                   COUNT(*) AS total
            FROM schedule_entries se
            JOIN subjects s ON s.id = se.subject_id
            WHERE se.course_id = ? AND se.semester_id = ?
            GROUP BY s.name, COALESCE(se.lesson_type, '')
            ORDER BY s.name, COALESCE(se.lesson_type, '')
          `,
          [courseId, activeSemester.id]
        )
      : [];
    return res.render('admin-schedule-summary', {
      username: req.session.user.username,
      role: normalizeRoleKey(req.session.role || 'student'),
      adminHomeHref: getStaffPanelBase(req, courseId),
      courses,
      semesters: semesterList,
      activeSemester,
      selectedCourseId: courseId,
      allowCourseSelect,
      semesterSummary: summaryRows || [],
    });
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleSummary');
  }
});

app.get('/admin/schedule-generator', requireScheduleGeneratorSectionAccess, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleGenerator.init');
  }
  const userId = req.session.user.id;
  const runId = Number(req.query.run);
  let run = null;
  try {
    if (Number.isFinite(runId) && runId > 0) {
      run = await db.get('SELECT * FROM schedule_generator_runs WHERE id = ?', [runId]);
    }
    if (!run) {
      run = await db.get(
        'SELECT * FROM schedule_generator_runs WHERE created_by_id = ? ORDER BY created_at DESC LIMIT 1',
        [userId]
      );
    }
    if (!run) {
      const insert = await db.run(
        'INSERT INTO schedule_generator_runs (status, created_by_id, config) VALUES (?, ?, ?) RETURNING id',
        ['draft', userId, serializeGeneratorConfig(DEFAULT_GENERATOR_CONFIG)]
      );
      const newId = insert.lastID;
      return res.redirect(`/admin/schedule-generator?run=${newId}`);
    }

    const parsedConfig = parseGeneratorConfig(run.config);
    const config = parsedConfig && typeof parsedConfig === 'object'
      ? { ...DEFAULT_GENERATOR_CONFIG, ...parsedConfig }
      : { ...DEFAULT_GENERATOR_CONFIG };
    const requestedLocation = String((req.body && req.body.active_location) || '');
    const activeLocation = requestedLocation.toLowerCase() === 'munich'
      ? 'munich'
      : requestedLocation
      ? 'kyiv'
      : config.active_location === 'munich'
      ? 'munich'
      : 'kyiv';
    if (activeLocation !== config.active_location) {
      config.active_location = activeLocation;
    }
    const coursesByLocation = {
      kyiv: await getCoursesByLocation('kyiv'),
      munich: await getCoursesByLocation('munich'),
    };
    const courseSemestersByLocation = { kyiv: [], munich: [] };
    const courseDaysByLocation = { kyiv: {}, munich: {} };
    const subjectsByCourse = {};
    const semestersByCourse = {};
    const selectedSemestersByLocation = { kyiv: {}, munich: {} };
    for (const location of ['kyiv', 'munich']) {
      const courses = coursesByLocation[location] || [];
      for (const course of courses) {
        const semesters = await getSemestersCached(course.id);
        semestersByCourse[course.id] = semesters || [];
        const configuredId = config.course_semesters_by_location
          ? config.course_semesters_by_location[location]?.[course.id]
            || config.course_semesters_by_location[location]?.[String(course.id)]
          : null;
        let semester = null;
        if (configuredId) {
          semester = (semesters || []).find((s) => Number(s.id) === Number(configuredId)) || null;
        }
        if (!semester) {
          semester = await getActiveSemester(course.id);
        }
        if (semester) {
          selectedSemestersByLocation[location][course.id] = semester.id;
        }
        courseSemestersByLocation[location].push({ course, semester });
        const studyDays = await getCourseStudyDays(course.id);
        const activeDays = (studyDays || [])
          .filter((d) => d.is_active)
          .map((d) => d.day_name)
          .filter(Boolean);
        courseDaysByLocation[location][course.id] = activeDays.length ? activeDays : [...daysOfWeek];
        subjectsByCourse[course.id] = await getSubjectsCached(course.id);
      }
    }

    const teachers = await db.all(
      "SELECT id, full_name FROM users WHERE role = 'teacher' ORDER BY full_name"
    );
    const items = await db.all(
      `
        SELECT sgi.*, s.name AS subject_name, s.group_count, s.is_general, u.full_name AS teacher_name
        FROM schedule_generator_items sgi
        JOIN subjects s ON s.id = sgi.subject_id
        LEFT JOIN users u ON u.id = sgi.teacher_id
        WHERE sgi.run_id = ?
        ORDER BY sgi.id DESC
      `,
      [run.id]
    );
    const courseLocationMap = {};
    Object.entries(coursesByLocation).forEach(([location, list]) => {
      (list || []).forEach((course) => {
        courseLocationMap[course.id] = location;
      });
    });
    const limitsRows = await db.all(
      'SELECT * FROM schedule_generator_teacher_limits WHERE run_id = ?',
      [run.id]
    );
    const limitsByTeacher = {};
    limitsRows.forEach((row) => {
      limitsByTeacher[row.teacher_id] = {
        allowed_weekdays: row.allowed_weekdays ? row.allowed_weekdays.split(',') : [],
        max_pairs_per_week: row.max_pairs_per_week,
      };
    });
    const lastConflicts = Array.isArray(config.last_conflicts) ? config.last_conflicts : [];
    const lastStats = config.last_stats || null;
    const allCourses = Object.values(coursesByLocation).flat();
    const courseById = {};
    allCourses.forEach((course) => {
      courseById[course.id] = course.name;
    });
    const courseMetaById = {};
    ['kyiv', 'munich'].forEach((location) => {
      (courseSemestersByLocation[location] || []).forEach((row) => {
        courseMetaById[row.course.id] = {
          weeks_count: row.semester ? Number(row.semester.weeks_count || 0) : 0,
          active_days: courseDaysByLocation[location][row.course.id] || [],
          location,
        };
      });
    });
    const itemsByLocation = { kyiv: [], munich: [] };
    const itemsById = {};
    (items || []).forEach((item) => {
      itemsById[item.id] = item;
      const location = courseLocationMap[item.course_id] || 'kyiv';
      itemsByLocation[location].push(item);
    });
    const mirrorSummaryByLocation = {
      kyiv: buildMirrorSummary(itemsByLocation.kyiv, courseById),
      munich: buildMirrorSummary(itemsByLocation.munich, courseById),
    };
    const validationByLocation = {
      kyiv: buildGeneratorValidation({
        items: itemsByLocation.kyiv,
        courseMetaById,
        teacherLimits: limitsByTeacher,
        config,
        locationLabel: 'Kyiv',
      }),
      munich: buildGeneratorValidation({
        items: itemsByLocation.munich,
        courseMetaById,
        teacherLimits: limitsByTeacher,
        config,
        locationLabel: 'Munich',
      }),
    };
    const { conflictDetails, conflictItemIds } = buildConflictContext(
      lastConflicts,
      itemsById,
      courseById,
      courseLocationMap
    );
    const problemItemLookupByLocation = { kyiv: {}, munich: {} };
    ['kyiv', 'munich'].forEach((location) => {
      const validationItems = validationByLocation[location].itemIssues || {};
      Object.entries(validationItems).forEach(([itemId, info]) => {
        problemItemLookupByLocation[location][itemId] = info.level;
      });
      conflictItemIds[location].forEach((itemId) => {
        if (!problemItemLookupByLocation[location][itemId]) {
          problemItemLookupByLocation[location][itemId] = 'warn';
        }
      });
    });
    const entryRows = await db.all(
      'SELECT course_id, day_of_week, class_number FROM schedule_generator_entries WHERE run_id = ?',
      [run.id]
    );
    const entriesByLocation = { kyiv: [], munich: [] };
    (entryRows || []).forEach((row) => {
      const location = courseLocationMap[row.course_id] || 'kyiv';
      entriesByLocation[location].push(row);
    });
    const heatmapByLocation = {
      kyiv: buildHeatmap(entriesByLocation.kyiv, fullWeekDays, [1, 2, 3, 4, 5, 6, 7]),
      munich: buildHeatmap(entriesByLocation.munich, fullWeekDays, [1, 2, 3, 4, 5, 6, 7]),
    };
    const isSeminarType = (lessonType) => {
      const raw = String(lessonType || '').toLowerCase();
      return raw.includes('seminar') || raw.includes('сем');
    };
    const autoMirrorCandidatesByLocation = { kyiv: [], munich: [] };
    const autoMirrorExclusionsByLocation = { kyiv: [], munich: [] };
    Object.entries(itemsByLocation).forEach(([location, list]) => {
      const buckets = new Map();
      const matchedIds = new Set();
      const sameSubjectOnly = new Set();
      (list || []).forEach((item) => {
        const groupNum = Number(item.group_number);
        const generalFlag = item.is_general === true || Number(item.is_general) === 1;
        const baseEligible = isSeminarType(item.lesson_type)
          && (groupNum === 1 || groupNum === 2)
          && !item.mirror_key
          && !(item.fixed_day || item.fixed_class_number || item.weeks_set)
          && generalFlag;
        if (!baseEligible) return;
        const key = `${item.course_id}|${item.semester_id || ''}|${String(item.lesson_type || '')}|${item.pairs_count || 0}`;
        if (!buckets.has(key)) {
          buckets.set(key, { group1: [], group2: [] });
        }
        const bucket = buckets.get(key);
        if (groupNum === 1) bucket.group1.push(item);
        if (groupNum === 2) bucket.group2.push(item);
      });
      const candidates = [];
      buckets.forEach((bucket) => {
        const group1 = [...bucket.group1].sort((a, b) => a.subject_name.localeCompare(b.subject_name) || a.id - b.id);
        const group2 = [...bucket.group2].sort((a, b) => a.subject_name.localeCompare(b.subject_name) || a.id - b.id);
        const used = new Set();
        group1.forEach((a) => {
          const idx = group2.findIndex((b, i) => !used.has(i) && Number(b.subject_id) !== Number(a.subject_id));
          if (idx === -1) return;
          const b = group2[idx];
          used.add(idx);
          matchedIds.add(a.id);
          matchedIds.add(b.id);
          candidates.push({
            a,
            b,
            course_name: courseById[a.course_id] || '',
            lesson_type: a.lesson_type,
            pairs_count: a.pairs_count,
          });
        });
      });
      buckets.forEach((bucket) => {
        bucket.group1.forEach((a) => {
          if (matchedIds.has(a.id)) return;
          const hasSame = bucket.group2.some((b) => Number(b.subject_id) === Number(a.subject_id));
          if (hasSame) sameSubjectOnly.add(a.id);
        });
        bucket.group2.forEach((b) => {
          if (matchedIds.has(b.id)) return;
          const hasSame = bucket.group1.some((a) => Number(a.subject_id) === Number(b.subject_id));
          if (hasSame) sameSubjectOnly.add(b.id);
        });
      });
      const exclusions = [];
      (list || []).forEach((item) => {
        const reasons = [];
        const groupNum = Number(item.group_number);
        const generalFlag = item.is_general === true || Number(item.is_general) === 1;
        if (!isSeminarType(item.lesson_type)) reasons.push('Не семінар');
        if (!(groupNum === 1 || groupNum === 2)) reasons.push('Не група 1/2');
        if (item.mirror_key) reasons.push('Вже має ключ дзеркала');
        if (item.fixed_day || item.fixed_class_number || item.weeks_set) reasons.push('Є фіксований день/слот/тижні');
        if (!generalFlag) reasons.push('Не загальний предмет');
        if (!reasons.length && !matchedIds.has(item.id)) {
          if (sameSubjectOnly.has(item.id)) {
            reasons.push('У іншій групі лише такий самий предмет');
          } else {
            reasons.push('Немає пари для групи 1/2');
          }
        }
        if (!reasons.length) return;
        exclusions.push({
          id: item.id,
          subject_name: item.subject_name,
          course_name: courseById[item.course_id] || '',
          group_number: item.group_number,
          lesson_type: item.lesson_type,
          pairs_count: item.pairs_count,
          reasons,
        });
      });
      autoMirrorCandidatesByLocation[location] = candidates;
      autoMirrorExclusionsByLocation[location] = exclusions;
    });
    const generationInsightsByLocation = buildGenerationInsights({
      validationByLocation,
      conflictDetails,
      heatmapByLocation,
      mirrorSummaryByLocation,
      config,
    });

    return res.render('admin-schedule-generator', {
      username: req.session.user.username,
      role: req.session.role,
      run,
      config,
      activeLocation,
      coursesByLocation,
      courseSemestersByLocation,
      courseDaysByLocation,
      subjectsByCourse,
      semestersByCourse,
      selectedSemestersByLocation,
      courseLocationMap,
      courseById,
      teachers,
      items,
      limitsByTeacher,
      lastConflicts,
      lastStats,
      mirrorSummaryByLocation,
      validationByLocation,
      conflictDetails,
      conflictItemIds,
      problemItemLookupByLocation,
      heatmapByLocation,
      generationInsightsByLocation,
      autoMirrorCandidatesByLocation,
      autoMirrorExclusionsByLocation,
      dayOptions: fullWeekDays,
      dayLabels: studyDayLabels,
      classOptions: [1, 2, 3, 4, 5, 6, 7],
    });
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleGenerator.render');
  }
});

app.get('/admin/schedule-generator/merge-preview', requireScheduleGeneratorSectionAccess, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleGenerator.mergePreview');
  }
  const courseIdRaw = Number(req.query.course_id);
  const courseId = Number.isFinite(courseIdRaw) && courseIdRaw > 0 ? courseIdRaw : null;
  try {
    const preview = await buildSubjectMergePreview(courseId);
    return res.json({
      generated_at: new Date().toISOString(),
      total: preview.length,
      course_id: courseId,
      merges: preview,
    });
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleGenerator.mergePreview');
  }
});

app.post('/admin/schedule-generator/new', requireScheduleGeneratorSectionAccess, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleGenerator.create');
  }
  const userId = req.session.user.id;
  try {
    const insert = await db.run(
      'INSERT INTO schedule_generator_runs (status, created_by_id, config) VALUES (?, ?, ?) RETURNING id',
      ['draft', userId, serializeGeneratorConfig(DEFAULT_GENERATOR_CONFIG)]
    );
    const runId = insert.lastID;
    return res.redirect(`/admin/schedule-generator?run=${runId}`);
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleGenerator.create');
  }
});

app.post('/admin/schedule-generator/config', requireScheduleGeneratorSectionAccess, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleGenerator.config');
  }
  const runId = Number(req.body.run_id);
  if (!Number.isFinite(runId) || runId <= 0) {
    return res.redirect('/admin/schedule-generator?err=Invalid%20run');
  }
  try {
    const run = await db.get('SELECT * FROM schedule_generator_runs WHERE id = ?', [runId]);
    if (!run) return res.redirect('/admin/schedule-generator?err=Run%20not%20found');
    const existing = parseGeneratorConfig(run.config);
    const maxDailyRaw = Number(req.body.max_daily_pairs);
    const targetDailyRaw = Number(req.body.target_daily_pairs);
    const evennessRaw = Number(req.body.evenness_bias);
    const lateSlotRaw = Number(req.body.late_slot_weight);
    const maxDailyPairs = Number.isNaN(maxDailyRaw)
      ? existing.max_daily_pairs
      : Math.min(Math.max(maxDailyRaw, 1), 7);
    const targetDailyPairs = Number.isNaN(targetDailyRaw)
      ? existing.target_daily_pairs
      : Math.min(Math.max(targetDailyRaw, 1), 7);
    const evennessBias = Number.isNaN(evennessRaw)
      ? existing.evenness_bias
      : Math.min(Math.max(evennessRaw, 0), 100);
    const lateSlotWeight = Number.isNaN(lateSlotRaw)
      ? existing.late_slot_weight
      : Math.min(Math.max(lateSlotRaw, 0), 100);
    const activeLocation = String(req.body.active_location || existing.active_location || 'kyiv').toLowerCase() === 'munich'
      ? 'munich'
      : 'kyiv';
    const courseSemesterInput = req.body.course_semesters || {};
    const sanitizedCourseSemesters = {};
    const entries = Object.entries(courseSemesterInput);
    for (const [courseIdRaw, semesterIdRaw] of entries) {
      const courseId = Number(courseIdRaw);
      const semesterId = Number(semesterIdRaw);
      if (!Number.isFinite(courseId) || !Number.isFinite(semesterId)) continue;
      const row = await db.get('SELECT id FROM semesters WHERE id = ? AND course_id = ?', [semesterId, courseId]);
      if (row) {
        sanitizedCourseSemesters[String(courseId)] = semesterId;
      }
    }
    const nextCourseSemestersByLocation = {
      ...(existing.course_semesters_by_location || { kyiv: {}, munich: {} }),
      [activeLocation]: sanitizedCourseSemesters,
    };
    const nextConfig = {
      ...existing,
      active_location: activeLocation,
      distribution: normalizeDistribution(req.body.distribution, existing.distribution || 'even'),
      seminar_distribution: normalizeDistribution(req.body.seminar_distribution, existing.seminar_distribution || 'even'),
      max_daily_pairs: maxDailyPairs || 7,
      target_daily_pairs: targetDailyPairs || 4,
      evenness_bias: evennessBias,
      late_slot_weight: Number.isFinite(lateSlotWeight) ? lateSlotWeight : 0,
      blocked_weeks: String(req.body.blocked_weeks || ''),
      special_weeks_mode: String(req.body.special_weeks_mode || existing.special_weeks_mode || 'block'),
      prefer_compactness: String(req.body.prefer_compactness || '') === 'on',
      strict_no_evening: String(req.body.strict_no_evening || '') === 'on',
      mirror_groups: String(req.body.mirror_groups || '') === 'on',
      auto_subject_days: String(req.body.auto_subject_days || '') === 'on',
      subject_single_day: String(req.body.subject_single_day || '') === 'on',
      lecture_seminar_same_day: String(req.body.lecture_seminar_same_day || '') === 'on',
      lecture_before_seminar: String(req.body.lecture_before_seminar || '') === 'on',
      course_semesters: sanitizedCourseSemesters,
      course_semesters_by_location: nextCourseSemestersByLocation,
    };
    await db.run(
      'UPDATE schedule_generator_runs SET config = ?, updated_at = NOW() WHERE id = ?',
      [serializeGeneratorConfig(nextConfig), runId]
    );
    const semesterPairs = Object.entries(sanitizedCourseSemesters);
    for (const [courseId, semesterId] of semesterPairs) {
      await db.run(
        'UPDATE schedule_generator_items SET semester_id = ? WHERE run_id = ? AND course_id = ?',
        [Number(semesterId), runId, Number(courseId)]
      );
    }
    return res.redirect(`/admin/schedule-generator?run=${runId}&ok=Settings%20saved`);
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleGenerator.config.save');
  }
});

app.post('/admin/schedule-generator/config/autotune', requireScheduleGeneratorSectionAccess, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleGenerator.config.autotune');
  }
  const runId = Number(req.body.run_id);
  if (!Number.isFinite(runId) || runId <= 0) {
    return res.redirect('/admin/schedule-generator?err=Invalid%20run');
  }
  try {
    const run = await db.get('SELECT * FROM schedule_generator_runs WHERE id = ?', [runId]);
    if (!run) return res.redirect('/admin/schedule-generator?err=Run%20not%20found');
    const existing = parseGeneratorConfig(run.config);
    const activeLocation = String(req.body.active_location || existing.active_location || 'kyiv').toLowerCase() === 'munich'
      ? 'munich'
      : 'kyiv';

    const coursesByLocation = {
      kyiv: await getCoursesByLocation('kyiv'),
      munich: await getCoursesByLocation('munich'),
    };
    const courseMetaById = {};
    const courseById = {};
    const courseLocationMap = {};
    for (const location of ['kyiv', 'munich']) {
      const courses = coursesByLocation[location] || [];
      for (const course of courses) {
        const semesters = await getSemestersCached(course.id);
        const configuredId = existing.course_semesters_by_location
          ? existing.course_semesters_by_location[location]?.[course.id]
            || existing.course_semesters_by_location[location]?.[String(course.id)]
          : null;
        let semester = null;
        if (configuredId) {
          semester = (semesters || []).find((s) => Number(s.id) === Number(configuredId)) || null;
        }
        if (!semester) {
          semester = await getActiveSemester(course.id);
        }
        const studyDays = await getCourseStudyDays(course.id);
        const activeDays = (studyDays || [])
          .filter((d) => d.is_active)
          .map((d) => d.day_name)
          .filter(Boolean);
        courseMetaById[course.id] = {
          weeks_count: semester ? Number(semester.weeks_count || 0) : 0,
          active_days: activeDays.length ? activeDays : [...daysOfWeek],
          location,
        };
        courseById[course.id] = course.name;
        courseLocationMap[course.id] = location;
      }
    }

    const items = await db.all(
      `
        SELECT sgi.*, s.name AS subject_name, s.group_count, s.is_general, u.full_name AS teacher_name
        FROM schedule_generator_items sgi
        JOIN subjects s ON s.id = sgi.subject_id
        LEFT JOIN users u ON u.id = sgi.teacher_id
        WHERE sgi.run_id = ?
        ORDER BY sgi.id DESC
      `,
      [run.id]
    );
    const itemsByLocation = { kyiv: [], munich: [] };
    const itemsById = {};
    (items || []).forEach((item) => {
      itemsById[item.id] = item;
      const location = courseLocationMap[item.course_id] || 'kyiv';
      itemsByLocation[location].push(item);
    });

    const limitsRows = await db.all(
      'SELECT * FROM schedule_generator_teacher_limits WHERE run_id = ?',
      [run.id]
    );
    const limitsByTeacher = {};
    limitsRows.forEach((row) => {
      limitsByTeacher[row.teacher_id] = {
        allowed_weekdays: row.allowed_weekdays ? row.allowed_weekdays.split(',') : [],
        max_pairs_per_week: row.max_pairs_per_week,
      };
    });

    const validationByLocation = {
      kyiv: buildGeneratorValidation({
        items: itemsByLocation.kyiv,
        courseMetaById,
        teacherLimits: limitsByTeacher,
        config: existing,
        locationLabel: 'Kyiv',
      }),
      munich: buildGeneratorValidation({
        items: itemsByLocation.munich,
        courseMetaById,
        teacherLimits: limitsByTeacher,
        config: existing,
        locationLabel: 'Munich',
      }),
    };
    const mirrorSummaryByLocation = {
      kyiv: buildMirrorSummary(itemsByLocation.kyiv, courseById),
      munich: buildMirrorSummary(itemsByLocation.munich, courseById),
    };
    const lastConflicts = Array.isArray(existing.last_conflicts) ? existing.last_conflicts : [];
    const { conflictDetails } = buildConflictContext(
      lastConflicts,
      itemsById,
      courseById,
      courseLocationMap
    );
    const entryRows = await db.all(
      'SELECT course_id, day_of_week, class_number FROM schedule_generator_entries WHERE run_id = ?',
      [run.id]
    );
    const entriesByLocation = { kyiv: [], munich: [] };
    (entryRows || []).forEach((row) => {
      const location = courseLocationMap[row.course_id] || 'kyiv';
      entriesByLocation[location].push(row);
    });
    const heatmapByLocation = {
      kyiv: buildHeatmap(entriesByLocation.kyiv, fullWeekDays, [1, 2, 3, 4, 5, 6, 7]),
      munich: buildHeatmap(entriesByLocation.munich, fullWeekDays, [1, 2, 3, 4, 5, 6, 7]),
    };
    const insightsByLocation = buildGenerationInsights({
      validationByLocation,
      conflictDetails,
      heatmapByLocation,
      mirrorSummaryByLocation,
      config: existing,
    });
    const patch = buildSafeAutoTunePatch(existing, insightsByLocation[activeLocation]);
    const nextConfig = {
      ...existing,
      ...patch,
      active_location: activeLocation,
    };
    await db.run(
      'UPDATE schedule_generator_runs SET config = ?, updated_at = NOW() WHERE id = ?',
      [serializeGeneratorConfig(nextConfig), runId]
    );
    return res.redirect(`/admin/schedule-generator?run=${runId}&ok=Safe%20auto-tune%20applied`);
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleGenerator.config.autotune.save');
  }
});

app.post('/admin/schedule-generator/items/add', requireScheduleGeneratorSectionAccess, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleGenerator.item');
  }
  const runId = Number(req.body.run_id);
  const courseId = Number(req.body.course_id);
  const subjectId = Number(req.body.subject_id);
  const teacherIdRaw = req.body.teacher_id ? Number(req.body.teacher_id) : null;
  const lessonTypeRaw = String(req.body.lesson_type || 'lecture').trim();
  const lessonType = lessonTypeRaw || 'lecture';
  const groupRaw = String(req.body.group_number || 'all');
  const groupNumber = groupRaw === 'all' || groupRaw === '0' ? null : Number(groupRaw);
  const pairsCount = Number(req.body.pairs_count);
  const weeksSet = String(req.body.weeks_set || '').trim();
  const fixedDay = normalizeWeekdayName(req.body.fixed_day);
  const fixedClass = req.body.fixed_class_number ? Number(req.body.fixed_class_number) : null;
  const mirrorKeyRaw = String(req.body.mirror_key || '').trim();
  const mirrorKey = mirrorKeyRaw || null;

  if (!Number.isFinite(runId) || runId <= 0 || !Number.isFinite(courseId) || !Number.isFinite(subjectId)) {
    return res.redirect(`/admin/schedule-generator?run=${runId}&err=Invalid%20data`);
  }
  if (!Number.isFinite(pairsCount) || pairsCount <= 0) {
    return res.redirect(`/admin/schedule-generator?run=${runId}&err=Invalid%20pairs`);
  }
  if (groupNumber && (Number.isNaN(groupNumber) || groupNumber < 1)) {
    return res.redirect(`/admin/schedule-generator?run=${runId}&err=Invalid%20group`);
  }
  if (fixedClass && (fixedClass < 1 || fixedClass > 7)) {
    return res.redirect(`/admin/schedule-generator?run=${runId}&err=Invalid%20slot`);
  }

  try {
    const subjectRow = await db.get('SELECT id, group_count, is_general FROM subjects WHERE id = ? AND course_id = ?', [subjectId, courseId]);
    if (!subjectRow) {
      return res.redirect(`/admin/schedule-generator?run=${runId}&err=Subject%20not%20found`);
    }
    if (groupNumber && Number(groupNumber) > Number(subjectRow.group_count || 1)) {
      return res.redirect(`/admin/schedule-generator?run=${runId}&err=Invalid%20group`);
    }
    const run = await db.get('SELECT config FROM schedule_generator_runs WHERE id = ?', [runId]);
    if (!run) {
      return res.redirect(`/admin/schedule-generator?run=${runId}&err=Run%20not%20found`);
    }
    const runConfig = parseGeneratorConfig(run.config);
    const courseRow = await db.get('SELECT location FROM courses WHERE id = ?', [courseId]);
    const courseLocation = String(courseRow?.location || 'kyiv').toLowerCase() === 'munich' ? 'munich' : 'kyiv';
    const configuredSemesterId = runConfig.course_semesters_by_location
      ? runConfig.course_semesters_by_location[courseLocation]?.[courseId]
        || runConfig.course_semesters_by_location[courseLocation]?.[String(courseId)]
      : null;
    let semester = null;
    if (configuredSemesterId) {
      semester = await db.get('SELECT id FROM semesters WHERE id = ? AND course_id = ?', [configuredSemesterId, courseId]);
    }
    if (!semester) {
      semester = await getActiveSemester(courseId);
    }
    if (!semester) {
      return res.redirect(`/admin/schedule-generator?run=${runId}&err=Semester%20not%20found`);
    }
    const lessonTypeLower = String(lessonType || '').toLowerCase();
    const isSeminar = lessonTypeLower.includes('seminar') || lessonTypeLower.includes('сем');
    const totalGroups = Math.max(1, Number(subjectRow.group_count || 1));
    const shouldSplitAllGroups = !groupNumber && isSeminar && totalGroups > 1;
    if (shouldSplitAllGroups) {
      const stmt = db.prepare(
        `
          INSERT INTO schedule_generator_items
            (run_id, course_id, semester_id, subject_id, teacher_id, lesson_type, group_number, pairs_count, weeks_set, fixed_day, fixed_class_number, mirror_key)
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `
      );
      for (let g = 1; g <= totalGroups; g += 1) {
        stmt.run(
          runId,
          courseId,
          semester.id,
          subjectId,
          teacherIdRaw || null,
          lessonType,
          g,
          pairsCount,
          weeksSet || null,
          fixedDay,
          fixedClass || null,
          mirrorKey
        );
      }
      await stmt.finalize();
    } else {
      await db.run(
        `
          INSERT INTO schedule_generator_items
            (run_id, course_id, semester_id, subject_id, teacher_id, lesson_type, group_number, pairs_count, weeks_set, fixed_day, fixed_class_number, mirror_key)
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `,
        [
          runId,
          courseId,
          semester.id,
          subjectId,
          teacherIdRaw || null,
          lessonType,
          groupNumber,
          pairsCount,
          weeksSet || null,
          fixedDay,
          fixedClass || null,
          mirrorKey,
        ]
      );
    }
    return res.redirect(`/admin/schedule-generator?run=${runId}&ok=Item%20added`);
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleGenerator.item.add');
  }
});

app.post('/admin/schedule-generator/mirror-auto', requireScheduleGeneratorSectionAccess, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleGenerator.mirrorAuto');
  }
  const runId = Number(req.body.run_id);
  if (!Number.isFinite(runId) || runId <= 0) {
    return res.redirect('/admin/schedule-generator?err=Invalid%20run');
  }
  const pairsRaw = req.body.mirror_pairs || [];
  const pairs = Array.isArray(pairsRaw) ? pairsRaw : pairsRaw ? [pairsRaw] : [];
  if (!pairs.length) {
    return res.redirect(`/admin/schedule-generator?run=${runId}&err=No%20pairs%20selected`);
  }
  const run = await db.get('SELECT id FROM schedule_generator_runs WHERE id = ?', [runId]);
  if (!run) {
    return res.redirect('/admin/schedule-generator?err=Run%20not%20found');
  }
  let updated = 0;
  for (const pair of pairs) {
    const [aRaw, bRaw] = String(pair || '').split(':');
    const aId = Number(aRaw);
    const bId = Number(bRaw);
    if (!Number.isFinite(aId) || !Number.isFinite(bId)) continue;
    const items = await db.all(
      `
        SELECT sgi.*, s.name AS subject_name, s.is_general
        FROM schedule_generator_items sgi
        JOIN subjects s ON s.id = sgi.subject_id
        WHERE sgi.run_id = ? AND sgi.id IN (?, ?)
      `,
      [runId, aId, bId]
    );
    if (!items || items.length < 2) continue;
    const a = items.find((row) => Number(row.id) === aId);
    const b = items.find((row) => Number(row.id) === bId);
    if (!a || !b) continue;
    if (Number(a.group_number) !== 1 || Number(b.group_number) !== 2) continue;
    if (Number(a.course_id) !== Number(b.course_id)) continue;
    if (Number(a.semester_id || 0) !== Number(b.semester_id || 0)) continue;
    if (String(a.lesson_type || '') !== String(b.lesson_type || '')) continue;
    if (Number(a.pairs_count || 0) !== Number(b.pairs_count || 0)) continue;
    if (a.fixed_day || a.fixed_class_number || a.weeks_set) continue;
    if (b.fixed_day || b.fixed_class_number || b.weeks_set) continue;
    if (a.mirror_key || b.mirror_key) continue;
    const lessonType = String(a.lesson_type || '').toLowerCase();
    if (!(lessonType.includes('seminar') || lessonType.includes('сем'))) continue;
    if (Number(a.subject_id) === Number(b.subject_id)) continue;
    const key = `AUTO-${aId.toString(36).toUpperCase()}${bId.toString(36).toUpperCase()}`;
    await db.run(
      'UPDATE schedule_generator_items SET mirror_key = ? WHERE run_id = ? AND id IN (?, ?)',
      [key, runId, aId, bId]
    );
    updated += 1;
  }
  if (!updated) {
    return res.redirect(`/admin/schedule-generator?run=${runId}&err=No%20pairs%20updated`);
  }
  return res.redirect(`/admin/schedule-generator?run=${runId}&ok=Auto%20mirror%20pairs%20applied`);
});

app.post('/admin/schedule-generator/items/edit/:id', requireScheduleGeneratorSectionAccess, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleGenerator.item.edit');
  }
  const itemId = Number(req.params.id);
  const runId = Number(req.body.run_id);
  const courseId = Number(req.body.course_id);
  const subjectId = Number(req.body.subject_id);
  const teacherIdRaw = req.body.teacher_id ? Number(req.body.teacher_id) : null;
  const lessonTypeRaw = String(req.body.lesson_type || 'lecture').trim();
  const lessonType = lessonTypeRaw || 'lecture';
  const groupRaw = String(req.body.group_number || 'all');
  const groupNumber = groupRaw === 'all' || groupRaw === '0' ? null : Number(groupRaw);
  const pairsCount = Number(req.body.pairs_count);
  const weeksSet = String(req.body.weeks_set || '').trim();
  const fixedDay = normalizeWeekdayName(req.body.fixed_day);
  const fixedClass = req.body.fixed_class_number ? Number(req.body.fixed_class_number) : null;
  const mirrorKeyRaw = String(req.body.mirror_key || '').trim();
  const mirrorKey = mirrorKeyRaw || null;

  if (!Number.isFinite(itemId) || !Number.isFinite(runId) || runId <= 0) {
    return res.redirect('/admin/schedule-generator?err=Invalid%20item');
  }
  if (!Number.isFinite(pairsCount) || pairsCount <= 0) {
    return res.redirect(`/admin/schedule-generator?run=${runId}&err=Invalid%20pairs`);
  }
  if (groupNumber && (Number.isNaN(groupNumber) || groupNumber < 1)) {
    return res.redirect(`/admin/schedule-generator?run=${runId}&err=Invalid%20group`);
  }
  if (fixedClass && (fixedClass < 1 || fixedClass > 7)) {
    return res.redirect(`/admin/schedule-generator?run=${runId}&err=Invalid%20slot`);
  }

  try {
    const subjectRow = await db.get('SELECT id, group_count FROM subjects WHERE id = ? AND course_id = ?', [subjectId, courseId]);
    if (!subjectRow) {
      return res.redirect(`/admin/schedule-generator?run=${runId}&err=Subject%20not%20found`);
    }
    if (groupNumber && Number(groupNumber) > Number(subjectRow.group_count || 1)) {
      return res.redirect(`/admin/schedule-generator?run=${runId}&err=Invalid%20group`);
    }
    const run = await db.get('SELECT config FROM schedule_generator_runs WHERE id = ?', [runId]);
    if (!run) {
      return res.redirect(`/admin/schedule-generator?run=${runId}&err=Run%20not%20found`);
    }
    const runConfig = parseGeneratorConfig(run.config);
    const courseRow = await db.get('SELECT location FROM courses WHERE id = ?', [courseId]);
    const courseLocation = String(courseRow?.location || 'kyiv').toLowerCase() === 'munich' ? 'munich' : 'kyiv';
    const configuredSemesterId = runConfig.course_semesters_by_location
      ? runConfig.course_semesters_by_location[courseLocation]?.[courseId]
        || runConfig.course_semesters_by_location[courseLocation]?.[String(courseId)]
      : null;
    let semester = null;
    if (configuredSemesterId) {
      semester = await db.get('SELECT id FROM semesters WHERE id = ? AND course_id = ?', [configuredSemesterId, courseId]);
    }
    if (!semester) {
      semester = await getActiveSemester(courseId);
    }
    if (!semester) {
      return res.redirect(`/admin/schedule-generator?run=${runId}&err=Semester%20not%20found`);
    }
    await db.run(
      `
        UPDATE schedule_generator_items
        SET course_id = ?, semester_id = ?, subject_id = ?, teacher_id = ?, lesson_type = ?, group_number = ?, pairs_count = ?, weeks_set = ?, fixed_day = ?, fixed_class_number = ?, mirror_key = ?
        WHERE id = ? AND run_id = ?
      `,
      [
        courseId,
        semester.id,
        subjectId,
        teacherIdRaw || null,
        lessonType,
        groupNumber,
        pairsCount,
        weeksSet || null,
        fixedDay,
        fixedClass || null,
        mirrorKey,
        itemId,
        runId,
      ]
    );
    return res.redirect(`/admin/schedule-generator?run=${runId}&ok=Item%20saved`);
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleGenerator.item.edit');
  }
});

app.post('/admin/schedule-generator/items/delete/:id', requireScheduleGeneratorSectionAccess, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleGenerator.item.delete');
  }
  const itemId = Number(req.params.id);
  const runId = Number(req.body.run_id);
  if (!Number.isFinite(itemId) || !Number.isFinite(runId) || runId <= 0) {
    return res.redirect('/admin/schedule-generator?err=Invalid%20item');
  }
  try {
    await db.run('DELETE FROM schedule_generator_items WHERE id = ? AND run_id = ?', [itemId, runId]);
    return res.redirect(`/admin/schedule-generator?run=${runId}&ok=Item%20deleted`);
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleGenerator.item.delete');
  }
});

app.post('/admin/schedule-generator/items/freeze/:id', requireScheduleGeneratorSectionAccess, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleGenerator.item.freeze');
  }
  const itemId = Number(req.params.id);
  const runId = Number(req.body.run_id);
  if (!Number.isFinite(itemId) || !Number.isFinite(runId) || runId <= 0) {
    return res.redirect('/admin/schedule-generator?err=Invalid%20item');
  }
  try {
    const item = await db.get(
      'SELECT * FROM schedule_generator_items WHERE id = ? AND run_id = ?',
      [itemId, runId]
    );
    if (!item) {
      return res.redirect(`/admin/schedule-generator?run=${runId}&err=Item%20not%20found`);
    }
    let slot = await db.get(
      `
        SELECT day_of_week, class_number, COUNT(*) as cnt
        FROM schedule_generator_entries
        WHERE run_id = ? AND item_id = ?
        GROUP BY day_of_week, class_number
        ORDER BY cnt DESC
        LIMIT 1
      `,
      [runId, itemId]
    );
    if (!slot) {
      const params = [runId, item.course_id, item.subject_id];
      let where = 'run_id = ? AND course_id = ? AND subject_id = ?';
      if (item.group_number) {
        where += ' AND group_number = ?';
        params.push(item.group_number);
      }
      slot = await db.get(
        `
          SELECT day_of_week, class_number, COUNT(*) as cnt
          FROM schedule_generator_entries
          WHERE ${where}
          GROUP BY day_of_week, class_number
          ORDER BY cnt DESC
          LIMIT 1
        `,
        params
      );
    }
    if (!slot) {
      return res.redirect(`/admin/schedule-generator?run=${runId}&err=No%20generated%20slot`);
    }
    await db.run(
      'UPDATE schedule_generator_items SET fixed_day = ?, fixed_class_number = ? WHERE id = ? AND run_id = ?',
      [slot.day_of_week, slot.class_number, itemId, runId]
    );
    return res.redirect(`/admin/schedule-generator?run=${runId}&ok=Slot%20fixed`);
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleGenerator.item.freeze');
  }
});

app.post('/admin/schedule-generator/items/unfreeze/:id', requireScheduleGeneratorSectionAccess, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleGenerator.item.unfreeze');
  }
  const itemId = Number(req.params.id);
  const runId = Number(req.body.run_id);
  if (!Number.isFinite(itemId) || !Number.isFinite(runId) || runId <= 0) {
    return res.redirect('/admin/schedule-generator?err=Invalid%20item');
  }
  try {
    await db.run(
      'UPDATE schedule_generator_items SET fixed_day = NULL, fixed_class_number = NULL WHERE id = ? AND run_id = ?',
      [itemId, runId]
    );
    return res.redirect(`/admin/schedule-generator?run=${runId}&ok=Slot%20unfixed`);
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleGenerator.item.unfreeze');
  }
});

app.post('/admin/schedule-generator/teachers/save', requireScheduleGeneratorSectionAccess, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleGenerator.teacher');
  }
  const runId = Number(req.body.run_id);
  const teacherId = Number(req.body.teacher_id);
  if (!Number.isFinite(runId) || runId <= 0 || !Number.isFinite(teacherId)) {
    return res.redirect('/admin/schedule-generator?err=Invalid%20teacher');
  }
  const allowedDaysRaw = normalizeGeneratorDays(req.body.allowed_days);
  const allowedDays = allowedDaysRaw
    .map((day) => normalizeWeekdayName(day))
    .filter(Boolean);
  const maxPairsRaw = Number(req.body.max_pairs_per_week);
  const maxPairs = Number.isNaN(maxPairsRaw) || maxPairsRaw <= 0 ? null : maxPairsRaw;

  try {
    await db.run(
      `
        INSERT INTO schedule_generator_teacher_limits (run_id, teacher_id, allowed_weekdays, max_pairs_per_week)
        VALUES (?, ?, ?, ?)
        ON CONFLICT (run_id, teacher_id)
        DO UPDATE SET allowed_weekdays = EXCLUDED.allowed_weekdays, max_pairs_per_week = EXCLUDED.max_pairs_per_week, updated_at = NOW()
      `,
      [runId, teacherId, allowedDays.join(','), maxPairs]
    );
    return res.redirect(`/admin/schedule-generator?run=${runId}&ok=Teacher%20saved`);
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleGenerator.teacher.save');
  }
});

app.post('/admin/schedule-generator/run', requireScheduleGeneratorSectionAccess, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleGenerator.run');
  }
  const runId = Number(req.body.run_id);
  const courseOnlyRaw = Number(req.body.course_id);
  const courseOnly = Number.isFinite(courseOnlyRaw) && courseOnlyRaw > 0 ? courseOnlyRaw : null;
  const scopeWeekFromRaw = Number(req.body.scope_week_from);
  const scopeWeekToRaw = Number(req.body.scope_week_to);
  const scopeWeeksInput = String(req.body.scope_weeks || '').trim();
  let scopeWeeks = [];
  if (scopeWeeksInput) {
    scopeWeeks = parseWeekSet(scopeWeeksInput, 0);
  } else if (Number.isFinite(scopeWeekFromRaw) && Number.isFinite(scopeWeekToRaw)) {
    const start = Math.max(1, Math.min(scopeWeekFromRaw, scopeWeekToRaw));
    const end = Math.max(scopeWeekFromRaw, scopeWeekToRaw);
    for (let week = start; week <= end; week += 1) {
      scopeWeeks.push(week);
    }
  }
  const scopeGroupsRaw = Array.isArray(req.body.scope_groups)
    ? req.body.scope_groups
    : req.body.scope_groups
    ? [req.body.scope_groups]
    : [];
  const scopeGroups = scopeGroupsRaw
    .map((value) => Number(value))
    .filter((value) => Number.isFinite(value) && value > 0);
  const scopeDays = normalizeGeneratorDays(req.body.scope_days)
    .map((day) => normalizeWeekdayName(day))
    .filter(Boolean);
  const scopeSemesterRaw = Number(req.body.scope_semester_id);
  const scopeSemesterId = Number.isFinite(scopeSemesterRaw) && scopeSemesterRaw > 0 ? scopeSemesterRaw : null;
  if (!Number.isFinite(runId) || runId <= 0) {
    return res.redirect('/admin/schedule-generator?err=Invalid%20run');
  }
  try {
    const run = await db.get('SELECT * FROM schedule_generator_runs WHERE id = ?', [runId]);
    if (!run) return res.redirect('/admin/schedule-generator?err=Run%20not%20found');
    const config = parseGeneratorConfig(run.config);
    const requestedLocation = String(req.body.active_location || config.active_location || 'kyiv').toLowerCase();
    const activeLocation = requestedLocation === 'munich' ? 'munich' : 'kyiv';
    if (activeLocation !== config.active_location) {
      config.active_location = activeLocation;
    }
    const locationCourses = await getCoursesByLocation(activeLocation);
    const locationCourseIds = new Set((locationCourses || []).map((c) => Number(c.id)));
    if (courseOnly && !locationCourseIds.has(courseOnly)) {
      return res.redirect(`/admin/schedule-generator?run=${runId}&err=Course%20not%20in%20location`);
    }
    const itemsAll = await db.all(
      `
        SELECT sgi.*, s.name AS subject_name, s.group_count, s.is_general
        FROM schedule_generator_items sgi
        JOIN subjects s ON s.id = sgi.subject_id
        WHERE sgi.run_id = ?
      `,
      [runId]
    );
    const items = (itemsAll || []).filter((item) =>
      locationCourseIds.has(Number(item.course_id)) &&
      (!courseOnly || Number(item.course_id) === courseOnly)
    );
    if (!items.length) {
      return res.redirect(`/admin/schedule-generator?run=${runId}&err=No%20items%20for%20location`);
    }

    const courseContexts = new Map();
    const courseIds = Array.from(new Set(items.map((item) => String(item.course_id))));
    for (const courseId of courseIds) {
      const configuredSemesterId = getConfiguredCourseSemesterId(config, courseId, activeLocation);
      let semester = null;
      if (configuredSemesterId) {
        semester = await db.get('SELECT * FROM semesters WHERE id = ? AND course_id = ?', [configuredSemesterId, courseId]);
      }
      if (!semester) {
        semester = await getActiveSemester(courseId);
      }
      if (!semester) continue;
      const studyDays = await getCourseStudyDays(courseId);
      const activeDays = (studyDays || [])
        .filter((d) => d.is_active)
        .map((d) => d.day_name)
        .filter(Boolean);
      courseContexts.set(String(courseId), {
        course_id: Number(courseId),
        semester_id: semester.id,
        weeks_count: Number(semester.weeks_count || 15),
        active_days: activeDays.length ? activeDays : [...daysOfWeek],
      });
    }

    const limitsRows = await db.all(
      'SELECT * FROM schedule_generator_teacher_limits WHERE run_id = ?',
      [runId]
    );
    const limitsMap = new Map();
    limitsRows.forEach((row) => {
      limitsMap.set(String(row.teacher_id), {
        allowed_days: row.allowed_weekdays ? row.allowed_weekdays.split(',') : [],
        max_pairs_per_week: row.max_pairs_per_week,
      });
    });

    const normalizedItems = items.map((item) => ({
      ...item,
      semester_id: (courseContexts.get(String(item.course_id)) || {}).semester_id || item.semester_id,
    }));

    let existingEntries = [];
    if (courseOnly) {
      const otherCourseIds = Array.from(locationCourseIds).filter((id) => id !== courseOnly);
      if (otherCourseIds.length) {
        const placeholders = otherCourseIds.map(() => '?').join(',');
        existingEntries = await db.all(
          `
            SELECT teacher_id, day_of_week, class_number, week_number
            FROM schedule_generator_entries
            WHERE run_id = ? AND course_id IN (${placeholders})
          `,
          [runId, ...otherCourseIds]
        );
      }
    }

    const result = generateSchedule({
      items: normalizedItems,
      courseContexts,
      teacherLimits: limitsMap,
      config,
      existingEntries,
    });

    const scopeWeekSet = scopeWeeks.length ? new Set(scopeWeeks) : null;
    const scopeGroupSet = scopeGroups.length ? new Set(scopeGroups) : null;
    const scopeDaySet = scopeDays.length ? new Set(scopeDays) : null;
    const filteredEntries = (result.entries || []).filter((entry) => {
      if (scopeSemesterId && Number(entry.semester_id) !== Number(scopeSemesterId)) return false;
      if (scopeWeekSet && !scopeWeekSet.has(Number(entry.week_number))) return false;
      if (scopeGroupSet && !scopeGroupSet.has(Number(entry.group_number))) return false;
      if (scopeDaySet && !scopeDaySet.has(entry.day_of_week)) return false;
      return true;
    });
    if (!filteredEntries.length) {
      return res.redirect(`/admin/schedule-generator?run=${runId}&err=No%20entries%20for%20scope`);
    }
    const operationId = randomUUID();
    const diffResult = await buildScheduleDiff(filteredEntries);
    const nextConfig = {
      ...config,
      last_stats: {
        generated_at: new Date().toISOString(),
        items: normalizedItems.length,
        entries: filteredEntries.length,
        conflicts: result.conflicts.length,
        diff: diffResult.diff,
        operation_id: operationId,
        scope: {
          type: courseOnly ? 'course' : 'location',
          location: activeLocation,
          course_id: courseOnly,
          semester_id: scopeSemesterId,
          weeks: scopeWeeks,
          groups: scopeGroups,
          days: scopeDays,
        },
      },
      last_conflicts: result.conflicts,
    };
    await withTransaction(async (client) => {
      if (courseOnly) {
        await txRun(
          client,
          'DELETE FROM schedule_generator_entries WHERE run_id = ? AND course_id = ?',
          [runId, courseOnly]
        );
      } else if (courseIds.length) {
        const placeholders = courseIds.map(() => '?').join(',');
        await txRun(
          client,
          `DELETE FROM schedule_generator_entries WHERE run_id = ? AND course_id IN (${placeholders})`,
          [runId, ...courseIds]
        );
      }
      const insertSql = `
        INSERT INTO schedule_generator_entries
          (run_id, item_id, course_id, semester_id, subject_id, teacher_id, lesson_type, group_number, day_of_week, class_number, week_number, is_mirror, mirror_key)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `;
      for (const entry of filteredEntries) {
        await txRun(
          client,
          insertSql,
          [
            runId,
            entry.item_id || null,
            entry.course_id,
            entry.semester_id,
            entry.subject_id,
            entry.teacher_id,
            entry.lesson_type || null,
            entry.group_number,
            entry.day_of_week,
            entry.class_number,
            entry.week_number,
            Boolean(entry.is_mirror),
            entry.mirror_key || null,
          ]
        );
      }
      await txRun(
        client,
        'UPDATE schedule_generator_runs SET config = ?, updated_at = NOW() WHERE id = ?',
        [serializeGeneratorConfig(nextConfig), runId]
      );
    });

    const firstCourse = courseOnly || (normalizedItems[0] ? normalizedItems[0].course_id : courseIds[0]);
    return res.redirect(`/admin/schedule-generator/${runId}/preview?course=${firstCourse}&week=1`);
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleGenerator.run');
  }
});

app.get('/admin/schedule-generator/:runId/preview', requireScheduleGeneratorSectionAccess, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleGenerator.preview');
  }
  const runId = Number(req.params.runId);
  const courseId = Number(req.query.course);
  if (!Number.isFinite(runId) || runId <= 0) {
    return res.redirect('/admin/schedule-generator?err=Invalid%20run');
  }
  try {
    const run = await db.get('SELECT * FROM schedule_generator_runs WHERE id = ?', [runId]);
    if (!run) return res.redirect('/admin/schedule-generator?err=Run%20not%20found');
    const config = parseGeneratorConfig(run.config);
    const activeLocation = config.active_location === 'munich' ? 'munich' : 'kyiv';
    const coursesByLocation = {
      kyiv: await getCoursesByLocation('kyiv'),
      munich: await getCoursesByLocation('munich'),
    };
    const allCourses = [...(coursesByLocation.kyiv || []), ...(coursesByLocation.munich || [])];
    const availableCourseIds = allCourses.map((c) => Number(c.id));
    const preferredList = coursesByLocation[activeLocation] || [];
    const fallbackCourseId = preferredList.length ? Number(preferredList[0].id) : availableCourseIds[0];
    const selectedCourseId = availableCourseIds.includes(courseId) ? courseId : fallbackCourseId;
    if (!selectedCourseId) {
      return res.redirect('/admin/schedule-generator?run=' + runId);
    }
    const selectedCourse = allCourses.find((course) => Number(course.id) === Number(selectedCourseId));
    const selectedLocation = normalizeGeneratorLocation(selectedCourse?.location || activeLocation);
    const configuredSemesterId = getConfiguredCourseSemesterId(config, selectedCourseId, selectedLocation);
    let activeSemester = null;
    if (configuredSemesterId) {
      activeSemester = await db.get('SELECT * FROM semesters WHERE id = ? AND course_id = ?', [configuredSemesterId, selectedCourseId]);
    }
    if (!activeSemester) {
      activeSemester = await getActiveSemester(selectedCourseId);
    }
    const totalWeeks = activeSemester && activeSemester.weeks_count ? Number(activeSemester.weeks_count) : 15;
    let selectedWeek = Number(req.query.week);
    if (Number.isNaN(selectedWeek) || selectedWeek < 1) selectedWeek = 1;
    if (selectedWeek > totalWeeks) selectedWeek = totalWeeks;

    const studyDays = await getCourseStudyDays(selectedCourseId);
    let activeDays = (studyDays || [])
      .filter((d) => d.is_active)
      .map((d) => d.day_name)
      .filter(Boolean);
    if (!activeDays.length) {
      activeDays = [...daysOfWeek];
    }
    const weekDates = fullWeekDays.map((_, idx) =>
      getDateForWeekIndex(selectedWeek, idx, activeSemester ? activeSemester.start_date : null)
    );
    const dayDates = {};
    activeDays.forEach((day) => {
      const idx = fullWeekDays.indexOf(day);
      dayDates[day] = idx >= 0 ? weekDates[idx] : null;
    });

    const scheduleByDay = {};
    activeDays.forEach((day) => {
      scheduleByDay[day] = [];
    });

    const rows = await db.all(
      `
        SELECT sge.*, s.name AS subject_name, u.full_name AS teacher_name
        FROM schedule_generator_entries sge
        JOIN subjects s ON s.id = sge.subject_id
        LEFT JOIN users u ON u.id = sge.teacher_id
        WHERE sge.run_id = ? AND sge.course_id = ? AND sge.week_number = ?
      `,
      [runId, selectedCourseId, selectedWeek]
    );
    const grouped = new Map();
    (rows || []).forEach((row) => {
      const key = `${row.subject_id}|${row.day_of_week}|${row.class_number}|${row.teacher_id || 0}|${row.lesson_type || ''}|${row.is_mirror ? 1 : 0}|${row.mirror_key || ''}`;
      if (!grouped.has(key)) {
        grouped.set(key, { ...row, group_numbers: new Set() });
      }
      grouped.get(key).group_numbers.add(Number(row.group_number));
    });
    grouped.forEach((entry) => {
      const groups = Array.from(entry.group_numbers).sort((a, b) => a - b);
      const groupLabel = groups.length === 1 ? `Група ${groups[0]}` : `Групи: ${groups.join(', ')}`;
      const normalized = {
        ...entry,
        group_numbers: groups,
        group_label: groupLabel,
        is_mirror: Boolean(entry.is_mirror),
        mirror_key: entry.mirror_key ? String(entry.mirror_key).trim() : null,
      };
      if (scheduleByDay[entry.day_of_week]) {
        scheduleByDay[entry.day_of_week].push(normalized);
      }
    });
    activeDays.forEach((day) => {
      scheduleByDay[day].sort((a, b) => a.class_number - b.class_number);
    });

    const lastStats = config.last_stats || null;
    const overwriteCount = lastStats && lastStats.diff ? Number(lastStats.diff.overwrite || 0) : 0;
    const publishRequiresTyped = overwriteCount > IMPORT_CONFIRM_THRESHOLD;

    const publishSummary = req.query.published
      ? {
          operation_id: req.query.op || '',
          added: Number(req.query.added || 0),
          updated: Number(req.query.updated || 0),
          removed: Number(req.query.removed || 0),
          overwrite: Number(req.query.overwrite || 0),
          backup: req.query.backup || '',
        }
      : null;

    return res.render('admin-schedule-generator-preview', {
      username: req.session.user.username,
      role: req.session.role,
      run,
      courses: allCourses,
      selectedCourseId,
      scheduleByDay,
      daysOfWeek: activeDays,
      dayDates,
      currentWeek: selectedWeek,
      totalWeeks,
      semester: activeSemester,
      bellSchedule,
      config,
      lastStats,
      publishRequiresTyped,
      publishSummary,
    });
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleGenerator.preview');
  }
});

app.get('/admin/schedule-generator/backup.csv', requireScheduleGeneratorSectionAccess, (req, res) => {
  const operationId = String(req.query.op || '').trim();
  if (!operationId) {
    return res.status(400).send('Missing operation id');
  }
  const backupPath = path.join(uploadsDir, 'generator-backups', `schedule-backup-${operationId}.csv`);
  if (!fs.existsSync(backupPath)) {
    return res.status(404).send('Backup not found');
  }
  res.setHeader('Content-Type', 'text/csv');
  res.setHeader('Content-Disposition', `attachment; filename="schedule-backup-${operationId}.csv"`);
  return res.sendFile(backupPath);
});

app.post('/admin/schedule-generator/:runId/publish', requireScheduleGeneratorSectionAccess, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleGenerator.publish');
  }
  const runId = Number(req.params.runId);
  const buildPreviewRedirect = (message) => {
    const params = new URLSearchParams();
    const courseId = Number(req.body.course_id);
    const week = Number(req.body.week);
    if (Number.isFinite(courseId) && courseId > 0) {
      params.set('course', String(courseId));
    }
    if (Number.isFinite(week) && week > 0) {
      params.set('week', String(week));
    }
    if (message) {
      params.set('err', String(message));
    }
    const query = params.toString();
    return `/admin/schedule-generator/${runId}/preview${query ? `?${query}` : ''}`;
  };
  if (!Number.isFinite(runId) || runId <= 0) {
    return res.redirect('/admin/schedule-generator?err=Invalid%20run');
  }
  const replace = String(req.body.replace || '') === '1' || String(req.body.replace || '') === 'on';
  try {
    const run = await db.get('SELECT * FROM schedule_generator_runs WHERE id = ?', [runId]);
    if (!run) return res.redirect('/admin/schedule-generator?err=Run%20not%20found');
    const config = parseGeneratorConfig(run.config);
    const lastOperationId = config && config.last_stats ? config.last_stats.operation_id : null;
    const requestedOperationId = String(req.body.operation_id || '').trim();
    if (lastOperationId && requestedOperationId && lastOperationId !== requestedOperationId) {
      return res.redirect(buildPreviewRedirect('Preview outdated'));
    }
    const operationId = requestedOperationId || lastOperationId || randomUUID();
    const entries = await db.all(
      `
        SELECT run_id, course_id, semester_id, subject_id, group_number, day_of_week, class_number, week_number, lesson_type
        FROM schedule_generator_entries
        WHERE run_id = ?
      `,
      [runId]
    );
    if (!entries.length) {
      return res.redirect(buildPreviewRedirect('No entries'));
    }
    const diffResult = await buildScheduleDiff(entries);
    const overwriteCount = diffResult.diff.overwrite;
    const confirmOverwrite = String(req.body.confirm_overwrite || '') === '1' || String(req.body.confirm_overwrite || '') === 'on';
    if (!confirmOverwrite) {
      return res.redirect(buildPreviewRedirect('Confirm overwrite'));
    }
    const requiresTyped = overwriteCount > IMPORT_CONFIRM_THRESHOLD;
    const confirmPhrase = String(req.body.confirm_phrase || '').trim().toUpperCase();
    if (requiresTyped && confirmPhrase !== 'PUBLISH') {
      return res.redirect(buildPreviewRedirect('Type PUBLISH to confirm'));
    }

    let backupInfo = null;
    if (diffResult.existing && diffResult.existing.length) {
      backupInfo = writeGeneratorBackupCsv(diffResult.existing, operationId);
      if (backupInfo) {
        logAction(db, req, 'generator_backup_created', {
          operation_id: operationId,
          file: backupInfo.filename,
          entries: diffResult.existing.length,
        });
      }
    }
    await withTransaction(async (client) => {
      if (replace) {
        const pairs = new Map();
        entries.forEach((entry) => {
          const key = `${entry.course_id}|${entry.semester_id}`;
          pairs.set(key, { course_id: entry.course_id, semester_id: entry.semester_id });
        });
        for (const pair of pairs.values()) {
          await txRun(
            client,
            'DELETE FROM schedule_entries WHERE course_id = ? AND semester_id = ?',
            [pair.course_id, pair.semester_id]
          );
        }
      }
      const insertSql = `
        INSERT INTO schedule_entries (subject_id, group_number, day_of_week, class_number, week_number, course_id, semester_id, lesson_type)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      `;
      for (const entry of entries) {
        await txRun(
          client,
          insertSql,
          [
            entry.subject_id,
            entry.group_number,
            entry.day_of_week,
            entry.class_number,
            entry.week_number,
            entry.course_id,
            entry.semester_id,
            entry.lesson_type || null,
          ]
        );
      }
      await txRun(
        client,
        'UPDATE schedule_generator_runs SET status = ?, updated_at = NOW() WHERE id = ?',
        ['published', runId]
      );
    });
    logAction(db, req, 'schedule_generator_publish', {
      run_id: runId,
      replace,
      operation_id: operationId,
      diff: diffResult.diff,
    });
    const courseId = Number(req.body.course_id) || Number(entries[0].course_id);
    const week = Number(req.body.week) || 1;
    const query = new URLSearchParams({
      course: String(courseId),
      week: String(week),
      published: '1',
      op: operationId,
      added: String(diffResult.diff.added),
      updated: String(diffResult.diff.updated),
      removed: String(diffResult.diff.removed),
      overwrite: String(diffResult.diff.overwrite),
      backup: backupInfo ? operationId : '',
    });
    return res.redirect(`/admin/schedule-generator/${runId}/preview?${query.toString()}`);
  } catch (err) {
    return handleDbError(res, err, 'admin.scheduleGenerator.publish');
  }
});

const resolveSchedulerIntervalMs = () => {
  const raw = Number(process.env.SCHEDULER_INTERVAL_MS || 60000);
  if (!Number.isFinite(raw)) return 60000;
  return Math.floor(raw);
};
const schedulerIntervalMs = resolveSchedulerIntervalMs();
let schedulerRunning = false;
const publishScheduledItems = async () => {
  if (schedulerRunning) {
    schedulerHealthState.skipped_count += 1;
    return { messages: 0, homework: 0, skipped: true };
  }
  const startedAt = Date.now();
  schedulerRunning = true;
  schedulerHealthState.running = true;
  schedulerHealthState.last_started_at = new Date(startedAt).toISOString();
  try {
    await ensureDbReady();
    const nowIso = new Date().toISOString();
    const msgResult = settingsCache.allow_messages
      ? await db.run(
          `UPDATE messages
           SET status = 'published', published_at = ?
           WHERE status = 'scheduled' AND scheduled_at IS NOT NULL AND scheduled_at <= ?`,
          [nowIso, nowIso]
        )
      : { changes: 0 };
    const hwResult = await db.run(
      `UPDATE homework
       SET status = 'published', published_at = ?
       WHERE status = 'scheduled' AND scheduled_at IS NOT NULL AND scheduled_at <= ?`,
      [nowIso, nowIso]
    );
    const messages = Number(msgResult?.changes || 0);
    const homework = Number(hwResult?.changes || 0);
    if (messages) {
      broadcast('messages_updated');
    }
    if (homework) {
      broadcast('homework_updated');
    }
    const result = { messages, homework, skipped: false };
    schedulerHealthState.run_count += 1;
    schedulerHealthState.last_run_at = nowIso;
    schedulerHealthState.last_duration_ms = Math.max(0, Date.now() - startedAt);
    schedulerHealthState.last_result = result;
    schedulerHealthState.last_error = null;
    return result;
  } catch (err) {
    const message = normalizeRuntimeErrorMessage(err && err.message ? err.message : err);
    schedulerHealthState.error_count += 1;
    schedulerHealthState.last_error_at = new Date().toISOString();
    schedulerHealthState.last_error = message;
    pushRuntimeErrorEvent('scheduler', 'publishScheduledItems', message);
    throw err;
  } finally {
    schedulerRunning = false;
    schedulerHealthState.running = false;
  }
};

const publishScheduleItems = publishScheduledItems;

app.post('/admin/api/scheduler/run', requireScheduleGeneratorSectionAccess, async (req, res) => {
  try {
    const result = await publishScheduledItems();
    return res.json({ ok: true, ...result });
  } catch (err) {
    return res.status(500).json({ error: 'Database error' });
  }
});
      }
    );
  });
});
});

app.post('/admin/settings', requireSettingsSectionAccess, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'admin.settings.init');
  }
  const body = req.body && typeof req.body === 'object' ? req.body : {};
  const sessionDays = Number(body.session_duration_days);
  const maxFileSize = Number(body.max_file_size_mb);
  const minTeamMembers = Number(body.min_team_members);
  const allowHomework = String(body.allow_homework_creation).toLowerCase() === 'true';
  const allowCustomDeadlines = String(body.allow_custom_deadlines).toLowerCase() === 'true';
  const myDayShowStudentHomeworkSource = Object.prototype.hasOwnProperty.call(body, 'myday_show_student_homework')
    ? body.myday_show_student_homework
    : settingsCache.myday_show_student_homework;
  const myDayShowStudentHomework = String(myDayShowStudentHomeworkSource).toLowerCase() === 'true';
  const allowMessages = String(body.allow_messages).toLowerCase() === 'true';
  const scheduleRefreshMinutes = Number(body.schedule_refresh_minutes);
  const siteVisitRetentionDays = Number(body.site_visit_retention_days);
  const loginHistoryRetentionDays = Number(body.login_history_retention_days);
  const activityLogRetentionDays = Number(body.activity_log_retention_days);
  const securityAllowlistSource = Object.prototype.hasOwnProperty.call(body, 'security_admin_ip_allowlist')
    ? body.security_admin_ip_allowlist
    : settingsCache.security_admin_ip_allowlist;
  const securityAdminIpAllowlist = String(securityAllowlistSource || '');
  const thresholdRaw = Object.prototype.hasOwnProperty.call(body, 'security_registration_alert_threshold')
    ? body.security_registration_alert_threshold
    : settingsCache.security_registration_alert_threshold;
  const thresholdProvided = thresholdRaw !== undefined && thresholdRaw !== null && String(thresholdRaw).trim() !== '';
  const thresholdParsed = Number(thresholdRaw);
  const securityRegistrationAlertThreshold = thresholdProvided
    ? thresholdParsed
    : Number(settingsCache.security_registration_alert_threshold || DEFAULT_SETTINGS.security_registration_alert_threshold);
  const windowRaw = Object.prototype.hasOwnProperty.call(body, 'security_registration_alert_window_minutes')
    ? body.security_registration_alert_window_minutes
    : settingsCache.security_registration_alert_window_minutes;
  const windowProvided = windowRaw !== undefined && windowRaw !== null && String(windowRaw).trim() !== '';
  const windowParsed = Number(windowRaw);
  const securityRegistrationAlertWindowMinutes = windowProvided
    ? windowParsed
    : Number(settingsCache.security_registration_alert_window_minutes || DEFAULT_SETTINGS.security_registration_alert_window_minutes);
  const securityAutoQuarantineSource = Object.prototype.hasOwnProperty.call(body, 'security_auto_quarantine_enabled')
    ? body.security_auto_quarantine_enabled
    : settingsCache.security_auto_quarantine_enabled;
  const securityAutoQuarantineEnabled = String(securityAutoQuarantineSource).toLowerCase() === 'true';
  const securityIpRetentionRaw = Object.prototype.hasOwnProperty.call(body, 'security_ip_retention_days')
    ? body.security_ip_retention_days
    : settingsCache.security_ip_retention_days;
  const securityUaRetentionRaw = Object.prototype.hasOwnProperty.call(body, 'security_user_agent_retention_days')
    ? body.security_user_agent_retention_days
    : settingsCache.security_user_agent_retention_days;
  const securityIpRetentionDays = Number(securityIpRetentionRaw);
  const securityUserAgentRetentionDays = Number(securityUaRetentionRaw);
  const wantsJson = req.headers.accept && req.headers.accept.includes('application/json');
  if (
    Number.isNaN(sessionDays) || sessionDays <= 0 ||
    Number.isNaN(maxFileSize) || maxFileSize <= 0 ||
    Number.isNaN(minTeamMembers) || minTeamMembers <= 0 ||
    Number.isNaN(scheduleRefreshMinutes) || scheduleRefreshMinutes <= 0 ||
    Number.isNaN(siteVisitRetentionDays) ||
    Number.isNaN(loginHistoryRetentionDays) ||
    Number.isNaN(activityLogRetentionDays) ||
    Number.isNaN(securityIpRetentionDays) ||
    Number.isNaN(securityUserAgentRetentionDays) ||
    (thresholdProvided && Number.isNaN(securityRegistrationAlertThreshold)) ||
    (windowProvided && Number.isNaN(securityRegistrationAlertWindowMinutes))
  ) {
    if (wantsJson) {
      return res.status(400).json({ error: 'Invalid settings' });
    }
    return res.redirect('/admin?err=Invalid%20settings');
  }
  if (
    scheduleRefreshMinutes > 120 ||
    siteVisitRetentionDays < SETTINGS_RETENTION_MIN_DAYS ||
    siteVisitRetentionDays > SETTINGS_RETENTION_MAX_DAYS ||
    loginHistoryRetentionDays < SETTINGS_RETENTION_MIN_DAYS ||
    loginHistoryRetentionDays > SETTINGS_RETENTION_MAX_DAYS ||
    activityLogRetentionDays < SETTINGS_RETENTION_MIN_DAYS ||
    activityLogRetentionDays > SETTINGS_RETENTION_MAX_DAYS ||
    securityIpRetentionDays < SETTINGS_RETENTION_MIN_DAYS ||
    securityIpRetentionDays > SETTINGS_RETENTION_MAX_DAYS ||
    securityUserAgentRetentionDays < SETTINGS_RETENTION_MIN_DAYS ||
    securityUserAgentRetentionDays > SETTINGS_RETENTION_MAX_DAYS ||
    (thresholdProvided && (
      securityRegistrationAlertThreshold < SECURITY_REGISTRATION_ALERT_THRESHOLD_MIN ||
      securityRegistrationAlertThreshold > SECURITY_REGISTRATION_ALERT_THRESHOLD_MAX
    )) ||
    (windowProvided && (
      securityRegistrationAlertWindowMinutes < SECURITY_REGISTRATION_ALERT_WINDOW_MINUTES_MIN ||
      securityRegistrationAlertWindowMinutes > SECURITY_REGISTRATION_ALERT_WINDOW_MINUTES_MAX
    ))
  ) {
    if (wantsJson) {
      return res.status(400).json({ error: 'Invalid settings' });
    }
    return res.redirect('/admin?err=Invalid%20settings');
  }
  try {
    const courseId = getAdminCourse(req);
    const beforeState = buildSystemSettingsAuditState(settingsCache);
    const nextSettings = {
      session_duration_days: sessionDays,
      max_file_size_mb: maxFileSize,
      allow_homework_creation: allowHomework,
      min_team_members: minTeamMembers,
      allow_custom_deadlines: allowCustomDeadlines,
      myday_show_student_homework: myDayShowStudentHomework,
      allow_messages: allowMessages,
      schedule_refresh_minutes: scheduleRefreshMinutes,
      site_visit_retention_days: normalizeRetentionDays(siteVisitRetentionDays, DEFAULT_SETTINGS.site_visit_retention_days),
      login_history_retention_days: normalizeRetentionDays(loginHistoryRetentionDays, DEFAULT_SETTINGS.login_history_retention_days),
      activity_log_retention_days: normalizeRetentionDays(activityLogRetentionDays, DEFAULT_SETTINGS.activity_log_retention_days),
      security_admin_ip_allowlist: normalizeSecurityAdminIpAllowlist(securityAdminIpAllowlist),
      security_registration_alert_threshold: normalizeSecurityRegistrationAlertThreshold(
        securityRegistrationAlertThreshold,
        DEFAULT_SETTINGS.security_registration_alert_threshold
      ),
      security_registration_alert_window_minutes: normalizeSecurityRegistrationAlertWindowMinutes(
        securityRegistrationAlertWindowMinutes,
        DEFAULT_SETTINGS.security_registration_alert_window_minutes
      ),
      security_auto_quarantine_enabled: Boolean(securityAutoQuarantineEnabled),
      security_ip_retention_days: normalizeRetentionDays(
        securityIpRetentionDays,
        DEFAULT_SETTINGS.security_ip_retention_days
      ),
      security_user_agent_retention_days: normalizeRetentionDays(
        securityUserAgentRetentionDays,
        DEFAULT_SETTINGS.security_user_agent_retention_days
      ),
    };
    const changes = Object.keys(nextSettings).reduce((acc, key) => {
      if (String(settingsCache[key]) !== String(nextSettings[key])) {
        acc.push({ key, from: settingsCache[key], to: nextSettings[key] });
      }
      return acc;
    }, []);
    const operationId = randomUUID();
    const afterState = await persistSystemSettingsState(nextSettings);
    await createAdminAuditEntry(req, {
      scopeKey: ADMIN_AUDIT_SCOPE_SYSTEM_SETTINGS,
      targetType: 'system_settings',
      summary: 'System settings updated',
      beforeState,
      afterState,
      operationId,
      courseId,
    });
    logAction(db, req, 'system_settings_update', {
      operation_id: operationId,
      changes,
    });
    if (wantsJson) {
      return res.json({
        ok: true,
        operation_id: operationId,
        updated_at: new Date().toISOString(),
        updated_by: req.session.user ? req.session.user.username : null,
        changes,
      });
    }
    return res.redirect(`/admin?ok=Settings%20saved&op=${operationId}`);
  } catch (err) {
    return handleDbError(res, err, 'admin.settings.save');
  }
});

app.post('/admin/role-access', requireRoleAccessSectionAccess, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'admin.roleAccess.init');
  }
  try {
    const courseId = getAdminCourse(req);
    const rolePermissions = req.body.role_permissions || {};
    const beforeState = sanitizeLegacyRolePermissions(settingsCache.role_permissions || {});
    const nextPermissions = sanitizeLegacyRolePermissions(rolePermissions);

    const previous = beforeState;
    const changes = [];
    Object.keys(nextPermissions).forEach((role) => {
      const prevList = new Set(previous[role] || []);
      const nextList = new Set(nextPermissions[role] || []);
      const added = Array.from(nextList).filter((id) => !prevList.has(id));
      const removed = Array.from(prevList).filter((id) => !nextList.has(id));
      if (added.length || removed.length) {
        changes.push({ role, added, removed });
      }
    });
    const operationId = randomUUID();
    const afterState = await persistLegacyRolePermissions(nextPermissions);
    await createAdminAuditEntry(req, {
      scopeKey: ADMIN_AUDIT_SCOPE_ROLE_STUDIO,
      targetType: 'role_permissions',
      targetKey: 'legacy',
      summary: 'Role permissions updated',
      beforeState,
      afterState,
      operationId,
      courseId,
    });
    logAction(db, req, 'role_access_update', {
      operation_id: operationId,
      changes,
    });
    return res.redirect(`/admin?ok=Role%20access%20saved&op=${operationId}`);
  } catch (err) {
    return handleDbError(res, err, 'admin.roleAccess.save');
  }
});

const parseAuditState = (rawState) => {
  if (rawState == null) return null;
  if (typeof rawState === 'object') return rawState;
  if (typeof rawState !== 'string') return null;
  try {
    return JSON.parse(rawState);
  } catch (err) {
    return null;
  }
};

app.get('/admin/audit/settings.json', requireSettingsSectionAccess, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'admin.audit.settings.init');
  }
  try {
    const courseId = getAdminCourse(req);
    const rows = await db.all(
      `
        SELECT
          a.id,
          a.target_type,
          a.target_key,
          a.summary,
          a.operation_id,
          a.created_by_name,
          a.created_at,
          a.is_rolled_back,
          a.rolled_back_at,
          ur.full_name AS rolled_back_by_name,
          (a.before_state IS NOT NULL) AS can_rollback
        FROM admin_change_audit a
        LEFT JOIN users ur ON ur.id = a.rolled_back_by
        WHERE a.scope_key = ?
          AND (a.course_id = ? OR a.course_id IS NULL)
        ORDER BY a.created_at DESC, a.id DESC
        LIMIT 20
      `,
      [ADMIN_AUDIT_SCOPE_SYSTEM_SETTINGS, courseId]
    );
    const entries = (rows || []).map((row) => ({
      id: Number(row.id),
      target_type: String(row.target_type || ''),
      target_key: row.target_key ? String(row.target_key) : '',
      summary: String(row.summary || 'System settings update'),
      operation_id: row.operation_id ? String(row.operation_id) : '',
      created_by_name: row.created_by_name ? String(row.created_by_name) : '',
      created_at: row.created_at || null,
      is_rolled_back: row.is_rolled_back === true || Number(row.is_rolled_back) === 1,
      rolled_back_at: row.rolled_back_at || null,
      rolled_back_by_name: row.rolled_back_by_name ? String(row.rolled_back_by_name) : '',
      can_rollback: row.can_rollback === true || Number(row.can_rollback) === 1,
    }));
    return res.json({ entries });
  } catch (err) {
    return res.status(500).json({ error: 'Database error' });
  }
});

app.get('/admin/audit/role-studio.json', requireRoleAccessSectionAccess, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'admin.audit.roleStudio.init');
  }
  try {
    const courseId = getAdminCourse(req);
    const rows = await db.all(
      `
        SELECT
          a.id,
          a.target_type,
          a.target_key,
          a.summary,
          a.operation_id,
          a.created_by_name,
          a.created_at,
          a.is_rolled_back,
          a.rolled_back_at,
          ur.full_name AS rolled_back_by_name,
          (a.before_state IS NOT NULL) AS can_rollback
        FROM admin_change_audit a
        LEFT JOIN users ur ON ur.id = a.rolled_back_by
        WHERE a.scope_key = ?
          AND (a.course_id = ? OR a.course_id IS NULL)
        ORDER BY a.created_at DESC, a.id DESC
        LIMIT 30
      `,
      [ADMIN_AUDIT_SCOPE_ROLE_STUDIO, courseId]
    );
    const entries = (rows || []).map((row) => ({
      id: Number(row.id),
      target_type: String(row.target_type || ''),
      target_key: row.target_key ? String(row.target_key) : '',
      summary: String(row.summary || 'Role Studio update'),
      operation_id: row.operation_id ? String(row.operation_id) : '',
      created_by_name: row.created_by_name ? String(row.created_by_name) : '',
      created_at: row.created_at || null,
      is_rolled_back: row.is_rolled_back === true || Number(row.is_rolled_back) === 1,
      rolled_back_at: row.rolled_back_at || null,
      rolled_back_by_name: row.rolled_back_by_name ? String(row.rolled_back_by_name) : '',
      can_rollback: row.can_rollback === true || Number(row.can_rollback) === 1,
    }));
    return res.json({ entries });
  } catch (err) {
    return res.status(500).json({ error: 'Database error' });
  }
});

app.post('/admin/settings/rollback', requireSettingsSectionAccess, async (req, res) => {
  const auditId = Number(req.body.audit_id);
  if (!Number.isFinite(auditId) || auditId < 1) {
    return res.redirect('/admin?tab=admin-settings&err=Invalid%20audit%20entry');
  }
  try {
    await ensureDbReady();
    const courseId = getAdminCourse(req);
    const auditRow = await db.get(
      `
        SELECT id, target_type, before_state, after_state
        FROM admin_change_audit
        WHERE id = ?
          AND scope_key = ?
          AND (course_id = ? OR course_id IS NULL)
        LIMIT 1
      `,
      [auditId, ADMIN_AUDIT_SCOPE_SYSTEM_SETTINGS, courseId]
    );
    if (!auditRow) {
      return res.redirect('/admin?tab=admin-settings&err=Audit%20entry%20not%20found');
    }
    if (String(auditRow.target_type || '') !== 'system_settings') {
      return res.redirect('/admin?tab=admin-settings&err=Unsupported%20audit%20target');
    }
    const rollbackStateRaw = parseAuditState(auditRow.before_state);
    if (!rollbackStateRaw || typeof rollbackStateRaw !== 'object') {
      return res.redirect('/admin?tab=admin-settings&err=Rollback%20snapshot%20is%20invalid');
    }

    const beforeRollbackState = buildSystemSettingsAuditState(settingsCache);
    const rollbackState = buildSystemSettingsAuditState(rollbackStateRaw);
    const operationId = randomUUID();
    const afterRollbackState = await persistSystemSettingsState(rollbackState);
    await markAdminAuditEntryRolledBack(auditId, req);
    await createAdminAuditEntry(req, {
      scopeKey: ADMIN_AUDIT_SCOPE_SYSTEM_SETTINGS,
      targetType: 'system_settings',
      summary: `Rollback from audit #${auditId}`,
      beforeState: beforeRollbackState,
      afterState: afterRollbackState,
      operationId,
      courseId,
    });
    logAction(db, req, 'system_settings_rollback', {
      operation_id: operationId,
      audit_id: auditId,
    });
    return res.redirect(`/admin?tab=admin-settings&ok=Settings%20rollback%20applied&op=${operationId}`);
  } catch (err) {
    return res.redirect('/admin?tab=admin-settings&err=Database%20error');
  }
});

app.post('/admin/role-studio/rollback', requireRoleAccessSectionAccess, async (req, res) => {
  const auditId = Number(req.body.audit_id);
  if (!Number.isFinite(auditId) || auditId < 1) {
    return res.redirect('/admin?tab=admin-role-studio&err=Invalid%20audit%20entry');
  }
  try {
    await ensureDbReady();
    const courseId = getAdminCourse(req);
    const auditRow = await db.get(
      `
        SELECT id, target_type, target_key, before_state, after_state
        FROM admin_change_audit
        WHERE id = ?
          AND scope_key = ?
          AND (course_id = ? OR course_id IS NULL)
        LIMIT 1
      `,
      [auditId, ADMIN_AUDIT_SCOPE_ROLE_STUDIO, courseId]
    );
    if (!auditRow) {
      return res.redirect('/admin?tab=admin-role-studio&err=Audit%20entry%20not%20found');
    }
    const targetType = String(auditRow.target_type || '');
    const targetKey = String(auditRow.target_key || '').trim().toLowerCase();
    const rollbackState = parseAuditState(auditRow.before_state);
    const afterState = parseAuditState(auditRow.after_state);
    const operationId = randomUUID();

    if (targetType === 'role_permissions') {
      if (!rollbackState || typeof rollbackState !== 'object') {
        return res.redirect('/admin?tab=admin-role-studio&err=Rollback%20snapshot%20is%20invalid');
      }
      const beforeRollbackState = sanitizeLegacyRolePermissions(settingsCache.role_permissions || {});
      const appliedState = await persistLegacyRolePermissions(rollbackState);
      await markAdminAuditEntryRolledBack(auditId, req);
      await createAdminAuditEntry(req, {
        scopeKey: ADMIN_AUDIT_SCOPE_ROLE_STUDIO,
        targetType: 'role_permissions',
        targetKey: 'legacy',
        summary: `Rollback from audit #${auditId}`,
        beforeState: beforeRollbackState,
        afterState: appliedState,
        operationId,
        courseId,
      });
      logAction(db, req, 'role_permissions_rollback', {
        operation_id: operationId,
        audit_id: auditId,
      });
      broadcast('users_updated');
      return res.redirect(`/admin?tab=admin-role-studio&ok=Role%20Studio%20rollback%20applied&op=${operationId}`);
    }

    if (targetType === 'rbac_role') {
      if (!targetKey) {
        return res.redirect('/admin?tab=admin-role-studio&err=Invalid%20audit%20target%20key');
      }
      const beforeRollbackState = await getRbacRoleStateByKey(targetKey);
      if (!rollbackState && !afterState) {
        return res.redirect('/admin?tab=admin-role-studio&err=Rollback%20snapshot%20is%20empty');
      }
      await withTransaction(async (client) => {
        if (!rollbackState && afterState) {
          await deleteRbacRoleByKey(client, targetKey);
          return;
        }
        await upsertRbacRoleState(client, rollbackState);
      });
      const appliedState = await getRbacRoleStateByKey(targetKey);
      await markAdminAuditEntryRolledBack(auditId, req);
      await createAdminAuditEntry(req, {
        scopeKey: ADMIN_AUDIT_SCOPE_ROLE_STUDIO,
        targetType: 'rbac_role',
        targetKey,
        summary: `Rollback from audit #${auditId}`,
        beforeState: beforeRollbackState,
        afterState: appliedState,
        operationId,
        courseId,
      });
      logAction(db, req, 'rbac_role_rollback', {
        operation_id: operationId,
        audit_id: auditId,
        role_key: targetKey,
      });
      broadcast('users_updated');
      return res.redirect(`/admin?tab=admin-role-studio&ok=Role%20Studio%20rollback%20applied&op=${operationId}`);
    }

    return res.redirect('/admin?tab=admin-role-studio&err=Unsupported%20rollback%20target');
  } catch (err) {
    const message = String(err && err.message ? err.message : '');
    if (message.includes('Role is assigned to users')) {
      return res.redirect('/admin?tab=admin-role-studio&err=Cannot%20rollback:%20role%20is%20assigned%20to%20users');
    }
    if (message.includes('Cannot delete system role')) {
      return res.redirect('/admin?tab=admin-role-studio&err=Cannot%20rollback:%20system%20role%20delete%20blocked');
    }
    return res.redirect('/admin?tab=admin-role-studio&err=Database%20error');
  }
});

app.get('/admin/visit-analytics.json', requireVisitAnalyticsSectionAccess, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'admin.visitAnalytics.init');
  }
  try {
    const days = parseVisitDays(req.query.days);
    const excludeAdmin = parseVisitExcludeAdmin(req.query.exclude_admin);
    const labels = buildVisitDayLabels(days);
    const sinceIso = labels.length
      ? new Date(`${labels[0]}T00:00:00.000Z`).toISOString()
      : new Date(Date.now() - (days * 24 * 60 * 60 * 1000)).toISOString();
    const courseId = getAdminCourse(req);
    const userId = Number(req?.session?.user?.id || 0);
    const roleKeys = getSessionRoleList(req);
    const activeSemester = await getActiveSemester(courseId);
    const uniqueExpr = "COALESCE(v.user_id::text, NULLIF(v.session_id, ''), NULLIF(v.ip, ''), 'guest')";
    const excludeAdminClause = excludeAdmin
      ? "AND COALESCE(NULLIF(v.role_key, ''), 'guest') <> 'admin'"
      : '';
    const now = new Date();

    const recentSqlBase = `
      SELECT
        v.created_at,
        COALESCE(NULLIF(u.full_name, ''), 'Guest') AS user_name,
        COALESCE(NULLIF(v.role_key, ''), 'guest') AS role_key,
        v.page_key,
        v.route_path
      FROM site_visit_events v
      LEFT JOIN users u ON u.id = v.user_id
      WHERE (v.course_id = ? OR v.course_id IS NULL)
        AND v.created_at >= ?
    `;
    const recentFilteredSql = `
      ${recentSqlBase}
      ${excludeAdminClause}
      ORDER BY v.created_at DESC
      LIMIT 30
    `;
    const recentFallbackSql = `
      ${recentSqlBase}
      ORDER BY v.created_at DESC
      LIMIT 30
    `;

    const [summaryRow, dailyRows, topPagesRows, roleRows, recentRows, recentFallbackRows] = await Promise.all([
      db.get(
        `
          SELECT
            COUNT(*)::int AS total_visits,
            COUNT(DISTINCT ${uniqueExpr})::int AS unique_visitors,
            COUNT(DISTINCT v.user_id)::int AS signed_users,
            COUNT(DISTINCT DATE(v.created_at))::int AS active_days
          FROM site_visit_events v
          WHERE v.course_id = ?
            AND v.created_at >= ?
            ${excludeAdminClause}
        `,
        [courseId, sinceIso]
      ),
      db.all(
        `
          SELECT
            DATE(v.created_at) AS day,
            COUNT(*)::int AS visits,
            COUNT(DISTINCT ${uniqueExpr})::int AS unique_visitors
          FROM site_visit_events v
          WHERE v.course_id = ?
            AND v.created_at >= ?
            ${excludeAdminClause}
          GROUP BY DATE(v.created_at)
          ORDER BY day ASC
        `,
        [courseId, sinceIso]
      ),
      db.all(
        `
          SELECT
            v.page_key,
            COUNT(*)::int AS visits,
            COUNT(DISTINCT ${uniqueExpr})::int AS unique_visitors
          FROM site_visit_events v
          WHERE v.course_id = ?
            AND v.created_at >= ?
            ${excludeAdminClause}
          GROUP BY v.page_key
          ORDER BY visits DESC, v.page_key ASC
          LIMIT 8
        `,
        [courseId, sinceIso]
      ),
      db.all(
        `
          SELECT
            COALESCE(NULLIF(v.role_key, ''), 'guest') AS role_key,
            COUNT(*)::int AS visits
          FROM site_visit_events v
          WHERE v.course_id = ?
            AND v.created_at >= ?
            ${excludeAdminClause}
          GROUP BY COALESCE(NULLIF(v.role_key, ''), 'guest')
          ORDER BY visits DESC, role_key ASC
        `,
        [courseId, sinceIso]
      ),
      db.all(
        recentFilteredSql,
        [courseId, sinceIso]
      ),
      excludeAdmin
        ? db.all(recentFallbackSql, [courseId, sinceIso])
        : Promise.resolve([]),
    ]);
    let homeworkSla = null;
    try {
      homeworkSla = await buildAdminHomeworkReviewSla({
        userId,
        courseId,
        semesterId: activeSemester ? Number(activeSemester.id) : null,
        roleKeys,
        now,
      });
    } catch (err) {
      homeworkSla = null;
    }

    const dailyMap = new Map();
    (dailyRows || []).forEach((row) => {
      const key = row && row.day ? String(row.day).slice(0, 10) : '';
      if (!key) return;
      dailyMap.set(key, {
        visits: Number(row.visits || 0),
        unique_visitors: Number(row.unique_visitors || 0),
      });
    });
    const daily = labels.map((day) => {
      const value = dailyMap.get(day) || { visits: 0, unique_visitors: 0 };
      return {
        day,
        visits: value.visits,
        unique_visitors: value.unique_visitors,
      };
    });

    const normalizedRecent = (recentRows || []).map((row) => ({
      created_at: row.created_at,
      user_name: row.user_name || 'Guest',
      role_key: row.role_key || 'guest',
      page_key: row.page_key || 'unknown',
      route_path: row.route_path || '/',
    }));
    const normalizedRecentFallback = (recentFallbackRows || []).map((row) => ({
      created_at: row.created_at,
      user_name: row.user_name || 'Guest',
      role_key: row.role_key || 'guest',
      page_key: row.page_key || 'unknown',
      route_path: row.route_path || '/',
    }));
    const recentIsFallback = Boolean(
      excludeAdmin &&
      normalizedRecent.length === 0 &&
      normalizedRecentFallback.length > 0
    );

    return res.json({
      ok: true,
      days,
      course_id: courseId,
      exclude_admin: excludeAdmin,
      summary: {
        total_visits: Number(summaryRow?.total_visits || 0),
        unique_visitors: Number(summaryRow?.unique_visitors || 0),
        signed_users: Number(summaryRow?.signed_users || 0),
        active_days: Number(summaryRow?.active_days || 0),
      },
      daily,
      top_pages: (topPagesRows || []).map((row) => ({
        page_key: String(row.page_key || 'unknown'),
        visits: Number(row.visits || 0),
        unique_visitors: Number(row.unique_visitors || 0),
      })),
      roles: (roleRows || []).map((row) => ({
        role_key: String(row.role_key || 'guest'),
        visits: Number(row.visits || 0),
      })),
      recent: normalizedRecent,
      recent_fallback: normalizedRecentFallback,
      recent_is_fallback: recentIsFallback,
      homework_sla: homeworkSla,
    });
  } catch (err) {
    return handleDbError(res, err, 'admin.visitAnalytics.fetch');
  }
});

app.get('/admin/data-quality.json', requireVisitAnalyticsSectionAccess, async (req, res) => {
  const unavailablePayload = {
    ok: true,
    generated_at: new Date().toISOString(),
    available: false,
    summary: {
      checks_total: 0,
      checks_with_issues: 0,
      total_issues: 0,
      affected_subjects: 0,
      severity_rows: {
        critical: 0,
        warning: 0,
        info: 0,
      },
      severity_checks: {
        critical: 0,
        warning: 0,
        info: 0,
      },
    },
    items: [],
  };
  try {
    await ensureDbReady();
  } catch (err) {
    return res.json(unavailablePayload);
  }
  try {
    const courseId = getAdminCourse(req);
    let activeSemester = null;
    try {
      activeSemester = await getActiveSemester(courseId);
    } catch (err) {
      if (!isDbSchemaCompatibilityError(err)) {
        console.error('Database error (admin.dataQuality.activeSemester)', err);
      }
      activeSemester = null;
    }
    const diagnostics = await buildAdminDataQualityDiagnostics({
      courseId,
      semesterId: activeSemester ? Number(activeSemester.id) : null,
    });
    return res.json({
      ok: true,
      ...diagnostics,
    });
  } catch (err) {
    return res.json(unavailablePayload);
  }
});

app.get('/admin/security-dashboard.json', requireVisitAnalyticsSectionAccess, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'admin.securityDashboard.init');
  }
  try {
    const courseId = getAdminCourse(req);
    const adminAllowlist = parseSecurityAdminIpAllowlist(settingsCache.security_admin_ip_allowlist);
    const [summaryRow, riskyRows, alertsRows, ipRows, deviceRows] = await Promise.all([
      db.get(
        `
          SELECT
            COUNT(*)::int AS total_cases,
            COUNT(*) FILTER (WHERE usc.risk_level = 'high-risk')::int AS high_risk_total,
            COUNT(*) FILTER (WHERE usc.risk_level = 'watch')::int AS watch_total,
            COUNT(*) FILTER (WHERE usc.risk_level = 'normal')::int AS normal_total,
            COUNT(*) FILTER (WHERE usc.status IN ('open', 'confirmed'))::int AS open_cases,
            COUNT(*) FILTER (WHERE usc.status = 'confirmed')::int AS confirmed_cases,
            COUNT(*) FILTER (WHERE usc.status = 'closed')::int AS closed_cases,
            COUNT(*) FILTER (
              WHERE usc.status IN ('open', 'confirmed')
                AND usc.updated_at <= NOW() - INTERVAL '24 hours'
            )::int AS overdue_24h,
            COUNT(*) FILTER (
              WHERE usc.status IN ('open', 'confirmed')
                AND usc.updated_at <= NOW() - INTERVAL '72 hours'
            )::int AS overdue_72h
          FROM user_security_cases usc
          JOIN users u ON u.id = usc.user_id
          WHERE u.course_id = ?
        `,
        [courseId]
      ),
      db.all(
        `
          SELECT
            usc.user_id,
            u.full_name,
            u.role,
            usc.risk_level,
            usc.risk_score,
            usc.status,
            usc.reason,
            usc.updated_at
          FROM user_security_cases usc
          JOIN users u ON u.id = usc.user_id
          WHERE u.course_id = ?
          ORDER BY
            CASE usc.risk_level
              WHEN 'high-risk' THEN 3
              WHEN 'watch' THEN 2
              ELSE 1
            END DESC,
            usc.risk_score DESC,
            usc.updated_at DESC
          LIMIT 16
        `,
        [courseId]
      ),
      db.all(
        `
          SELECT
            sae.id,
            sae.user_id,
            u.full_name AS user_name,
            sae.alert_key,
            sae.severity,
            sae.title,
            sae.message,
            sae.created_at
          FROM security_alert_events sae
          LEFT JOIN users u ON u.id = sae.user_id
          WHERE (sae.course_id = ? OR sae.course_id IS NULL)
            AND sae.resolved_at IS NULL
            AND sae.created_at::timestamptz >= NOW() - INTERVAL '14 days'
          ORDER BY sae.created_at::timestamptz DESC
          LIMIT 24
        `,
        [courseId]
      ),
      db.all(
        `
          WITH ip_events AS (
            SELECT ip, user_id, created_at::timestamp AS created_at
            FROM login_history
            WHERE ip IS NOT NULL
              AND created_at::timestamp >= NOW() - INTERVAL '14 days'
              AND (course_id = ? OR course_id IS NULL)
            UNION ALL
            SELECT ip, user_id, created_at::timestamp AS created_at
            FROM user_registration_events
            WHERE ip IS NOT NULL
              AND created_at::timestamptz >= NOW() - INTERVAL '14 days'
              AND (course_id = ? OR course_id IS NULL)
            UNION ALL
            SELECT ip, user_id, created_at::timestamp AS created_at
            FROM auth_failure_events
            WHERE ip IS NOT NULL
              AND created_at::timestamptz >= NOW() - INTERVAL '14 days'
              AND (course_id = ? OR course_id IS NULL)
          )
          SELECT
            ip,
            COUNT(*)::int AS events_count,
            COUNT(DISTINCT user_id)::int AS users_count,
            MAX(created_at) AS last_seen_at
          FROM ip_events
          GROUP BY ip
          ORDER BY users_count DESC, events_count DESC, last_seen_at DESC
          LIMIT 16
        `,
        [courseId, courseId, courseId]
      ),
      db.all(
        `
          WITH device_events AS (
            SELECT
              device_fingerprint AS device_key,
              user_id,
              created_at::timestamp AS created_at,
              device_fingerprint AS sample_label
            FROM user_registration_events
            WHERE device_fingerprint IS NOT NULL
              AND created_at::timestamptz >= NOW() - INTERVAL '21 days'
              AND (course_id = ? OR course_id IS NULL)
            UNION ALL
            SELECT
              md5(lower(user_agent)) AS device_key,
              user_id,
              created_at::timestamp AS created_at,
              LEFT(user_agent, 120) AS sample_label
            FROM login_history
            WHERE user_agent IS NOT NULL
              AND created_at::timestamp >= NOW() - INTERVAL '21 days'
              AND (course_id = ? OR course_id IS NULL)
          )
          SELECT
            device_key,
            MAX(sample_label) AS sample_label,
            COUNT(*)::int AS events_count,
            COUNT(DISTINCT user_id)::int AS users_count,
            MAX(created_at) AS last_seen_at
          FROM device_events
          GROUP BY device_key
          ORDER BY users_count DESC, events_count DESC, last_seen_at DESC
          LIMIT 16
        `,
        [courseId, courseId]
      ),
    ]);

    const ipItems = (ipRows || [])
      .filter((row) => row && row.ip && !isSecurityAdminIpAllowlisted(row.ip, adminAllowlist))
      .map((row) => ({
        ip: normalizeForensicsIp(row.ip),
        events_count: Number(row.events_count || 0),
        users_count: Number(row.users_count || 0),
        last_seen_at: toIsoStringSafe(row.last_seen_at),
      }))
      .slice(0, 10);

    const deviceItems = (deviceRows || []).map((row) => ({
      device_key: String(row.device_key || ''),
      sample_label: String(row.sample_label || '').trim(),
      events_count: Number(row.events_count || 0),
      users_count: Number(row.users_count || 0),
      last_seen_at: toIsoStringSafe(row.last_seen_at),
    })).slice(0, 10);

    return res.json({
      ok: true,
      generated_at: new Date().toISOString(),
      summary: {
        total_cases: Number(summaryRow && summaryRow.total_cases ? summaryRow.total_cases : 0),
        high_risk_total: Number(summaryRow && summaryRow.high_risk_total ? summaryRow.high_risk_total : 0),
        watch_total: Number(summaryRow && summaryRow.watch_total ? summaryRow.watch_total : 0),
        normal_total: Number(summaryRow && summaryRow.normal_total ? summaryRow.normal_total : 0),
        open_cases: Number(summaryRow && summaryRow.open_cases ? summaryRow.open_cases : 0),
        confirmed_cases: Number(summaryRow && summaryRow.confirmed_cases ? summaryRow.confirmed_cases : 0),
        closed_cases: Number(summaryRow && summaryRow.closed_cases ? summaryRow.closed_cases : 0),
        overdue_24h: Number(summaryRow && summaryRow.overdue_24h ? summaryRow.overdue_24h : 0),
        overdue_72h: Number(summaryRow && summaryRow.overdue_72h ? summaryRow.overdue_72h : 0),
      },
      risky_accounts: (riskyRows || []).map((row) => ({
        user_id: Number(row.user_id),
        full_name: String(row.full_name || ''),
        role: normalizeRoleKey(row.role || 'student'),
        risk_level: normalizeSecurityCaseLevel(row.risk_level),
        risk_score: Number(row.risk_score || 0),
        status: normalizeSecurityCaseStatus(row.status),
        reason: String(row.reason || ''),
        updated_at: toIsoStringSafe(row.updated_at),
      })),
      open_alerts: (alertsRows || []).map((row) => ({
        id: Number(row.id),
        user_id: Number.isFinite(Number(row.user_id)) ? Number(row.user_id) : null,
        user_name: row.user_name ? String(row.user_name) : '',
        alert_key: String(row.alert_key || ''),
        severity: normalizeSecurityAlertSeverity(row.severity),
        title: String(row.title || ''),
        message: String(row.message || ''),
        created_at: toIsoStringSafe(row.created_at),
      })),
      top_ips: ipItems,
      top_devices: deviceItems,
      settings: {
        auto_quarantine_enabled: Boolean(settingsCache.security_auto_quarantine_enabled),
        allowlist_count: adminAllowlist.length,
        ip_retention_days: normalizeRetentionDays(
          settingsCache.security_ip_retention_days,
          SECURITY_IP_RETENTION_DAYS_DEFAULT
        ),
        user_agent_retention_days: normalizeRetentionDays(
          settingsCache.security_user_agent_retention_days,
          SECURITY_USER_AGENT_RETENTION_DAYS_DEFAULT
        ),
      },
    });
  } catch (err) {
    return handleDbError(res, err, 'admin.securityDashboard.fetch');
  }
});

app.post('/admin/security-dashboard/recompute', requireVisitAnalyticsSectionAccess, writeLimiter, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'admin.securityDashboard.recompute.init');
  }
  try {
    const courseId = getAdminCourse(req);
    const requestedLimit = Number(req.body && req.body.limit ? req.body.limit : SECURITY_DASHBOARD_RECOMPUTE_LIMIT_DEFAULT);
    const recomputeLimit = Number.isFinite(requestedLimit)
      ? Math.max(1, Math.min(SECURITY_DASHBOARD_RECOMPUTE_LIMIT_MAX, Math.floor(requestedLimit)))
      : SECURITY_DASHBOARD_RECOMPUTE_LIMIT_DEFAULT;
    const userRows = await db.all(
      `
        SELECT id
        FROM users
        WHERE course_id = ?
          AND is_active = 1
        ORDER BY id DESC
        LIMIT ?
      `,
      [courseId, recomputeLimit]
    );
    const userIds = (userRows || [])
      .map((row) => Number(row.id || 0))
      .filter((id) => Number.isFinite(id) && id > 0);
    const beforeRows = userIds.length
      ? await db.all(
          `
            SELECT user_id, risk_level, risk_score, status
            FROM user_security_cases
            WHERE user_id = ANY(?::int[])
          `,
          [userIds]
        )
      : [];
    const beforeByUser = new Map();
    (beforeRows || []).forEach((row) => {
      const userId = Number(row && row.user_id ? row.user_id : 0);
      if (!Number.isFinite(userId) || userId < 1) return;
      const signature = [
        normalizeSecurityCaseLevel(row.risk_level),
        Number(row.risk_score || 0),
        normalizeSecurityCaseStatus(row.status),
      ].join('|');
      beforeByUser.set(userId, signature);
    });

    let processed = 0;
    let changed = 0;
    let errors = 0;
    const summary = {
      high_risk_total: 0,
      watch_total: 0,
      suspicious_total: 0,
    };

    for (const userId of userIds) {
      try {
        const recomputed = await recomputeUserSecurityCase(userId, {
          courseId,
          allowAutoQuarantine: false,
        });
        processed += 1;
        if (!recomputed) continue;
        const level = normalizeSecurityCaseLevel(recomputed.level);
        const score = Number(recomputed.score || 0);
        const status = normalizeSecurityCaseStatus(
          recomputed.case && recomputed.case.status ? recomputed.case.status : 'open'
        );
        const nextSignature = [level, score, status].join('|');
        if (beforeByUser.get(userId) !== nextSignature) {
          changed += 1;
        }
        if (level === 'high-risk') {
          summary.high_risk_total += 1;
        } else if (level === 'watch') {
          summary.watch_total += 1;
        }
      } catch (recomputeErr) {
        errors += 1;
        pushRuntimeErrorEvent(
          'security',
          'dashboard_recompute',
          recomputeErr && recomputeErr.message ? recomputeErr.message : recomputeErr,
          { user_id: userId }
        );
      }
    }

    summary.suspicious_total = summary.high_risk_total + summary.watch_total;
    logAction(db, req, 'security_dashboard_recompute', {
      course_id: courseId,
      limit: recomputeLimit,
      processed,
      changed,
      errors,
      suspicious_total: summary.suspicious_total,
    });

    return res.json({
      ok: true,
      course_id: courseId,
      limit: recomputeLimit,
      processed,
      changed,
      errors,
      summary,
      generated_at: new Date().toISOString(),
    });
  } catch (err) {
    return handleDbError(res, err, 'admin.securityDashboard.recompute');
  }
});

app.get('/admin/system-health.json', requireVisitAnalyticsSectionAccess, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'admin.systemHealth.init');
  }
  try {
    const nowTs = Date.now();
    const nowIso = new Date(nowTs).toISOString();
    const memoryUsage = process.memoryUsage();
    const dbStatus = initStatus === 'ok' ? 'ok' : (initStatus === 'error' ? 'fail' : 'starting');
    const sessionStatus = sessionHealthState.ok ? 'ok' : 'fail';
    const schedulerStatus = !schedulerHealthState.enabled
      ? 'disabled'
      : (schedulerHealthState.running
        ? 'running'
        : (schedulerHealthState.last_error ? 'degraded' : 'ok'));
    const errorSummary = getRuntimeErrorSummary(nowTs);
    const incidents = buildIncidentFeed(nowTs);
    const migrationRows = await db.all(
      `
        SELECT id, applied_at
        FROM migrations
        ORDER BY applied_at DESC, id DESC
      `
    );
    const availableIds = Array.isArray(migrationCatalog)
      ? migrationCatalog.map((item) => String(item && item.id ? item.id : '')).filter(Boolean)
      : [];
    const appliedSet = new Set((migrationRows || []).map((row) => String(row.id || '')).filter(Boolean));
    const pendingIds = availableIds.filter((id) => !appliedSet.has(id));
    let status = 'ok';
    if (dbStatus === 'fail' || sessionStatus === 'fail') {
      status = 'critical';
    } else if (dbStatus === 'starting') {
      status = 'starting';
    } else if (schedulerStatus === 'degraded' || Number(errorSummary.total || 0) > 0) {
      status = 'degraded';
    }

    return res.json({
      ok: true,
      generated_at: nowIso,
      status,
      runtime: {
        version: appVersion,
        build_stamp: buildStamp,
        node: process.version,
        uptime_seconds: Math.max(0, Math.floor(process.uptime())),
        memory_mb: {
          rss: Math.round((Number(memoryUsage.rss || 0) / (1024 * 1024)) * 10) / 10,
          heap_used: Math.round((Number(memoryUsage.heapUsed || 0) / (1024 * 1024)) * 10) / 10,
          heap_total: Math.round((Number(memoryUsage.heapTotal || 0) / (1024 * 1024)) * 10) / 10,
        },
      },
      health: {
        db_status: dbStatus,
        session_status: sessionStatus,
        scheduler_status: schedulerStatus,
      },
      db: {
        init_status: initStatus,
        init_error: initError ? normalizeRuntimeErrorMessage(initError.message || initError) : null,
      },
      session: {
        table: sessionHealthState.table,
        checks: Number(sessionHealthState.checks || 0),
        failures: Number(sessionHealthState.failures || 0),
        probe_interval_seconds: Number(sessionHealthProbeIntervalSeconds || 0),
        last_checked_at: sessionHealthState.lastCheckedAt || null,
        last_ok_at: sessionHealthState.lastOkAt || null,
        last_error_at: sessionHealthState.lastErrorAt || null,
        last_error: sessionHealthState.lastError || null,
        last_duration_ms: Number(sessionHealthState.lastDurationMs || 0),
      },
      scheduler: {
        enabled: Boolean(schedulerHealthState.enabled),
        interval_ms: Number(schedulerHealthState.interval_ms || 0),
        running: Boolean(schedulerHealthState.running),
        run_count: Number(schedulerHealthState.run_count || 0),
        skipped_count: Number(schedulerHealthState.skipped_count || 0),
        error_count: Number(schedulerHealthState.error_count || 0),
        last_started_at: schedulerHealthState.last_started_at || null,
        last_run_at: schedulerHealthState.last_run_at || null,
        last_duration_ms: Number(schedulerHealthState.last_duration_ms || 0),
        last_result: schedulerHealthState.last_result || null,
        last_error_at: schedulerHealthState.last_error_at || null,
        last_error: schedulerHealthState.last_error || null,
      },
      security: {
        admin_ip_allowlist_count: parseSecurityAdminIpAllowlist(settingsCache.security_admin_ip_allowlist).length,
        registration_alert_threshold: normalizeSecurityRegistrationAlertThreshold(
          settingsCache.security_registration_alert_threshold,
          DEFAULT_SETTINGS.security_registration_alert_threshold
        ),
        registration_alert_window_minutes: normalizeSecurityRegistrationAlertWindowMinutes(
          settingsCache.security_registration_alert_window_minutes,
          DEFAULT_SETTINGS.security_registration_alert_window_minutes
        ),
        auto_quarantine_enabled: Boolean(settingsCache.security_auto_quarantine_enabled),
        ip_retention_days: normalizeRetentionDays(
          settingsCache.security_ip_retention_days,
          SECURITY_IP_RETENTION_DAYS_DEFAULT
        ),
        user_agent_retention_days: normalizeRetentionDays(
          settingsCache.security_user_agent_retention_days,
          SECURITY_USER_AGENT_RETENTION_DAYS_DEFAULT
        ),
      },
      migrations: {
        total_available: availableIds.length,
        applied_count: appliedSet.size,
        pending_count: pendingIds.length,
        last_applied_at: migrationRows && migrationRows[0] ? migrationRows[0].applied_at : null,
        pending_ids: pendingIds.slice(0, 30),
      },
      errors: errorSummary,
      incidents,
    });
  } catch (err) {
    return handleDbError(res, err, 'admin.systemHealth.fetch');
  }
});

app.get('/admin/overview', requireOverviewSectionAccess, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'admin.overview.init');
  }
  const roleKeys = getSessionRoleList(req);
  const isAdmin = roleKeys.includes('admin');
  const isDeanery = roleKeys.includes('deanery');
  const isStarosta = roleKeys.includes('starosta');
  const overviewRole = isAdmin
    ? 'admin'
    : (isDeanery
      ? 'deanery'
      : (isStarosta ? 'starosta' : normalizeRoleKey(req.session.role || roleKeys[0] || 'student')));
  let courses = [];
  try {
    courses = await getCoursesCached();
  } catch (err) {
    return handleDbError(res, err, 'admin.overview.courses');
  }
  let courseId = isAdmin ? getAdminCourse(req) : Number(req.session.user.course_id || 1);
  let allowCourseSelect = isAdmin;
  if (!isAdmin) {
    const baseCourseId = Number(req.session.user.course_id || 1);
    const { allowedCourseIds, allowedCourses } = await buildStaffCourseAccess(baseCourseId, courses, roleKeys);
    if (!allowedCourses.length) {
      return res.status(403).send('Forbidden (course access)');
    }
    courses = allowedCourses;
    const requested = Number(req.query.course);
    courseId = allowedCourseIds.has(requested) ? requested : baseCourseId;
    if (!allowedCourseIds.has(courseId) && courses.length) {
      courseId = Number(courses[0].id);
    }
    allowCourseSelect = courses.length > 1;
  }
  if (courses.length && !courses.some((c) => Number(c.id) === Number(courseId))) {
    courseId = Number(courses[0].id);
  }
  let activeSemester = null;
  try {
    activeSemester = await getActiveSemester(courseId);
  } catch (err) {
    return handleDbError(res, err, 'admin.overview.semester');
  }
  try {
    const statsParams = activeSemester ? [courseId, activeSemester.id] : [courseId];
    const [
      usersRow,
      subjectsRow,
      homeworkRow,
      teamworkTasksRow,
      teamworkGroupsRow,
      teamworkMembersRow,
    ] = await Promise.all([
      db.get('SELECT COUNT(*) AS count FROM users WHERE course_id = ?', [courseId]),
      db.get('SELECT COUNT(*) AS count FROM subjects WHERE course_id = ?', [courseId]),
      db.get(
        `SELECT COUNT(*) AS count FROM homework WHERE course_id = ?${activeSemester ? ' AND semester_id = ?' : ''}`,
        statsParams
      ),
      db.get(
        `SELECT COUNT(*) AS count FROM teamwork_tasks WHERE course_id = ?${activeSemester ? ' AND semester_id = ?' : ''}`,
        statsParams
      ),
      db.get(
        `SELECT COUNT(*) AS count
         FROM teamwork_groups g
         JOIN teamwork_tasks t ON t.id = g.task_id
         WHERE t.course_id = ?${activeSemester ? ' AND t.semester_id = ?' : ''}`,
        statsParams
      ),
      db.get(
        `SELECT COUNT(*) AS count
         FROM teamwork_members m
         JOIN teamwork_tasks t ON t.id = m.task_id
         WHERE t.course_id = ?${activeSemester ? ' AND t.semester_id = ?' : ''}`,
        statsParams
      ),
                                  ]);

    const dashboardStats = {
      users: Number(usersRow?.count || 0),
      subjects: Number(subjectsRow?.count || 0),
      homework: Number(homeworkRow?.count || 0),
      teamworkTasks: Number(teamworkTasksRow?.count || 0),
      teamworkGroups: Number(teamworkGroupsRow?.count || 0),
      teamworkMembers: Number(teamworkMembersRow?.count || 0),
    };

    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const weekStart = new Date(today);
    weekStart.setDate(weekStart.getDate() - 6);
    const weeklyLabels = [];
    for (let i = 0; i < 7; i += 1) {
      const d = new Date(weekStart);
      d.setDate(weekStart.getDate() + i);
      weeklyLabels.push(d.toISOString().slice(0, 10));
    }
    let weeklyHomework = weeklyLabels.map(() => 0);
    let weeklyTeamwork = weeklyLabels.map(() => 0);
    let weeklyUserRoles = ['student', 'starosta', 'deanery', 'admin'];
    let weeklyUserSeries = weeklyUserRoles.map(() => weeklyLabels.map(() => 0));
    try {
      const weeklyParams = activeSemester
        ? [courseId, weekStart.toISOString(), activeSemester.id]
        : [courseId, weekStart.toISOString()];
      const [weeklyHomeworkRows, weeklyTeamworkRows, weeklyUsersRows] = await Promise.all([
        db.all(
          `SELECT DATE(created_at::timestamp) AS day, COUNT(*) AS count
           FROM homework
           WHERE course_id = ? AND created_at::timestamp >= ?${activeSemester ? ' AND semester_id = ?' : ''}
           GROUP BY DATE(created_at::timestamp)
           ORDER BY day`,
          weeklyParams
        ),
        db.all(
          `SELECT DATE(created_at::timestamp) AS day, COUNT(*) AS count
           FROM teamwork_tasks
           WHERE course_id = ? AND created_at::timestamp >= ?${activeSemester ? ' AND semester_id = ?' : ''}
           GROUP BY DATE(created_at::timestamp)
           ORDER BY day`,
          weeklyParams
        ),
        db.all(
          `SELECT DATE(created_at) AS day, role, COUNT(*) AS count
           FROM users
           WHERE course_id = ? AND created_at >= ?
           GROUP BY DATE(created_at), role
           ORDER BY day`,
          [courseId, weekStart.toISOString()]
        ),
      ]);

      const homeworkMap = {};
      (weeklyHomeworkRows || []).forEach((row) => {
        const key = String(row.day);
        homeworkMap[key] = Number(row.count || 0);
      });
      const teamworkMap = {};
      (weeklyTeamworkRows || []).forEach((row) => {
        const key = String(row.day);
        teamworkMap[key] = Number(row.count || 0);
      });
      weeklyHomework = weeklyLabels.map((key) => homeworkMap[key] || 0);
      weeklyTeamwork = weeklyLabels.map((key) => teamworkMap[key] || 0);

      const roleOrder = ['student', 'starosta', 'deanery', 'admin'];
      const roleMap = {};
      (weeklyUsersRows || []).forEach((row) => {
        const key = String(row.day);
        if (!roleMap[row.role]) {
          roleMap[row.role] = {};
        }
        roleMap[row.role][key] = Number(row.count || 0);
      });
      weeklyUserRoles = roleOrder.filter((role) => roleMap[role]);
      if (!weeklyUserRoles.length) {
        weeklyUserRoles.push(...roleOrder);
      }
      weeklyUserSeries = weeklyUserRoles.map((role) =>
        weeklyLabels.map((key) => (roleMap[role] && roleMap[role][key]) || 0)
      );
    } catch (weeklyErr) {
      console.error('Database error (admin.dashboard.weekly)', weeklyErr);
    }
    try {
      coursePulse = await buildCoursePulseAnalytics({
        courseId,
        semesterId: activeSemester ? Number(activeSemester.id) : null,
        now: new Date(),
      });
    } catch (pulseErr) {
      console.error('Database error (admin.dashboard.coursePulse)', pulseErr);
    }

    return res.render('admin-overview', {
      username: req.session.user.username,
      role: overviewRole,
      courses,
      selectedCourseId: courseId,
      dashboardStats,
      weeklyLabels,
      weeklyHomework,
      weeklyTeamwork,
      weeklyUserRoles,
      weeklyUserSeries,
      coursePulse,
      limitedStaffView: !isAdmin,
      allowCourseSelect,
      backLink: isAdmin
        ? `/admin?course=${courseId}`
        : (isDeanery ? `/deanery?course=${courseId}` : `/admin?course=${courseId}`),
    });
  } catch (err) {
    return handleDbError(res, err, 'admin.overview.stats');
  }
});

app.get('/admin/users.json', requireUsersSectionAccess, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return res.status(500).json({ error: 'Database error' });
  }
  const rawStatus = String(req.query.status || 'active').trim().toLowerCase();
  const status = rawStatus === 'inactive' || rawStatus === 'all' ? rawStatus : 'active';
  const q = req.query.q;
  const group = req.query.group;
  const courseId = getAdminCourse(req);
  ensureUsersSchema(() => {
    const userFilters = ['u.course_id = ?'];
    const userParams = [courseId];
    if (usersHasIsActive) {
      if (status === 'inactive') {
        userFilters.push('u.is_active = 0');
      } else if (status === 'active') {
        userFilters.push('u.is_active = 1');
      }
    }
    if (q) {
      userFilters.push('u.full_name ILIKE ?');
      userParams.push(`%${q}%`);
    }
    if (group) {
      userFilters.push('u.schedule_group = ?');
      userParams.push(group);
    }
    const userWhere = userFilters.length ? `WHERE ${userFilters.join(' AND ')}` : '';
    const activeColumn = usersHasIsActive ? 'u.is_active,' : '';
    db.all(
      `
        SELECT
          u.id,
          u.full_name,
          u.role,
          u.schedule_group,
          ${activeColumn}
          COALESCE(NULLIF(u.last_login_ip, ''), NULLIF(reg.ip, '')) AS last_login_ip,
          COALESCE(NULLIF(u.last_user_agent, ''), NULLIF(reg.user_agent, '')) AS last_user_agent,
          u.last_login_at,
          u.course_id,
          COALESCE(usc.risk_level, 'normal') AS security_risk_level,
          COALESCE(usc.status, 'open') AS security_case_status,
          COALESCE(usc.risk_score, 0)::int AS security_risk_score,
          usc.updated_at AS security_case_updated_at
        FROM users u
        LEFT JOIN LATERAL (
          SELECT re.ip, re.user_agent
          FROM user_registration_events re
          WHERE re.user_id = u.id
          ORDER BY re.created_at DESC
          LIMIT 1
        ) reg ON true
        LEFT JOIN user_security_cases usc ON usc.user_id = u.id
        ${userWhere}
        ORDER BY u.full_name
      `,
      userParams,
      (userErr, users) => {
        if (userErr) {
          console.error('Database error (admin.users.json.users)', userErr);
          return res.status(500).json({ error: 'Database error' });
        }
        getSubjectsCached(courseId)
          .then((subjects) => {
            getCoursesCached()
              .then((courses) => {
                db.all(
                  `
                    SELECT sg.student_id, sg.subject_id, sg.group_number
                    FROM student_groups sg
                    JOIN subjects s ON s.id = sg.subject_id
                    WHERE s.course_id = ?
                  `,
                  [courseId],
                  (sgErr, studentGroups) => {
                    if (sgErr) {
                      console.error('Database error (admin.users.json.studentGroups)', sgErr);
                      return res.status(500).json({ error: 'Database error' });
                    }
                    (async () => {
                      const userIds = (users || []).map((user) => Number(user.id)).filter((id) => Number.isFinite(id));
                      const assignment = await getUserRoleAssignmentsForUserIds(userIds);
                      const usersWithRoles = (users || []).map((user) => {
                        const userId = Number(user.id);
                        const roleKeys = assignment.roleKeysByUser[userId] || [normalizeRoleKey(user.role || 'student')];
                        const primaryRole = assignment.primaryRoleByUser[userId]
                          || normalizeRoleKey(user.role || roleKeys[0] || 'student');
                        return {
                          ...user,
                          role_keys: roleKeys,
                          primary_role: primaryRole,
                        };
                      });
                      res.json({ users: usersWithRoles, subjects, studentGroups, courses, selectedCourseId: courseId });
                    })().catch((roleErr) => {
                      console.error('Database error (admin.users.json.roles)', roleErr);
                      return res.status(500).json({ error: 'Database error' });
                    });
                  }
                );
              })
              .catch((courseErr) => {
                console.error('Database error (admin.users.json.courses)', courseErr);
                return res.status(500).json({ error: 'Database error' });
              });
          })
          .catch((subjectErr) => {
            console.error('Database error (admin.users.json.subjects)', subjectErr);
            return res.status(500).json({ error: 'Database error' });
          });
      }
    );
  });
});

app.post('/admin/import/validate', requireImportExportSectionAccess, writeLimiter, csvUpload.single('csv_file'), async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'admin.import.validate.init');
  }
  if (!req.file || !req.file.buffer) {
    return res.status(400).json({ error: 'Missing CSV' });
  }
  const type = String(req.body.type || '').trim().toLowerCase();
  if (!Object.prototype.hasOwnProperty.call(IMPORT_REQUIRED_COLUMNS, type)) {
    return res.status(400).json({ error: 'Invalid import type' });
  }
  let rows = [];
  try {
    rows = parseCsvText(req.file.buffer.toString('utf8'));
  } catch (err) {
    return res.status(400).json({ error: 'Invalid CSV' });
  }
  if (!rows.length) {
    return res.status(400).json({ error: 'Empty CSV' });
  }

  let scope = null;
  try {
    scope = await resolveImportScope(req, type);
  } catch (err) {
    return res.status(500).json({ error: 'Scope error' });
  }
  if (scope && scope.error) {
    return res.status(400).json({ error: scope.error });
  }
  const scopeCourseId = scope.course.id;
  const scopeSemesterId = scope.semester ? scope.semester.id : null;
  const requiredCols = IMPORT_REQUIRED_COLUMNS[type] || [];

  let subjectMap = null;
  let existingSchedule = null;
  let existingUsers = null;
  let existingSubjects = null;
  if (type === 'schedule') {
    const subjects = await getSubjectsCached(scopeCourseId);
    subjectMap = new Map((subjects || []).map((s) => [String(s.name || '').trim().toLowerCase(), s]));
    const existingRows = await db.all(
      `
        SELECT subject_id, group_number, day_of_week, class_number, week_number, lesson_type
        FROM schedule_entries
        WHERE course_id = ? AND semester_id = ?
      `,
      [scopeCourseId, scopeSemesterId]
    );
    existingSchedule = new Map();
    (existingRows || []).forEach((row) => {
      const key = `${row.week_number}|${row.day_of_week}|${row.class_number}|${row.group_number}`;
      existingSchedule.set(key, row);
    });
  } else if (type === 'users') {
    const existingRows = await db.all('SELECT id, LOWER(full_name) AS full_name FROM users');
    existingUsers = new Set((existingRows || []).map((row) => String(row.full_name)));
  } else if (type === 'subjects') {
    const existingRows = await db.all('SELECT name FROM subjects WHERE course_id = ?', [scopeCourseId]);
    existingSubjects = new Set((existingRows || []).map((row) => String(row.name || '').trim().toLowerCase()));
  }

  const errors = [];
  let createCount = 0;
  let updateCount = 0;
  let skipCount = 0;
  let scopeMismatch = false;
  rows.forEach((row, idx) => {
    const rowNumber = idx + 2;
    let rowInvalid = false;

    requiredCols.forEach((col) => {
      if (!(col in row)) {
        rowInvalid = true;
        pushImportError(errors, rowNumber, col, '', 'Missing column');
      }
    });

    if (row.course_id && Number(row.course_id) !== Number(scopeCourseId)) {
      scopeMismatch = true;
      rowInvalid = true;
      pushImportError(errors, rowNumber, 'course_id', row.course_id, 'Does not match selected scope');
    }
    if (type === 'schedule' && row.semester_id && Number(row.semester_id) !== Number(scopeSemesterId)) {
      scopeMismatch = true;
      rowInvalid = true;
      pushImportError(errors, rowNumber, 'semester_id', row.semester_id, 'Does not match selected scope');
    }

    if (type === 'schedule') {
      const subjectName = String(row.subject || '').trim().toLowerCase();
      const subject = subjectMap ? subjectMap.get(subjectName) : null;
      const groupNumber = Number(row.group_number);
      const classNumber = Number(row.class_number);
      const weekNumber = Number(row.week_number);
      const dayOfWeek = normalizeWeekdayName(row.day_of_week);
      if (!subject) {
        rowInvalid = true;
        pushImportError(errors, rowNumber, 'subject', row.subject, 'Unknown subject');
      }
      if (Number.isNaN(groupNumber)) {
        rowInvalid = true;
        pushImportError(errors, rowNumber, 'group_number', row.group_number, 'Invalid group_number');
      }
      if (Number.isNaN(classNumber)) {
        rowInvalid = true;
        pushImportError(errors, rowNumber, 'class_number', row.class_number, 'Invalid class_number');
      }
      if (Number.isNaN(weekNumber)) {
        rowInvalid = true;
        pushImportError(errors, rowNumber, 'week_number', row.week_number, 'Invalid week_number');
      } else if (scope.semester && weekNumber > Number(scope.semester.weeks_count || 15)) {
        rowInvalid = true;
        pushImportError(errors, rowNumber, 'week_number', row.week_number, 'Week exceeds semester length');
      }
      if (!dayOfWeek) {
        rowInvalid = true;
        pushImportError(errors, rowNumber, 'day_of_week', row.day_of_week, 'Invalid day');
      }
      if (rowInvalid) {
        skipCount += 1;
        return;
      }
      const key = `${weekNumber}|${dayOfWeek}|${classNumber}|${groupNumber}`;
      if (existingSchedule && existingSchedule.has(key)) {
        updateCount += 1;
      } else {
        createCount += 1;
      }
      return;
    }

    if (type === 'users') {
      const fullName = String(row.full_name || '').trim();
      if (!fullName) {
        rowInvalid = true;
        pushImportError(errors, rowNumber, 'full_name', row.full_name, 'Missing full_name');
      }
      if (row.is_active !== '' && row.is_active !== undefined && row.is_active !== null && Number.isNaN(Number(row.is_active))) {
        rowInvalid = true;
        pushImportError(errors, rowNumber, 'is_active', row.is_active, 'Invalid is_active');
      }
      if (row.course_id && Number.isNaN(Number(row.course_id))) {
        rowInvalid = true;
        pushImportError(errors, rowNumber, 'course_id', row.course_id, 'Invalid course_id');
      }
      if (rowInvalid) {
        skipCount += 1;
        return;
      }
      if (existingUsers && existingUsers.has(fullName.toLowerCase())) {
        updateCount += 1;
      } else {
        createCount += 1;
      }
      return;
    }

    if (type === 'subjects') {
      const name = String(row.name || '').trim();
      const groupCount = row.group_count ? Number(row.group_count) : NaN;
      const defaultGroup = row.default_group ? Number(row.default_group) : NaN;
      if (!name) {
        rowInvalid = true;
        pushImportError(errors, rowNumber, 'name', row.name, 'Missing name');
      }
      if (Number.isNaN(groupCount) || groupCount < 1 || groupCount > 3) {
        rowInvalid = true;
        pushImportError(errors, rowNumber, 'group_count', row.group_count, 'Invalid group_count');
      }
      if (Number.isNaN(defaultGroup) || defaultGroup < 1 || defaultGroup > groupCount) {
        rowInvalid = true;
        pushImportError(errors, rowNumber, 'default_group', row.default_group, 'Invalid default_group');
      }
      if (rowInvalid) {
        skipCount += 1;
        return;
      }
      if (existingSubjects && existingSubjects.has(name.toLowerCase())) {
        updateCount += 1;
      } else {
        createCount += 1;
      }
    }
  });

  const operationId = randomUUID();
  setImportValidationCache(operationId, {
    errors,
    type,
    scope: {
      course_id: scopeCourseId,
      semester_id: scopeSemesterId,
      campus: scope.campus,
    },
  });
  logAction(db, req, `${type}_import_validate`, {
    operation_id: operationId,
    creates: createCount,
    updates: updateCount,
    skips: skipCount,
    errors: errors.length,
    scope: {
      course_id: scopeCourseId,
      semester_id: scopeSemesterId,
      campus: scope.campus,
    },
  });
  return res.json({
    operation_id: operationId,
    counts: {
      creates: createCount,
      updates: updateCount,
      skips: skipCount,
      errors: errors.length,
    },
    errors_preview: errors.slice(0, 20),
    requires_confirm: type === 'users' || createCount + updateCount > IMPORT_CONFIRM_THRESHOLD,
    blocked: scopeMismatch,
    scope: {
      course_id: scopeCourseId,
      semester_id: scopeSemesterId,
      campus: scope.campus,
    },
  });
});

app.get('/admin/import/errors.csv', requireImportExportSectionAccess, (req, res) => {
  const operationId = String(req.query.op || '').trim();
  if (!operationId) {
    return res.status(400).send('Missing operation id');
  }
  const entry = getImportValidationCache(operationId);
  if (!entry) {
    return res.status(404).send('Error report expired');
  }
  const header = ['row_number', 'column', 'value', 'reason'];
  const lines = [header.join(',')];
  (entry.errors || []).forEach((err) => {
    lines.push(
      [err.row_number, err.column, err.value, err.reason]
        .map((val) => escapeCsvValue(val))
        .join(',')
    );
  });
  res.setHeader('Content-Type', 'text/csv');
  res.setHeader('Content-Disposition', `attachment; filename="import_errors_${operationId}.csv"`);
  return res.send(lines.join('\n'));
});

app.get('/admin/export/schedule.csv', requireImportExportSectionAccess, async (req, res) => {
  const courseId = getAdminCourse(req);
  const activeSemester = await getActiveSemester(courseId);
  db.all(
    `
      SELECT se.id, s.name AS subject, se.group_number, se.day_of_week, se.class_number, se.week_number, se.lesson_type
      FROM schedule_entries se
      JOIN subjects s ON s.id = se.subject_id
      WHERE se.course_id = ?${activeSemester ? ' AND se.semester_id = ?' : ''}
      ORDER BY se.week_number, se.day_of_week, se.class_number
    `,
    activeSemester ? [courseId, activeSemester.id] : [courseId],
    (err, rows) => {
      if (err) {
        return res.status(500).send('Database error');
      }
      const header = 'id,subject,group_number,day_of_week,class_number,week_number,lesson_type';
      const lines = rows.map((r) =>
        [r.id, r.subject, r.group_number, r.day_of_week, r.class_number, r.week_number, r.lesson_type || '']
          .map((v) => escapeCsvValue(v))
          .join(',')
      );
      res.setHeader('Content-Type', 'text/csv');
      res.setHeader('Content-Disposition', 'attachment; filename="schedule.csv"');
      res.send([header, ...lines].join('\n'));
    }
  );
});

app.post('/admin/import/schedule.csv', requireImportExportSectionAccess, writeLimiter, csvUpload.single('csv_file'), async (req, res) => {
  if (!req.file || !req.file.buffer) {
    return res.redirect('/admin?err=Missing%20CSV');
  }
  const confirmRequired = String(req.body.confirm_required || '') === '1';
  const confirmPhrase = String(req.body.confirm_phrase || '').trim().toUpperCase();
  if (confirmRequired && confirmPhrase !== 'IMPORT') {
    return res.redirect('/admin?err=Type%20IMPORT%20to%20confirm');
  }
  let scope = null;
  try {
    scope = await resolveImportScope(req, 'schedule');
  } catch (err) {
    return res.redirect('/admin?err=Semester%20error');
  }
  if (!scope || scope.error || !scope.semester) {
    return res.redirect('/admin?err=No%20active%20semester');
  }
  const courseId = scope.course.id;
  const activeSemester = scope.semester;
  let subjects = [];
  try {
    subjects = await getSubjectsCached(courseId);
  } catch (err) {
    return res.redirect('/admin?err=Subjects%20error');
  }
  const subjectMap = new Map(
    (subjects || []).map((s) => [String(s.name || '').trim().toLowerCase(), s])
  );
  let rows = [];
  try {
    const text = req.file.buffer.toString('utf8');
    rows = parseCsvText(text);
  } catch (err) {
    return res.redirect('/admin?err=Invalid%20CSV');
  }
  if (!rows.length) {
    return res.redirect('/admin?err=Empty%20CSV');
  }
  let inserted = 0;
  let updated = 0;
  let skipped = 0;
  const operationId = randomUUID();
  for (const row of rows) {
    if (row.course_id && Number(row.course_id) !== Number(courseId)) {
      skipped += 1;
      continue;
    }
    if (row.semester_id && Number(row.semester_id) !== Number(activeSemester.id)) {
      skipped += 1;
      continue;
    }
    const subjectName = String(row.subject || '').trim().toLowerCase();
    const subject = subjectMap.get(subjectName);
    const groupNumber = Number(row.group_number);
    const classNumber = Number(row.class_number);
    const weekNumber = Number(row.week_number);
    const dayOfWeek = normalizeWeekdayName(row.day_of_week);
    const lessonType = normalizeLessonType(row.lesson_type);
    if (
      !subject ||
      Number.isNaN(groupNumber) ||
      Number.isNaN(classNumber) ||
      Number.isNaN(weekNumber) ||
      weekNumber > Number(activeSemester.weeks_count || 15) ||
      !dayOfWeek
    ) {
      skipped += 1;
      continue;
    }
    const existing = await db.get(
      `SELECT id FROM schedule_entries
       WHERE course_id = ? AND semester_id = ? AND week_number = ?
         AND day_of_week = ? AND class_number = ? AND group_number = ?`,
      [courseId, activeSemester.id, weekNumber, dayOfWeek, classNumber, groupNumber]
    );
    if (existing && existing.id) {
      if (lessonType) {
        await db.run('UPDATE schedule_entries SET subject_id = ?, lesson_type = ? WHERE id = ?', [subject.id, lessonType, existing.id]);
      } else {
        await db.run('UPDATE schedule_entries SET subject_id = ? WHERE id = ?', [subject.id, existing.id]);
      }
      updated += 1;
    } else {
      await db.run(
        `INSERT INTO schedule_entries
         (subject_id, group_number, day_of_week, class_number, week_number, course_id, semester_id, lesson_type)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
        [subject.id, groupNumber, dayOfWeek, classNumber, weekNumber, courseId, activeSemester.id, lessonType]
      );
      inserted += 1;
    }
  }
  logAction(db, req, 'schedule_import_csv', {
    inserted,
    updated,
    skipped,
    course_id: courseId,
    semester_id: activeSemester.id,
    operation_id: operationId,
  });
  return res.redirect(`/admin?ok=Schedule%20imported%20(${inserted}%2F${updated}%2F${skipped})&op=${operationId}`);
});

app.get('/admin/export/users.csv', requireImportExportSectionAccess, (req, res) => {
  const courseId = Number(req.query.course || getAdminCourse(req));
  const semesterId = req.query.semester_id ? Number(req.query.semester_id) : null;
  const group = req.query.group;
  const filters = ['u.course_id = ?'];
  const params = [courseId];
  if (group) {
    filters.push('u.schedule_group = ?');
    params.push(group);
  }
  if (semesterId) {
    filters.push(
      `EXISTS (
        SELECT 1
        FROM student_groups sg
        JOIN schedule_entries se
          ON se.subject_id = sg.subject_id
         AND se.group_number = sg.group_number
         AND se.semester_id = ?
        WHERE sg.student_id = u.id
      )`
    );
    params.push(semesterId);
  }
  const where = filters.length ? `WHERE ${filters.join(' AND ')}` : '';
  db.all(
    `SELECT u.id, u.full_name, u.role, u.schedule_group, u.is_active, u.course_id
     FROM users u
     ${where}
     ORDER BY u.full_name`,
    params,
    (err, rows) => {
    if (err) {
      return res.status(500).send('Database error');
    }
    const header = 'id,full_name,role,schedule_group,is_active,course_id';
    const lines = rows.map((r) =>
      [r.id, r.full_name, r.role, r.schedule_group, r.is_active, r.course_id]
        .map((v) => escapeCsvValue(v))
        .join(',')
    );
    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', 'attachment; filename="users.csv"');
    res.send([header, ...lines].join('\n'));
  });
});

app.post('/admin/import/users.csv', requireImportExportSectionAccess, writeLimiter, csvUpload.single('csv_file'), async (req, res) => {
  if (!req.file || !req.file.buffer) {
    return res.redirect('/admin?err=Missing%20CSV');
  }
  const confirmRequired = String(req.body.confirm_required || '') === '1';
  const confirmPhrase = String(req.body.confirm_phrase || '').trim().toUpperCase();
  if (confirmRequired && confirmPhrase !== 'IMPORT') {
    return res.redirect('/admin?err=Type%20IMPORT%20to%20confirm');
  }
  let scope = null;
  try {
    scope = await resolveImportScope(req, 'users');
  } catch (err) {
    return res.redirect('/admin?err=Invalid%20scope');
  }
  if (!scope || scope.error) {
    return res.redirect('/admin?err=Invalid%20scope');
  }
  const courseId = scope.course.id;
  let rows = [];
  let courses = [];
  try {
    const text = req.file.buffer.toString('utf8');
    rows = parseCsvText(text);
    courses = await getCoursesCached();
  } catch (err) {
    return res.redirect('/admin?err=Invalid%20CSV');
  }
  if (!rows.length) {
    return res.redirect('/admin?err=Empty%20CSV');
  }
  const courseSet = new Set((courses || []).map((c) => Number(c.id)));
  let inserted = 0;
  let updated = 0;
  let skipped = 0;
  const operationId = randomUUID();
  for (const row of rows) {
    const fullName = String(row.full_name || '').trim().replace(/\s+/g, ' ');
    if (!fullName) {
      skipped += 1;
      continue;
    }
    const role = String(row.role || 'student').trim().toLowerCase();
    const scheduleGroup = String(row.schedule_group || 'A').trim();
    const isActive = row.is_active === '' ? 1 : Number(row.is_active) ? 1 : 0;
    if (row.course_id && Number(row.course_id) !== Number(courseId)) {
      skipped += 1;
      continue;
    }
    const rowCourse = row.course_id ? Number(row.course_id) : courseId;
    const finalCourse = courseSet.has(rowCourse) ? rowCourse : courseId;
    const existing = await db.get('SELECT id FROM users WHERE LOWER(full_name) = LOWER(?)', [fullName]);
    if (existing && existing.id) {
      await db.run(
        `UPDATE users
         SET role = ?, schedule_group = ?, is_active = ?, course_id = ?, language = COALESCE(language, ?)
         WHERE id = ?`,
        [role || 'student', scheduleGroup || 'A', isActive, finalCourse, 'uk', existing.id]
      );
      updated += 1;
    } else {
      await db.run(
        `INSERT INTO users (full_name, role, password_hash, is_active, schedule_group, course_id, language)
         VALUES (?, ?, NULL, ?, ?, ?, ?)`,
        [fullName, role || 'student', isActive, scheduleGroup || 'A', finalCourse, 'uk']
      );
      inserted += 1;
    }
  }
  logAction(db, req, 'users_import_csv', {
    inserted,
    updated,
    skipped,
    course_id: courseId,
    operation_id: operationId,
  });
  broadcast('users_updated');
  return res.redirect(`/admin?ok=Users%20imported%20(${inserted}%2F${updated}%2F${skipped})&op=${operationId}`);
});

app.get('/admin/export/subjects.csv', requireImportExportSectionAccess, (req, res) => {
  const courseId = getAdminCourse(req);
  db.all(
    'SELECT id, name, group_count, default_group, is_required, is_general FROM subjects WHERE course_id = ? ORDER BY name',
    [courseId],
    (err, rows) => {
    if (err) {
      return res.status(500).send('Database error');
    }
    const header = 'id,name,group_count,default_group,is_required,is_general';
    const lines = rows.map((r) =>
      [r.id, r.name, r.group_count, r.default_group, r.is_required ? 1 : 0, r.is_general ? 1 : 0]
        .map((v) => escapeCsvValue(v))
        .join(',')
    );
    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', 'attachment; filename="subjects.csv"');
    res.send([header, ...lines].join('\n'));
  });
});

app.post('/admin/import/subjects.csv', requireImportExportSectionAccess, writeLimiter, csvUpload.single('csv_file'), async (req, res) => {
  if (!req.file || !req.file.buffer) {
    return res.redirect('/admin?err=Missing%20CSV');
  }
  const confirmRequired = String(req.body.confirm_required || '') === '1';
  const confirmPhrase = String(req.body.confirm_phrase || '').trim().toUpperCase();
  if (confirmRequired && confirmPhrase !== 'IMPORT') {
    return res.redirect('/admin?err=Type%20IMPORT%20to%20confirm');
  }
  let scope = null;
  try {
    scope = await resolveImportScope(req, 'subjects');
  } catch (err) {
    return res.redirect('/admin?err=Invalid%20scope');
  }
  if (!scope || scope.error) {
    return res.redirect('/admin?err=Invalid%20scope');
  }
  const courseId = scope.course.id;
  let rows = [];
  try {
    const text = req.file.buffer.toString('utf8');
    rows = parseCsvText(text);
  } catch (err) {
    return res.redirect('/admin?err=Invalid%20CSV');
  }
  if (!rows.length) {
    return res.redirect('/admin?err=Empty%20CSV');
  }
  let inserted = 0;
  let updated = 0;
  let skipped = 0;
  const operationId = randomUUID();
  for (const row of rows) {
    if (row.course_id && Number(row.course_id) !== Number(courseId)) {
      skipped += 1;
      continue;
    }
    const name = String(row.name || '').trim();
    const groupCount = row.group_count ? Number(row.group_count) : 1;
    const defaultGroup = row.default_group ? Number(row.default_group) : 1;
    const isRequired = String(row.is_required ?? '1');
    const isGeneral = String(row.is_general ?? '1');
    const requiredFlag = ['0', 'false', 'no', 'off'].includes(isRequired.toLowerCase()) ? 0 : 1;
    const generalFlag = ['0', 'false', 'no', 'off'].includes(isGeneral.toLowerCase()) ? 0 : 1;
    if (!name || Number.isNaN(groupCount) || groupCount < 1 || groupCount > 3 || Number.isNaN(defaultGroup) || defaultGroup < 1 || defaultGroup > groupCount) {
      skipped += 1;
      continue;
    }
    const existing = await db.get('SELECT id FROM subjects WHERE name = ?', [name]);
    if (existing && existing.id) {
      await db.run(
        'UPDATE subjects SET group_count = ?, default_group = ?, is_required = ?, is_general = ?, course_id = ? WHERE id = ?',
        [groupCount, defaultGroup, requiredFlag, generalFlag, courseId, existing.id]
      );
      updated += 1;
    } else {
      await db.run(
        'INSERT INTO subjects (name, group_count, default_group, show_in_teamwork, visible, is_required, is_general, course_id) VALUES (?, ?, ?, 1, 1, ?, ?, ?)',
        [name, groupCount, defaultGroup, requiredFlag, generalFlag, courseId]
      );
      inserted += 1;
    }
  }
  invalidateSubjectsCache(courseId);
  logAction(db, req, 'subjects_import_csv', {
    inserted,
    updated,
    skipped,
    course_id: courseId,
    operation_id: operationId,
  });
  return res.redirect(`/admin?ok=Subjects%20imported%20(${inserted}%2F${updated}%2F${skipped})&op=${operationId}`);
});

app.get('/admin/history.csv', requireHistorySectionAccess, (req, res) => {
  const { history_actor, history_action, history_q, history_from, history_to } = req.query;
  const filters = [];
  const params = [];
  if (history_actor) {
    filters.push('actor_name LIKE ?');
    params.push(`%${history_actor}%`);
  }
  if (history_action) {
    filters.push('action LIKE ?');
    params.push(`%${history_action}%`);
  }
  if (history_q) {
    filters.push('details LIKE ?');
    params.push(`%${history_q}%`);
  }
  if (history_from) {
    filters.push('created_at >= ?');
    params.push(new Date(history_from).toISOString());
  }
  if (history_to) {
    const end = new Date(history_to);
    end.setHours(23, 59, 59, 999);
    filters.push('created_at <= ?');
    params.push(end.toISOString());
  }
  const where = filters.length ? `WHERE ${filters.join(' AND ')}` : '';
  db.all(`SELECT * FROM history_log ${where} ORDER BY created_at DESC`, params, (err, rows) => {
    if (err) {
      return res.status(500).send('Database error');
    }
    const header = 'id,actor_name,action,details,created_at';
    const lines = rows.map((r) =>
      [r.id, r.actor_name, r.action, r.details, r.created_at]
        .map((v) => escapeCsvValue(v))
        .join(',')
    );
    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', 'attachment; filename="history.csv"');
    res.send([header, ...lines].join('\n'));
  });
});

app.get('/admin/history.json', requireHistorySectionAccess, (req, res) => {
  const { history_actor, history_action, history_q, history_from, history_to } = req.query;
  const filters = [];
  const params = [];
  if (history_actor) {
    filters.push('actor_name LIKE ?');
    params.push(`%${history_actor}%`);
  }
  if (history_action) {
    filters.push('action LIKE ?');
    params.push(`%${history_action}%`);
  }
  if (history_q) {
    filters.push('details LIKE ?');
    params.push(`%${history_q}%`);
  }
  if (history_from) {
    filters.push('created_at >= ?');
    params.push(new Date(history_from).toISOString());
  }
  if (history_to) {
    const end = new Date(history_to);
    end.setHours(23, 59, 59, 999);
    filters.push('created_at <= ?');
    params.push(end.toISOString());
  }
  const where = filters.length ? `WHERE ${filters.join(' AND ')}` : '';
  db.all(`SELECT * FROM history_log ${where} ORDER BY created_at DESC LIMIT 500`, params, (err, rows) => {
    if (err) {
      return res.status(500).json({ error: 'Database error' });
    }
    res.json({ logs: rows });
  });
});

app.get('/admin/user-logins.json', requireActivitySectionAccess, (req, res) => {
  const { user_id } = req.query;
  if (!user_id) {
    return res.status(400).json({ error: 'Missing user_id' });
  }
  db.all(
    'SELECT id, ip, user_agent, created_at FROM login_history WHERE user_id = ? ORDER BY created_at DESC LIMIT 20',
    [user_id],
    (err, rows) => {
      if (err) {
        return res.status(500).json({ error: 'Database error' });
      }
      res.json({ logins: rows });
    }
  );
});

app.get('/admin/users/:id/sessions.json', requireUsersSectionAccess, async (req, res) => {
  const targetUserId = Number(req.params.id);
  if (!Number.isFinite(targetUserId) || targetUserId < 1) {
    return res.status(400).json({ error: 'Invalid user id' });
  }
  try {
    await ensureDbReady();
    const scopedCourseId = getAdminCourse(req);
    const canCrossCourse = hasSessionRole(req, 'admin');
    const targetSql = canCrossCourse
      ? 'SELECT id, full_name, course_id FROM users WHERE id = ? LIMIT 1'
      : 'SELECT id, full_name, course_id FROM users WHERE id = ? AND course_id = ? LIMIT 1';
    const targetParams = canCrossCourse ? [targetUserId] : [targetUserId, scopedCourseId];
    const targetUser = await db.get(targetSql, targetParams);
    if (!targetUser) {
      return res.status(404).json({ error: 'User not found' });
    }
    const sessions = await listUserSessions(targetUserId, req.sessionID || null);
    return res.json({
      ok: true,
      user_id: targetUserId,
      sessions,
    });
  } catch (err) {
    return handleDbError(res, err, 'admin.users.sessions');
  }
});

app.post('/admin/users/:id/sessions/revoke-all', requireUsersSectionAccess, writeLimiter, async (req, res) => {
  const targetUserId = Number(req.params.id);
  if (!Number.isFinite(targetUserId) || targetUserId < 1) {
    return res.status(400).json({ error: 'Invalid user id' });
  }
  try {
    await ensureDbReady();
    const scopedCourseId = getAdminCourse(req);
    const canCrossCourse = hasSessionRole(req, 'admin');
    const targetSql = canCrossCourse
      ? 'SELECT id, full_name, course_id FROM users WHERE id = ? LIMIT 1'
      : 'SELECT id, full_name, course_id FROM users WHERE id = ? AND course_id = ? LIMIT 1';
    const targetParams = canCrossCourse ? [targetUserId] : [targetUserId, scopedCourseId];
    const targetUser = await db.get(targetSql, targetParams);
    if (!targetUser) {
      return res.status(404).json({ error: 'User not found' });
    }
    const keepCurrent = parseBinaryFlag(req.body.keep_current, 1) === 1;
    const revokedCount = await revokeUserSessions(targetUserId, {
      excludeSessionId: keepCurrent ? (req.sessionID || null) : null,
    });
    logAction(db, req, 'user_sessions_revoke_all', {
      user_id: targetUserId,
      keep_current: keepCurrent,
      revoked_count: revokedCount,
    });
    await emitSecurityAlertEvent({
      alertKey: 'sessions-revoked',
      severity: 'medium',
      title: 'User sessions revoked',
      message: `Сесії користувача ${targetUser.full_name || targetUserId} скасовано (${revokedCount})`,
      userId: targetUserId,
      courseId: Number(targetUser.course_id || scopedCourseId || 0) || null,
      details: {
        revoked_count: revokedCount,
        keep_current: keepCurrent,
        actor_user_id: Number(req.session.user.id),
      },
      dedupKey: `sessions-revoked|${targetUserId}|${Math.floor(Date.now() / (5 * 60 * 1000))}`,
    });
    return res.json({ ok: true, revoked_count: revokedCount });
  } catch (err) {
    return handleDbError(res, err, 'admin.users.sessions.revokeAll');
  }
});

app.post('/admin/users/:id/risk-case', requireUsersSectionAccess, writeLimiter, async (req, res) => {
  const targetUserId = Number(req.params.id);
  if (!Number.isFinite(targetUserId) || targetUserId < 1) {
    return res.status(400).json({ error: 'Invalid user id' });
  }
  try {
    await ensureDbReady();
    const scopedCourseId = getAdminCourse(req);
    const canCrossCourse = hasSessionRole(req, 'admin');
    const targetSql = canCrossCourse
      ? 'SELECT id, full_name, course_id, is_active, role FROM users WHERE id = ? LIMIT 1'
      : 'SELECT id, full_name, course_id, is_active, role FROM users WHERE id = ? AND course_id = ? LIMIT 1';
    const targetParams = canCrossCourse ? [targetUserId] : [targetUserId, scopedCourseId];
    const targetUser = await db.get(targetSql, targetParams);
    if (!targetUser) {
      return res.status(404).json({ error: 'User not found' });
    }

    const action = String(req.body.action || 'save').trim().toLowerCase();
    if (action === 'refresh') {
      const recomputed = await recomputeUserSecurityCase(targetUserId, {
        allowAutoQuarantine: false,
        courseId: Number.isFinite(Number(targetUser.course_id)) ? Number(targetUser.course_id) : null,
      });
      const refreshedCase = await getUserSecurityCaseWithActors(targetUserId);
      return res.json({
        ok: true,
        recomputed: true,
        score: recomputed ? recomputed.score : 0,
        level: recomputed ? recomputed.level : 'normal',
        reasons: recomputed ? recomputed.reasons : [],
        case: refreshedCase,
      });
    }

    const existingCase = await getUserSecurityCaseWithActors(targetUserId);
    const hasLevel = typeof req.body.risk_level !== 'undefined' && String(req.body.risk_level).trim() !== '';
    const hasStatus = typeof req.body.status !== 'undefined' && String(req.body.status).trim() !== '';
    const hasScore = typeof req.body.risk_score !== 'undefined' && String(req.body.risk_score).trim() !== '';
    const requestedLevel = hasLevel
      ? normalizeSecurityCaseLevel(req.body.risk_level)
      : normalizeSecurityCaseLevel(existingCase && existingCase.risk_level ? existingCase.risk_level : 'normal');
    let requestedStatus = hasStatus
      ? normalizeSecurityCaseStatus(req.body.status)
      : normalizeSecurityCaseStatus(existingCase && existingCase.status ? existingCase.status : 'open');
    const parsedScore = hasScore ? Number(req.body.risk_score) : NaN;
    let riskScore = Number.isFinite(parsedScore)
      ? Math.max(0, Math.round(parsedScore))
      : Number(existingCase && existingCase.risk_score ? existingCase.risk_score : 0);
    if (requestedLevel === 'high-risk' && riskScore < SECURITY_CASE_SCORE_HIGH) {
      riskScore = SECURITY_CASE_SCORE_HIGH;
    } else if (requestedLevel === 'watch' && riskScore < SECURITY_CASE_SCORE_WATCH) {
      riskScore = SECURITY_CASE_SCORE_WATCH;
    } else if (requestedLevel === 'normal' && riskScore >= SECURITY_CASE_SCORE_WATCH) {
      riskScore = 20;
    }
    const reason = trimSecurityText(req.body.reason, 600) || null;
    const resolutionNote = trimSecurityText(req.body.resolution_note, 600) || null;
    const actorUserId = Number(req.session.user.id);

    if (action === 'confirm') {
      requestedStatus = 'confirmed';
    } else if (action === 'close') {
      requestedStatus = 'closed';
    } else if (action === 'reopen') {
      requestedStatus = 'open';
    }

    if (existingCase) {
      await db.run(
        `
          UPDATE user_security_cases
          SET risk_score = ?,
              risk_level = ?,
              status = ?,
              reason = ?,
              resolution_note = ?,
              updated_at = NOW(),
              confirmed_by = CASE WHEN ? THEN ? ELSE confirmed_by END,
              confirmed_at = CASE WHEN ? THEN NOW() ELSE confirmed_at END,
              closed_by = CASE WHEN ? THEN ? WHEN ? THEN NULL ELSE closed_by END,
              closed_at = CASE WHEN ? THEN NOW() WHEN ? THEN NULL ELSE closed_at END
          WHERE user_id = ?
        `,
        [
          riskScore,
          requestedLevel,
          requestedStatus,
          reason || existingCase.reason || null,
          resolutionNote || existingCase.resolution_note || null,
          action === 'confirm' ? 1 : 0,
          actorUserId,
          action === 'confirm' ? 1 : 0,
          action === 'close' ? 1 : 0,
          actorUserId,
          action === 'reopen' ? 1 : 0,
          action === 'close' ? 1 : 0,
          action === 'reopen' ? 1 : 0,
          targetUserId,
        ]
      );
    } else {
      await db.run(
        `
          INSERT INTO user_security_cases
            (
              user_id,
              risk_score,
              risk_level,
              status,
              reason,
              resolution_note,
              signal_counters,
              auto_quarantined,
              allowlisted,
              confirmed_by,
              confirmed_at,
              closed_by,
              closed_at,
              last_risk_at,
              last_recomputed_at,
              created_at,
              updated_at
            )
          VALUES (?, ?, ?, ?, ?, ?, ?, 0, 0, ?, ?, ?, ?, NOW(), NOW(), NOW(), NOW())
        `,
        [
          targetUserId,
          riskScore,
          requestedLevel,
          requestedStatus,
          reason,
          resolutionNote,
          JSON.stringify({ manual: true }),
          action === 'confirm' ? actorUserId : null,
          action === 'confirm' ? new Date().toISOString() : null,
          action === 'close' ? actorUserId : null,
          action === 'close' ? new Date().toISOString() : null,
        ]
      );
    }

    const shouldQuarantine = (
      requestedLevel === 'high-risk'
      && settingsCache.security_auto_quarantine_enabled
      && Number(targetUser.is_active) === 1
      && action !== 'close'
    );
    if (shouldQuarantine) {
      await db.run('UPDATE users SET is_active = 0 WHERE id = ? AND is_active = 1', [targetUserId]);
      await db.run(
        `
          UPDATE user_security_cases
          SET auto_quarantined = true,
              updated_at = NOW()
          WHERE user_id = ?
        `,
        [targetUserId]
      );
      broadcast('users_updated');
    }

    logAction(db, req, 'user_security_case_update', {
      user_id: targetUserId,
      action,
      risk_level: requestedLevel,
      status: requestedStatus,
      risk_score: riskScore,
    });
    const updatedCase = await getUserSecurityCaseWithActors(targetUserId);
    return res.json({
      ok: true,
      case: updatedCase,
      quarantined: shouldQuarantine,
    });
  } catch (err) {
    return handleDbError(res, err, 'admin.users.riskCase.update');
  }
});

app.get('/admin/users/:id/forensics.json', requireUsersSectionAccess, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'admin.users.forensics.init');
  }

  const targetUserId = Number(req.params.id);
  if (!Number.isFinite(targetUserId) || targetUserId <= 0) {
    return res.status(400).json({ error: 'Invalid user id' });
  }
  const scopedCourseId = getAdminCourse(req);
  const canCrossCourseForensics = hasSessionRole(req, 'admin');

  const addIfPresent = (setRef, rawValue, normalizer) => {
    const normalized = normalizer(rawValue);
    if (normalized) setRef.add(normalized);
  };

  const buildInClause = (list) => list.map(() => '?').join(',');
  const parseTs = (rawValue) => {
    const parsed = new Date(rawValue);
    if (Number.isNaN(parsed.getTime())) return null;
    return parsed.toISOString();
  };

  const shortSessionLabel = (sessionId) => {
    const value = String(sessionId || '').trim();
    if (!value) return 'session';
    if (value.length <= 14) return value;
    return `${value.slice(0, 10)}…`;
  };

  try {
    const targetSql = canCrossCourseForensics
      ? `
        SELECT id, full_name, role, schedule_group, course_id, created_at, last_login_ip, last_user_agent, last_login_at
        FROM users
        WHERE id = ?
      `
      : `
        SELECT id, full_name, role, schedule_group, course_id, created_at, last_login_ip, last_user_agent, last_login_at
        FROM users
        WHERE id = ? AND course_id = ?
      `;
    const targetParams = canCrossCourseForensics ? [targetUserId] : [targetUserId, scopedCourseId];
    const targetUser = await db.get(targetSql, targetParams);
    if (!targetUser) {
      return res.status(404).json({ error: 'User not found' });
    }

    const targetCreatedAtIso = toIsoStringSafe(targetUser.created_at);
    const targetLoginRows = await db.all(
      `
        SELECT ip, user_agent, created_at
        FROM login_history
        WHERE user_id = ?
        ORDER BY created_at DESC
        LIMIT 20
      `,
      [targetUserId]
    );

    let registrationEvent = null;
    try {
      registrationEvent = await db.get(
        `
          SELECT id, ip, user_agent, device_fingerprint, session_id, source, course_id, created_at
          FROM user_registration_events
          WHERE user_id = ?
          ORDER BY created_at DESC
          LIMIT 1
        `,
        [targetUserId]
      );
    } catch (err) {
      registrationEvent = null;
    }

    let inferredRegistrationRows = [];
    if (!registrationEvent && targetCreatedAtIso) {
      const inferredParams = [targetCreatedAtIso, targetCreatedAtIso];
      let inferredSql = `
        SELECT
          session_id,
          ip,
          user_agent,
          COUNT(*)::int AS event_count,
          MIN(created_at) AS first_seen_at,
          MAX(created_at) AS last_seen_at
        FROM site_visit_events
        WHERE page_key = 'register'
          AND created_at >= (?::timestamptz - INTERVAL '20 minutes')
          AND created_at <= (?::timestamptz + INTERVAL '45 minutes')
      `;
      if (Number.isFinite(Number(targetUser.course_id))) {
        inferredSql += ' AND (course_id IS NULL OR course_id = ?) ';
        inferredParams.push(Number(targetUser.course_id));
      }
      inferredSql += `
        GROUP BY session_id, ip, user_agent
        ORDER BY event_count DESC, ABS(EXTRACT(EPOCH FROM (MIN(created_at) - ?::timestamptz))) ASC
        LIMIT 12
      `;
      inferredParams.push(targetCreatedAtIso);
      inferredRegistrationRows = await db.all(inferredSql, inferredParams);
    }

    const evidenceIpsSet = new Set();
    const evidenceAgentsSet = new Set();
    const evidenceFingerprintsSet = new Set();
    const evidenceSessionsSet = new Set();

    addIfPresent(evidenceIpsSet, targetUser.last_login_ip, normalizeForensicsIp);
    addIfPresent(evidenceAgentsSet, targetUser.last_user_agent, normalizeForensicsAgent);
    addIfPresent(evidenceFingerprintsSet, buildForensicsDeviceFingerprint(targetUser.last_user_agent), normalizeForensicsToken);

    (targetLoginRows || []).forEach((row) => {
      addIfPresent(evidenceIpsSet, row.ip, normalizeForensicsIp);
      addIfPresent(evidenceAgentsSet, row.user_agent, normalizeForensicsAgent);
      addIfPresent(evidenceFingerprintsSet, buildForensicsDeviceFingerprint(row.user_agent), normalizeForensicsToken);
    });

    if (registrationEvent) {
      addIfPresent(evidenceIpsSet, registrationEvent.ip, normalizeForensicsIp);
      addIfPresent(evidenceAgentsSet, registrationEvent.user_agent, normalizeForensicsAgent);
      addIfPresent(evidenceFingerprintsSet, registrationEvent.device_fingerprint, normalizeForensicsToken);
      addIfPresent(evidenceSessionsSet, registrationEvent.session_id, normalizeForensicsToken);
    }

    (inferredRegistrationRows || []).forEach((row) => {
      addIfPresent(evidenceIpsSet, row.ip, normalizeForensicsIp);
      addIfPresent(evidenceAgentsSet, row.user_agent, normalizeForensicsAgent);
      addIfPresent(evidenceFingerprintsSet, buildForensicsDeviceFingerprint(row.user_agent), normalizeForensicsToken);
      addIfPresent(evidenceSessionsSet, row.session_id, normalizeForensicsToken);
    });

    const matchesByUser = new Map();
    const addMatch = (row, payload) => {
      const userId = Number(row.user_id || row.id);
      if (!Number.isFinite(userId) || userId <= 0 || userId === targetUserId) return;
      if (!matchesByUser.has(userId)) {
        matchesByUser.set(userId, {
          user_id: userId,
          full_name: row.full_name || `User ${userId}`,
          role: normalizeRoleKey(row.role || 'student'),
          course_id: Number.isFinite(Number(row.course_id)) ? Number(row.course_id) : null,
          schedule_group: row.schedule_group || null,
          score: 0,
          reason_keys: new Set(),
          reasons: [],
          ip_hits: new Set(),
          session_hits: new Set(),
          agent_hits: new Set(),
          last_seen_at: null,
        });
      }
      const entry = matchesByUser.get(userId);
      const reasonKey = String(payload.reason_key || '').trim();
      const reasonLabel = String(payload.reason || '').trim();
      if (reasonKey && !entry.reason_keys.has(reasonKey)) {
        entry.reason_keys.add(reasonKey);
        entry.reasons.push(reasonLabel || reasonKey);
        entry.score += Number(payload.points || 0);
      }
      addIfPresent(entry.ip_hits, payload.ip, normalizeForensicsIp);
      addIfPresent(entry.session_hits, payload.session_id, normalizeForensicsToken);
      addIfPresent(entry.agent_hits, payload.user_agent, normalizeForensicsAgent);
      const seenAt = parseTs(payload.occurred_at || row.last_seen_at || row.created_at);
      if (seenAt) {
        if (!entry.last_seen_at || new Date(seenAt).getTime() > new Date(entry.last_seen_at).getTime()) {
          entry.last_seen_at = seenAt;
        }
      }
      if (Number.isFinite(Number(targetUser.course_id)) && Number(entry.course_id) === Number(targetUser.course_id)) {
        const courseReason = 'meta:same-course';
        if (!entry.reason_keys.has(courseReason)) {
          entry.reason_keys.add(courseReason);
          entry.reasons.push('Той самий курс');
          entry.score += 4;
        }
      }
    };

    const evidenceSessions = Array.from(evidenceSessionsSet).filter((v) => String(v).trim().length);
    const rawEvidenceIps = Array.from(evidenceIpsSet).filter((v) => String(v).trim().length);
    const adminIpAllowlist = parseSecurityAdminIpAllowlist(settingsCache.security_admin_ip_allowlist);
    const allowlistedEvidenceIps = rawEvidenceIps.filter((ip) => isSecurityAdminIpAllowlisted(ip, adminIpAllowlist));
    const evidenceIps = rawEvidenceIps.filter((ip) => !isSecurityAdminIpAllowlisted(ip, adminIpAllowlist));
    const evidenceAgents = Array.from(evidenceAgentsSet).filter((v) => String(v).trim().length);
    const evidenceFingerprints = Array.from(evidenceFingerprintsSet).filter((v) => String(v).trim().length);

    if (evidenceSessions.length) {
      const placeholders = buildInClause(evidenceSessions);
      const scopedClause = canCrossCourseForensics ? '' : ' AND u.course_id = ? ';
      const rows = await db.all(
        `
          SELECT
            v.user_id,
            u.full_name,
            u.role,
            u.course_id,
            u.schedule_group,
            v.session_id,
            MAX(v.created_at) AS last_seen_at
          FROM site_visit_events v
          JOIN users u ON u.id = v.user_id
          WHERE v.user_id IS NOT NULL
            AND v.user_id <> ?
            AND v.session_id IN (${placeholders})
            ${scopedClause}
          GROUP BY v.user_id, u.full_name, u.role, u.course_id, u.schedule_group, v.session_id
        `,
        canCrossCourseForensics
          ? [targetUserId, ...evidenceSessions]
          : [targetUserId, ...evidenceSessions, scopedCourseId]
      );
      (rows || []).forEach((row) => {
        addMatch(row, {
          points: 82,
          reason_key: `session:${row.session_id}`,
          reason: `Спільна сесія браузера (${shortSessionLabel(row.session_id)})`,
          session_id: row.session_id,
          occurred_at: row.last_seen_at,
        });
      });
    }

    if (evidenceIps.length) {
      const placeholders = buildInClause(evidenceIps);
      const scopedUsersClause = canCrossCourseForensics ? '' : ' AND course_id = ? ';
      const scopedJoinClause = canCrossCourseForensics ? '' : ' AND u.course_id = ? ';

      const userIpRows = await db.all(
        `
          SELECT
            id AS user_id,
            full_name,
            role,
            course_id,
            schedule_group,
            last_login_ip AS ip,
            last_login_at AS last_seen_at
          FROM users
          WHERE id <> ?
            AND last_login_ip IN (${placeholders})
            ${scopedUsersClause}
        `,
        canCrossCourseForensics
          ? [targetUserId, ...evidenceIps]
          : [targetUserId, ...evidenceIps, scopedCourseId]
      );
      (userIpRows || []).forEach((row) => {
        addMatch(row, {
          points: 36,
          reason_key: `users-last-ip:${row.ip}`,
          reason: `Збіг по останньому IP (${row.ip})`,
          ip: row.ip,
          occurred_at: row.last_seen_at,
        });
      });

      const loginIpRows = await db.all(
        `
          SELECT
            lh.user_id,
            u.full_name,
            u.role,
            u.course_id,
            u.schedule_group,
            lh.ip,
            MAX(lh.created_at) AS last_seen_at
          FROM login_history lh
          JOIN users u ON u.id = lh.user_id
          WHERE lh.user_id <> ?
            AND lh.ip IN (${placeholders})
            ${scopedJoinClause}
          GROUP BY lh.user_id, u.full_name, u.role, u.course_id, u.schedule_group, lh.ip
        `,
        canCrossCourseForensics
          ? [targetUserId, ...evidenceIps]
          : [targetUserId, ...evidenceIps, scopedCourseId]
      );
      (loginIpRows || []).forEach((row) => {
        addMatch(row, {
          points: 42,
          reason_key: `login-ip:${row.ip}`,
          reason: `Збіг по IP у login history (${row.ip})`,
          ip: row.ip,
          occurred_at: row.last_seen_at,
        });
      });

      const visitIpRows = await db.all(
        `
          SELECT
            v.user_id,
            u.full_name,
            u.role,
            u.course_id,
            u.schedule_group,
            v.ip,
            MAX(v.created_at) AS last_seen_at
          FROM site_visit_events v
          JOIN users u ON u.id = v.user_id
          WHERE v.user_id IS NOT NULL
            AND v.user_id <> ?
            AND v.ip IN (${placeholders})
            ${scopedJoinClause}
          GROUP BY v.user_id, u.full_name, u.role, u.course_id, u.schedule_group, v.ip
        `,
        canCrossCourseForensics
          ? [targetUserId, ...evidenceIps]
          : [targetUserId, ...evidenceIps, scopedCourseId]
      );
      (visitIpRows || []).forEach((row) => {
        addMatch(row, {
          points: 28,
          reason_key: `visit-ip:${row.ip}`,
          reason: `Збіг по IP у візитах (${row.ip})`,
          ip: row.ip,
          occurred_at: row.last_seen_at,
        });
      });

      try {
        const registrationIpRows = await db.all(
          `
            SELECT
              re.user_id,
              u.full_name,
              u.role,
              u.course_id,
              u.schedule_group,
              re.ip,
              MAX(re.created_at) AS last_seen_at
            FROM user_registration_events re
            JOIN users u ON u.id = re.user_id
            WHERE re.user_id <> ?
              AND re.ip IN (${placeholders})
              ${scopedJoinClause}
            GROUP BY re.user_id, u.full_name, u.role, u.course_id, u.schedule_group, re.ip
          `,
          canCrossCourseForensics
            ? [targetUserId, ...evidenceIps]
            : [targetUserId, ...evidenceIps, scopedCourseId]
        );
        (registrationIpRows || []).forEach((row) => {
          addMatch(row, {
            points: 45,
            reason_key: `registration-ip:${row.ip}`,
            reason: `Збіг по IP під час реєстрації (${row.ip})`,
            ip: row.ip,
            occurred_at: row.last_seen_at,
          });
        });
      } catch (err) {
        // no-op if table is missing on legacy nodes
      }
    }

    if (evidenceAgents.length) {
      const placeholders = buildInClause(evidenceAgents);
      const scopedUsersClause = canCrossCourseForensics ? '' : ' AND course_id = ? ';
      const scopedJoinClause = canCrossCourseForensics ? '' : ' AND u.course_id = ? ';

      const userAgentRows = await db.all(
        `
          SELECT
            id AS user_id,
            full_name,
            role,
            course_id,
            schedule_group,
            last_user_agent AS user_agent,
            last_login_at AS last_seen_at
          FROM users
          WHERE id <> ?
            AND last_user_agent IN (${placeholders})
            ${scopedUsersClause}
        `,
        canCrossCourseForensics
          ? [targetUserId, ...evidenceAgents]
          : [targetUserId, ...evidenceAgents, scopedCourseId]
      );
      (userAgentRows || []).forEach((row) => {
        addMatch(row, {
          points: 18,
          reason_key: `users-agent:${row.user_agent}`,
          reason: 'Збіг по пристрою (останній логін)',
          user_agent: row.user_agent,
          occurred_at: row.last_seen_at,
        });
      });

      const loginAgentRows = await db.all(
        `
          SELECT
            lh.user_id,
            u.full_name,
            u.role,
            u.course_id,
            u.schedule_group,
            lh.user_agent,
            MAX(lh.created_at) AS last_seen_at
          FROM login_history lh
          JOIN users u ON u.id = lh.user_id
          WHERE lh.user_id <> ?
            AND lh.user_agent IN (${placeholders})
            ${scopedJoinClause}
          GROUP BY lh.user_id, u.full_name, u.role, u.course_id, u.schedule_group, lh.user_agent
        `,
        canCrossCourseForensics
          ? [targetUserId, ...evidenceAgents]
          : [targetUserId, ...evidenceAgents, scopedCourseId]
      );
      (loginAgentRows || []).forEach((row) => {
        addMatch(row, {
          points: 16,
          reason_key: `login-agent:${row.user_agent}`,
          reason: 'Збіг по пристрою в login history',
          user_agent: row.user_agent,
          occurred_at: row.last_seen_at,
        });
      });
    }

    if (evidenceFingerprints.length) {
      const placeholders = buildInClause(evidenceFingerprints);
      const scopedJoinClause = canCrossCourseForensics ? '' : ' AND u.course_id = ? ';
      try {
        const registrationFingerprintRows = await db.all(
          `
            SELECT
              re.user_id,
              u.full_name,
              u.role,
              u.course_id,
              u.schedule_group,
              re.device_fingerprint,
              MAX(re.created_at) AS last_seen_at
            FROM user_registration_events re
            JOIN users u ON u.id = re.user_id
            WHERE re.user_id <> ?
              AND re.device_fingerprint IN (${placeholders})
              ${scopedJoinClause}
            GROUP BY re.user_id, u.full_name, u.role, u.course_id, u.schedule_group, re.device_fingerprint
          `,
          canCrossCourseForensics
            ? [targetUserId, ...evidenceFingerprints]
            : [targetUserId, ...evidenceFingerprints, scopedCourseId]
        );
        (registrationFingerprintRows || []).forEach((row) => {
          addMatch(row, {
            points: 24,
            reason_key: `registration-fingerprint:${row.device_fingerprint}`,
            reason: 'Збіг device fingerprint під час реєстрації',
            occurred_at: row.last_seen_at,
          });
        });
      } catch (err) {
        // no-op if table is missing on legacy nodes
      }
    }

    const matches = Array.from(matchesByUser.values())
      .map((row) => {
        const confidence = resolveForensicsConfidence(row.score);
        return {
          user_id: row.user_id,
          full_name: row.full_name,
          role: row.role,
          course_id: row.course_id,
          schedule_group: row.schedule_group,
          score: Number(row.score || 0),
          confidence: confidence.key,
          confidence_label: confidence.label,
          reasons: row.reasons.slice(0, 6),
          ip_hits: Array.from(row.ip_hits),
          session_hits: Array.from(row.session_hits),
          agent_hits: Array.from(row.agent_hits),
          last_seen_at: row.last_seen_at,
        };
      })
      .sort((a, b) => {
        if (Number(b.score || 0) !== Number(a.score || 0)) {
          return Number(b.score || 0) - Number(a.score || 0);
        }
        const aSeen = a.last_seen_at ? new Date(a.last_seen_at).getTime() : 0;
        const bSeen = b.last_seen_at ? new Date(b.last_seen_at).getTime() : 0;
        return bSeen - aSeen;
      })
      .slice(0, 10);

    const suspectedOwner = matches.length && matches[0].score >= 35 ? matches[0] : null;
    const confidenceRank = { high: 3, medium: 2, low: 1, weak: 0 };
    const strongMatches = matches.filter((row) => Number(confidenceRank[row.confidence] || 0) >= 2).length;
    const riskReasons = [];
    let riskScore = 0;
    if (suspectedOwner) {
      riskScore += Number(suspectedOwner.score || 0) >= 110 ? 62 : 36;
      riskReasons.push(`Ймовірний власник: ${suspectedOwner.full_name}`);
    }
    if (strongMatches >= 2) {
      riskScore += 24;
      riskReasons.push(`Кілька сильних збігів (${strongMatches})`);
    }
    if (evidenceSessions.length) {
      riskScore += 14;
      riskReasons.push(`Є збіги по session (${evidenceSessions.length})`);
    }
    if (evidenceIps.length) {
      riskScore += 10;
      riskReasons.push(`Є збіги по IP (${evidenceIps.length})`);
    }
    if (allowlistedEvidenceIps.length) {
      riskReasons.push(`IP у allowlist (ігнор): ${allowlistedEvidenceIps.join(', ')}`);
    }
    const hasSuppressedOnly =
      allowlistedEvidenceIps.length > 0 &&
      !evidenceIps.length &&
      !evidenceSessions.length &&
      !strongMatches;
    const resolvedRisk = resolveForensicsRiskState(riskScore);
    const riskLevel = hasSuppressedOnly ? 'suppressed' : resolvedRisk.key;
    const riskLabel = hasSuppressedOnly ? 'Збіги приглушено (allowlist)' : resolvedRisk.label;
    const securityAlertWindowMs = SYSTEM_INCIDENT_WINDOW_HOURS * 60 * 60 * 1000;
    const securityAlertsForTarget = runtimeErrorEvents
      .filter((event) => {
        if (String(event?.kind || '').toLowerCase() !== 'security') return false;
        const createdAtMs = new Date(event.created_at).getTime();
        if (!Number.isFinite(createdAtMs) || Date.now() - createdAtMs > securityAlertWindowMs) {
          return false;
        }
        const directUserId = Number(event.user_id || 0);
        if (directUserId === targetUserId) return true;
        const sampleIds = Array.isArray(event.sample_user_ids) ? event.sample_user_ids : [];
        return sampleIds.some((id) => Number(id) === targetUserId);
      })
      .sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime())
      .slice(0, 4);

    let securityCase = await getUserSecurityCaseWithActors(targetUserId);
    try {
      const recomputed = await recomputeUserSecurityCase(targetUserId, {
        allowAutoQuarantine: false,
        courseId: Number.isFinite(Number(targetUser.course_id)) ? Number(targetUser.course_id) : null,
      });
      if (recomputed && recomputed.case) {
        securityCase = recomputed.case;
      }
    } catch (recomputeErr) {
      console.error('Database error (admin.users.forensics.recompute)', recomputeErr);
    }

    const normalizedSecurityCase = securityCase
      ? {
          user_id: Number(securityCase.user_id),
          risk_score: Number(securityCase.risk_score || 0),
          risk_level: normalizeSecurityCaseLevel(securityCase.risk_level),
          status: normalizeSecurityCaseStatus(securityCase.status),
          reason: String(securityCase.reason || ''),
          resolution_note: String(securityCase.resolution_note || ''),
          auto_quarantined: securityCase.auto_quarantined === true || Number(securityCase.auto_quarantined) === 1,
          allowlisted: securityCase.allowlisted === true || Number(securityCase.allowlisted) === 1,
          updated_at: parseTs(securityCase.updated_at),
          last_recomputed_at: parseTs(securityCase.last_recomputed_at),
          confirmed_at: parseTs(securityCase.confirmed_at),
          confirmed_by_name: securityCase.confirmed_by_name ? String(securityCase.confirmed_by_name) : '',
          closed_at: parseTs(securityCase.closed_at),
          closed_by_name: securityCase.closed_by_name ? String(securityCase.closed_by_name) : '',
        }
      : null;

    const graph = buildForensicsGraphPayload(
      {
        id: targetUser.id,
        full_name: targetUser.full_name,
        role: normalizeRoleKey(targetUser.role || 'student'),
      },
      {
        ips: evidenceIps,
        session_ids: evidenceSessions,
        device_fingerprints: evidenceFingerprints,
      },
      matches
    );

    const caseRiskLevel = normalizedSecurityCase ? normalizedSecurityCase.risk_level : null;
    const caseRiskLabel = caseRiskLevel === 'high-risk'
      ? 'Високий ризик'
      : (caseRiskLevel === 'watch'
        ? 'Під наглядом'
        : 'Нормальний ризик');
    const finalRiskLevel = caseRiskLevel && caseRiskLevel !== 'normal'
      ? caseRiskLevel
      : riskLevel;
    const finalRiskLabel = caseRiskLevel && caseRiskLevel !== 'normal'
      ? caseRiskLabel
      : riskLabel;
    const finalRiskScore = normalizedSecurityCase
      ? Math.max(Number(normalizedSecurityCase.risk_score || 0), Number(riskScore || 0))
      : Number(riskScore || 0);
    if (normalizedSecurityCase && normalizedSecurityCase.reason) {
      riskReasons.unshift(`Кейс: ${normalizedSecurityCase.reason}`);
    }

    return res.json({
      target: {
        id: targetUser.id,
        full_name: targetUser.full_name,
        role: normalizeRoleKey(targetUser.role || 'student'),
        course_id: Number.isFinite(Number(targetUser.course_id)) ? Number(targetUser.course_id) : null,
        schedule_group: targetUser.schedule_group || null,
        created_at: parseTs(targetUser.created_at),
        last_login_at: parseTs(targetUser.last_login_at),
      },
      evidence: {
        source: registrationEvent ? 'registration_event' : (inferredRegistrationRows.length ? 'inferred_site_visits' : 'login_only'),
        ips: evidenceIps,
        ignored_ips: allowlistedEvidenceIps,
        session_ids: evidenceSessions,
        user_agents: evidenceAgents,
        device_fingerprints: evidenceFingerprints,
        register_event: registrationEvent
          ? {
              ip: normalizeForensicsIp(registrationEvent.ip),
              user_agent: normalizeForensicsAgent(registrationEvent.user_agent),
              session_id: String(registrationEvent.session_id || '').trim() || null,
              source: registrationEvent.source || 'register_form',
              created_at: parseTs(registrationEvent.created_at),
            }
          : null,
        inferred_register_events: (inferredRegistrationRows || []).slice(0, 4).map((row) => ({
          session_id: String(row.session_id || '').trim() || null,
          ip: normalizeForensicsIp(row.ip),
          user_agent: normalizeForensicsAgent(row.user_agent),
          event_count: Number(row.event_count || 0),
          first_seen_at: parseTs(row.first_seen_at),
          last_seen_at: parseTs(row.last_seen_at),
        })),
        has_login_history: (targetLoginRows || []).length > 0,
      },
      risk: {
        score: Number(finalRiskScore || 0),
        level: finalRiskLevel,
        label: finalRiskLabel,
        reasons: riskReasons.slice(0, 5),
        allowlisted: allowlistedEvidenceIps.length > 0,
        recent_alerts_count: securityAlertsForTarget.length,
        recent_alerts: securityAlertsForTarget.map((event) => ({
          created_at: parseTs(event.created_at),
          label: String(event.label || 'security'),
          message: String(event.message || ''),
        })),
      },
      security_case: normalizedSecurityCase,
      graph,
      suspected_owner: suspectedOwner,
      matches,
    });
  } catch (err) {
    return handleDbError(res, err, 'admin.users.forensics.fetch');
  }
});

app.post('/homework/add', requireLogin, uploadLimiter, upload.single('attachment'), async (req, res) => {
  const {
    description,
    link_url,
    meeting_url,
    tags,
    is_control,
    subject_id,
    group_number,
    day_of_week,
    class_number,
    class_date,
    time,
  } = req.body;
  const filePath = req.file ? `/uploads/${req.file.filename}` : null;
  const fileName = req.file ? req.file.originalname : null;
  const classNum = Number(class_number);
  const groupNum = Number(group_number);
  const subjectId = Number(subject_id);
  const isControl = String(is_control || '').toLowerCase() === '1' ? 1 : 0;
  const isCredit = ['1', 'true', 'on', 'yes'].includes(String(req.body.is_credit || '').toLowerCase()) ? 1 : 0;
  const sessionCourseId = req.session.user?.course_id || 1;
  const inputCourseId = Number(req.body.course_id);
  const isTeacher = hasSessionRole(req, 'teacher');
  const courseId = isTeacher && !Number.isNaN(inputCourseId) ? inputCourseId : sessionCourseId;

  if (
    !description ||
    !day_of_week ||
    !class_date ||
    Number.isNaN(classNum) ||
    Number.isNaN(groupNum) ||
    Number.isNaN(subjectId)
  ) {
    if (req.file) {
      fs.unlink(req.file.path, () => {});
    }
    return res.status(400).send('Missing fields');
  }
  const dayAllowed = await isCourseDayActive(courseId, day_of_week);
  if (!dayAllowed || classNum < 1 || classNum > 7) {
    if (req.file) {
      fs.unlink(req.file.path, () => {});
    }
    return res.status(400).send('Invalid data');
  }

  const { schedule_group: group, username, id: userId } = req.session.user;
  const createdAt = new Date().toISOString();
  const activeSemester = await getActiveSemester(courseId || 1);
  const isStaff = getSessionRoleList(req).some((role) => ['admin', 'deanery', 'starosta', 'teacher'].includes(role));
  let homeworkStatus = isStaff ? String(req.body.status || 'published').toLowerCase() : 'published';
  if (!['draft', 'scheduled', 'published'].includes(homeworkStatus)) {
    homeworkStatus = 'published';
  }
  let scheduledAt = null;
  let publishedAt = createdAt;
  if (homeworkStatus === 'scheduled') {
    const parsed = req.body.scheduled_at ? new Date(req.body.scheduled_at) : null;
    if (!parsed || Number.isNaN(parsed.getTime())) {
      if (req.file) {
        fs.unlink(req.file.path, () => {});
      }
      return res.status(400).send('Schedule date required');
    }
    scheduledAt = parsed.toISOString();
    publishedAt = null;
  }
  if (homeworkStatus === 'draft') {
    publishedAt = null;
  }
  if (!settingsCache.allow_homework_creation && !hasSessionRole(req, 'admin')) {
    if (req.file) {
      fs.unlink(req.file.path, () => {});
    }
    return res.status(403).send('Homework disabled');
  }

  try {
    const subjectRow = await db.get(
      'SELECT name, course_id, group_count, is_general FROM subjects WHERE id = ?',
      [subjectId]
    );
    if (!subjectRow || (subjectRow.course_id && subjectRow.course_id !== (courseId || 1))) {
      if (req.file) {
        fs.unlink(req.file.path, () => {});
      }
      return res.status(400).send('Invalid subject');
    }
    const maxGroups = Number(subjectRow.group_count || 1);
    let targetGroups = [];
    if (isTeacher) {
      const teacherRows = await db.all(
        'SELECT group_number FROM teacher_subjects WHERE user_id = ? AND subject_id = ?',
        [userId, subjectId]
      );
      const teacherAccess = buildTeacherSubjectAccess(teacherRows || [], maxGroups);
      if (!teacherAccess.hasRows) {
        if (req.file) {
          fs.unlink(req.file.path, () => {});
        }
        return res.status(400).send('Invalid subject');
      }

      const scheduleGroupParams = [subjectId, courseId || 1, day_of_week, classNum];
      let scheduleGroupSql = `
        SELECT DISTINCT group_number
        FROM schedule_entries
        WHERE subject_id = ?
          AND course_id = ?
          AND day_of_week = ?
          AND class_number = ?
      `;
      if (activeSemester && activeSemester.id) {
        scheduleGroupSql += ' AND semester_id = ?';
        scheduleGroupParams.push(activeSemester.id);
        const parsedClassDate = /^\d{4}-\d{2}-\d{2}$/.test(String(class_date || ''))
          ? new Date(`${class_date}T00:00:00`)
          : null;
        const classWeek = parsedClassDate ? getAcademicWeekForSemester(parsedClassDate, activeSemester) : null;
        if (Number.isFinite(classWeek) && classWeek > 0) {
          scheduleGroupSql += ' AND week_number = ?';
          scheduleGroupParams.push(classWeek);
        }
      }
      scheduleGroupSql += ' ORDER BY group_number ASC';
      const scheduleGroupsRows = await db.all(scheduleGroupSql, scheduleGroupParams);
      const scheduleGroups = (scheduleGroupsRows || [])
        .map((row) => Number(row.group_number))
        .filter((value) => Number.isInteger(value) && value >= 1 && value <= maxGroups);

      if (scheduleGroups.length) {
        targetGroups = scheduleGroups.filter((value) => teacherAccess.allowAll || teacherAccess.groups.has(value));
      } else if (Number.isInteger(groupNum) && groupNum >= 1 && groupNum <= maxGroups) {
        if (!teacherAccess.allowAll && !teacherAccess.groups.has(groupNum)) {
          if (req.file) {
            fs.unlink(req.file.path, () => {});
          }
          return res.status(400).send('Invalid group');
        }
        targetGroups = [groupNum];
      } else if (teacherAccess.allowAll) {
        targetGroups = Array.from({ length: maxGroups }, (_v, index) => index + 1);
      } else {
        targetGroups = Array.from(teacherAccess.groups || []).sort((a, b) => a - b);
      }
    } else {
      targetGroups = [groupNum];
    }
    if (targetGroups.some((g) => Number.isNaN(g) || g < 1 || g > maxGroups)) {
      if (req.file) {
        fs.unlink(req.file.path, () => {});
      }
      return res.status(400).send('Invalid group');
    }

    const createdIds = [];
    for (const targetGroup of targetGroups) {
      const row = await db.get(
        `
          INSERT INTO homework
          (group_name, subject, day, time, class_number, subject_id, group_number, day_of_week, created_by_id, description, class_date, meeting_url, link_url, file_path, file_name, created_by, created_at, course_id, semester_id, status, scheduled_at, published_at, is_control, is_teacher_homework, is_credit)
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
          RETURNING id
        `,
        [
          group,
          subjectRow.name,
          day_of_week,
          time,
          classNum,
          subjectId,
          targetGroup,
          day_of_week,
          userId,
          description,
          class_date,
          meeting_url || null,
          link_url || null,
          filePath,
          fileName,
          username,
          createdAt,
          courseId || 1,
          activeSemester ? activeSemester.id : null,
          homeworkStatus,
          scheduledAt,
          publishedAt,
          isControl,
          isTeacher ? 1 : 0,
          isCredit,
        ]
      );
      if (!row || !row.id) {
        if (req.file) {
          fs.unlink(req.file.path, () => {});
        }
        return res.status(500).send('Database error');
      }
      createdIds.push(row.id);
    }

    const tagList = String(tags || '')
      .split(',')
      .map((t) => t.trim())
      .filter((t) => t.length);
    for (const tag of tagList) {
      const tagRow = await db.get(
        'INSERT INTO homework_tags (name) VALUES (?) ON CONFLICT (name) DO UPDATE SET name = EXCLUDED.name RETURNING id',
        [tag]
      );
      if (tagRow && tagRow.id && createdIds.length) {
        for (const hwId of createdIds) {
          await db.run(
            'INSERT INTO homework_tag_map (homework_id, tag_id) VALUES (?, ?) ON CONFLICT DO NOTHING',
            [hwId, tagRow.id]
          );
        }
      }
    }

    const logGroup = targetGroups.length === 1 ? targetGroups[0] : null;
    logActivity(
      db,
      req,
      'homework_create',
      'homework',
      createdIds[0] || null,
      {
        subject_id: subjectId,
        group_number: logGroup,
        day_of_week,
        class_number: classNum,
        tags: tagList,
        is_control: isControl,
        is_teacher_homework: isTeacher ? 1 : 0,
        is_credit: isCredit,
      },
      courseId || 1,
      activeSemester ? activeSemester.id : null
    );
    return res.redirect('/schedule');
  } catch (err) {
    if (req.file) {
      fs.unlink(req.file.path, () => {});
    }
    return res.status(500).send('Database error');
  }
});

app.post('/homework/custom', requireLogin, uploadLimiter, upload.single('attachment'), async (req, res) => {
  if (!settingsCache.allow_custom_deadlines && !hasSessionRole(req, 'admin')) {
    return res.status(403).send('Custom deadlines disabled');
  }
  const { description, link_url, meeting_url, subject_id, custom_due_date } = req.body;
  const filePath = req.file ? `/uploads/${req.file.filename}` : null;
  const fileName = req.file ? req.file.originalname : null;
  const subjectId = Number(subject_id);
  const groupInput = req.body.group_number ? Number(req.body.group_number) : null;
  const dueDate = String(custom_due_date || '').slice(0, 10);
  const isCredit = ['1', 'true', 'on', 'yes'].includes(String(req.body.is_credit || '').toLowerCase()) ? 1 : 0;
  if (!description || Number.isNaN(subjectId) || !dueDate) {
    if (req.file) {
      fs.unlink(req.file.path, () => {});
    }
    return res.status(400).send('Missing fields');
  }
  if (!/^\d{4}-\d{2}-\d{2}$/.test(dueDate)) {
    if (req.file) {
      fs.unlink(req.file.path, () => {});
    }
    return res.status(400).send('Invalid date');
  }

  const { schedule_group: group, username, id: userId } = req.session.user;
  const sessionCourseId = req.session.user.course_id || 1;
  const isTeacher = hasSessionRole(req, 'teacher');
  const courseId = isTeacher && !Number.isNaN(Number(req.body.course_id)) ? Number(req.body.course_id) : sessionCourseId;
  const createdAt = new Date().toISOString();
  const activeSemester = await getActiveSemester(courseId || 1);
  const isStaff = getSessionRoleList(req).some((role) => ['admin', 'deanery', 'starosta', 'teacher'].includes(role));
  let homeworkStatus = isStaff ? String(req.body.status || 'published').toLowerCase() : 'published';
  if (!['draft', 'scheduled', 'published'].includes(homeworkStatus)) {
    homeworkStatus = 'published';
  }
  let scheduledAt = null;
  let publishedAt = createdAt;
  if (homeworkStatus === 'scheduled') {
    const parsed = req.body.scheduled_at ? new Date(req.body.scheduled_at) : null;
    if (!parsed || Number.isNaN(parsed.getTime())) {
      if (req.file) {
        fs.unlink(req.file.path, () => {});
      }
      return res.status(400).send('Schedule date required');
    }
    scheduledAt = parsed.toISOString();
    publishedAt = null;
  }
  if (homeworkStatus === 'draft') {
    publishedAt = null;
  }
  if (!settingsCache.allow_homework_creation && !hasSessionRole(req, 'admin')) {
    if (req.file) {
      fs.unlink(req.file.path, () => {});
    }
    return res.status(403).send('Homework disabled');
  }

  try {
    const subjectRow = await db.get('SELECT name, course_id, group_count, is_general FROM subjects WHERE id = ?', [subjectId]);
    if (!subjectRow || (subjectRow.course_id && subjectRow.course_id !== (courseId || 1))) {
      if (req.file) {
        fs.unlink(req.file.path, () => {});
      }
      return res.status(400).send('Invalid subject');
    }
    let targetGroups = [];
    if (isTeacher) {
      const teacherRows = await db.all(
        'SELECT group_number FROM teacher_subjects WHERE user_id = ? AND subject_id = ?',
        [userId, subjectId]
      );
      const maxGroups = Number(subjectRow.group_count || 1);
      const teacherAccess = buildTeacherSubjectAccess(teacherRows || [], maxGroups);
      if (!teacherAccess.hasRows) {
        if (req.file) {
          fs.unlink(req.file.path, () => {});
        }
        return res.status(400).send('Invalid subject');
      }
      if (groupInput && (!Number.isInteger(groupInput) || groupInput < 1 || groupInput > maxGroups)) {
        if (req.file) {
          fs.unlink(req.file.path, () => {});
        }
        return res.status(400).send('Invalid group');
      }
      if (groupInput && (!teacherAccess.allowAll && !teacherAccess.groups.has(groupInput))) {
        if (req.file) {
          fs.unlink(req.file.path, () => {});
        }
        return res.status(400).send('Invalid group');
      }
      if (groupInput && !Number.isNaN(groupInput)) {
        targetGroups = [Number(groupInput)];
      } else if (teacherAccess.allowAll) {
        targetGroups = Array.from({ length: maxGroups }, (_, idx) => idx + 1);
      } else {
        targetGroups = Array.from(teacherAccess.groups || []).sort((a, b) => a - b);
      }
    } else {
      const groupRow = await db.get(
        'SELECT group_number FROM student_groups WHERE student_id = ? AND subject_id = ?',
        [userId, subjectId]
      );
      if (!groupRow) {
        if (req.file) {
          fs.unlink(req.file.path, () => {});
        }
        return res.status(400).send('Invalid group');
      }
      targetGroups = [groupRow.group_number];
    }
    const maxGroups = Number(subjectRow.group_count || 1);
    if (targetGroups.some((g) => Number.isNaN(g) || g < 1 || g > maxGroups)) {
      if (req.file) {
        fs.unlink(req.file.path, () => {});
      }
      return res.status(400).send('Invalid group');
    }
    const dayName = getDayNameFromDate(dueDate);
    let createdId = null;
    for (const targetGroup of targetGroups) {
      const row = await db.get(
        `
          INSERT INTO homework
          (group_name, subject, day, time, class_number, subject_id, group_number, day_of_week, created_by_id, description, class_date, meeting_url, link_url, file_path, file_name, created_by, created_at, course_id, semester_id, is_custom_deadline, custom_due_date, status, scheduled_at, published_at, is_teacher_homework, is_credit)
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
          RETURNING id
        `,
        [
          group,
          subjectRow.name,
          dayName || 'Deadline',
          'Deadline',
          null,
          subjectId,
          targetGroup,
          dayName,
          userId,
          description,
          null,
          meeting_url || null,
          link_url || null,
          filePath,
          fileName,
          username,
          createdAt,
          courseId || 1,
          activeSemester ? activeSemester.id : null,
          1,
          dueDate,
          homeworkStatus,
          scheduledAt,
          publishedAt,
          isTeacher ? 1 : 0,
          isCredit,
        ]
      );
      if (!row || !row.id) {
        if (req.file) {
          fs.unlink(req.file.path, () => {});
        }
        return res.status(500).send('Database error');
      }
      createdId = row.id;
    }
    logActivity(
      db,
      req,
      'homework_create',
      'homework',
      createdId,
      {
        subject_id: subjectId,
        custom_due_date: dueDate,
        is_custom_deadline: true,
        is_teacher_homework: isTeacher ? 1 : 0,
        is_credit: isCredit,
      },
      courseId || 1,
      activeSemester ? activeSemester.id : null
    );
    return res.redirect('/schedule');
  } catch (err) {
    if (req.file) {
      fs.unlink(req.file.path, () => {});
    }
    return res.status(500).send('Database error');
  }
});

app.post('/subgroup/create', requireLogin, async (req, res) => {
  const { homework_id, name } = req.body;
  const { username } = req.session.user;

  if (!homework_id || !name) {
    return res.status(400).send('Missing fields');
  }

  try {
    const existing = await db.get(
      `
        SELECT sm.id
        FROM subgroup_members sm
        JOIN subgroups s ON s.id = sm.subgroup_id
        WHERE s.homework_id = ? AND sm.member_username = ?
        LIMIT 1
      `,
      [homework_id, username]
    );
    if (existing) {
      return res.redirect('/schedule?sg=exists');
    }
    const createdAt = new Date().toISOString();
    const row = await db.get(
      'INSERT INTO subgroups (homework_id, name, created_at) VALUES (?, ?, ?) RETURNING id',
      [homework_id, name, createdAt]
    );
    if (!row || !row.id) {
      return res.status(500).send('Database error');
    }
    await db.run(
      'INSERT INTO subgroup_members (subgroup_id, member_username, joined_at) VALUES (?, ?, ?) ON CONFLICT(subgroup_id, member_username) DO NOTHING',
      [row.id, username, createdAt]
    );
    return res.redirect('/schedule');
  } catch (err) {
    return res.status(500).send('Database error');
  }
});

app.get('/starosta', requireStaff, async (req, res) => {
  try {
    await ensureDbReady();
  } catch (err) {
    return handleDbError(res, err, 'starosta.init');
  }

  const baseCourseId = Number(req.session.user.course_id || 1);
  let allCourses = [];
  try {
    allCourses = await getCoursesCached();
  } catch (err) {
    return handleDbError(res, err, 'starosta.courses');
  }

  const { allowedCourseIds, allowedCourses } = await buildStaffCourseAccess(baseCourseId, allCourses, getSessionRoleList(req));
  if (!allowedCourses.length) {
    return res.status(403).send('Forbidden (course access)');
  }
  const requestedCourse = Number(req.query.course);
  let courseId = allowedCourseIds.has(requestedCourse) ? requestedCourse : baseCourseId;
  if (allowedCourses.length && !allowedCourses.some((course) => Number(course.id) === Number(courseId))) {
    courseId = Number(allowedCourses[0].id);
  }
  const allowCourseSelect = allowedCourses.length > 1;

  const {
    group_number,
    subject,
    q,
    sort_homework,
    homework_from,
    homework_to,
    homework_tag,
  } = req.query;

  let activeSemester = null;
  try {
    activeSemester = await getActiveSemester(courseId);
  } catch (err) {
    return handleDbError(res, err, 'starosta.activeSemester');
  }

  const courses = allowedCourses;
  let semesters = [];
  try {
    semesters = await db.all('SELECT * FROM semesters WHERE course_id = ? ORDER BY start_date DESC', [courseId]);
  } catch (err) {
    return handleDbError(res, err, 'starosta.semesters');
  }

  let users = [];
  try {
    const activeClause = usersHasIsActive ? ' AND is_active = 1' : '';
    users = await db.all(
      `SELECT id, full_name, role, schedule_group, is_active, last_login_ip, last_user_agent, last_login_at, course_id
       FROM users
       WHERE course_id = ?${activeClause}
       ORDER BY full_name`,
      [courseId]
    );
  } catch (err) {
    return handleDbError(res, err, 'starosta.users');
  }

  let subjects = [];
  try {
    subjects = await db.all('SELECT * FROM subjects WHERE course_id = ? ORDER BY name', [courseId]);
  } catch (err) {
    return handleDbError(res, err, 'starosta.subjects');
  }

  const homeworkFilters = [];
  const homeworkParams = [];
  homeworkFilters.push('h.course_id = ?');
  homeworkParams.push(courseId);
  if (activeSemester) {
    homeworkFilters.push('h.semester_id = ?');
    homeworkParams.push(activeSemester.id);
  }
  if (group_number) {
    homeworkFilters.push('h.group_number = ?');
    homeworkParams.push(group_number);
  }
  if (subject) {
    homeworkFilters.push('h.subject LIKE ?');
    homeworkParams.push(`%${subject}%`);
  }
  if (q) {
    homeworkFilters.push('(h.description LIKE ? OR h.created_by LIKE ?)');
    homeworkParams.push(`%${q}%`, `%${q}%`);
  }
  if (homework_from) {
    const start = new Date(homework_from);
    if (!Number.isNaN(start.getTime())) {
      start.setHours(0, 0, 0, 0);
      homeworkFilters.push('h.created_at >= ?');
      homeworkParams.push(start.toISOString());
    }
  }
  if (homework_to) {
    const end = new Date(homework_to);
    if (!Number.isNaN(end.getTime())) {
      end.setHours(23, 59, 59, 999);
      homeworkFilters.push('h.created_at <= ?');
      homeworkParams.push(end.toISOString());
    }
  }
  if (homework_tag) {
    homeworkFilters.push(
      `EXISTS (
        SELECT 1
        FROM homework_tag_map ht
        JOIN homework_tags t ON t.id = ht.tag_id
        WHERE ht.homework_id = h.id AND t.name = ?
      )`
    );
    homeworkParams.push(homework_tag);
  }
  const homeworkWhere = homeworkFilters.length ? `WHERE ${homeworkFilters.join(' AND ')}` : '';
  const homeworkSql = `
    SELECT h.*, subj.name AS subject_name,
           COALESCE(taglist.tags, ARRAY[]::text[]) AS tags
    FROM homework h
    JOIN subjects subj ON subj.id = h.subject_id
    LEFT JOIN LATERAL (
      SELECT array_agg(t.name ORDER BY t.name) AS tags
      FROM homework_tag_map ht
      JOIN homework_tags t ON t.id = ht.tag_id
      WHERE ht.homework_id = h.id
    ) taglist ON true
    ${homeworkWhere}
    ORDER BY h.created_at DESC
  `;

  let homeworkRows = [];
  try {
    homeworkRows = await db.all(homeworkSql, homeworkParams);
  } catch (err) {
    return handleDbError(res, err, 'starosta.homework');
  }
  const homework = sortHomework(homeworkRows, sort_homework);

  let tagRows = [];
  try {
    tagRows = await db.all('SELECT name FROM homework_tags ORDER BY name');
  } catch (err) {
    return handleDbError(res, err, 'starosta.homework.tags');
  }
  const homeworkTags = (tagRows || []).map((row) => row.name);

  let teamworkTasks = [];
  try {
    teamworkTasks = await db.all(
      `
        SELECT t.id, t.title, t.created_at, s.name AS subject_name,
               COUNT(DISTINCT g.id) AS group_count,
               COUNT(DISTINCT m.user_id) AS member_count
        FROM teamwork_tasks t
        JOIN subjects s ON s.id = t.subject_id
        LEFT JOIN teamwork_groups g ON g.task_id = t.id
        LEFT JOIN teamwork_members m ON m.task_id = t.id
        WHERE t.course_id = ?${activeSemester ? ' AND t.semester_id = ?' : ''}
        GROUP BY t.id, t.title, t.created_at, s.name
        ORDER BY t.created_at DESC
      `,
      activeSemester ? [courseId, activeSemester.id] : [courseId]
    );
  } catch (err) {
    return handleDbError(res, err, 'starosta.teamwork');
  }

  let adminMessages = [];
  try {
    adminMessages = await db.all(
      `
        SELECT m.*, s.name AS subject_name, u.full_name AS created_by,
               COALESCE(reads.read_count, 0) AS read_count,
               COALESCE(targets.target_count, 0) AS target_count
        FROM messages m
        LEFT JOIN subjects s ON s.id = m.subject_id
        LEFT JOIN users u ON u.id = m.created_by_id
        LEFT JOIN LATERAL (
          SELECT COUNT(*) AS read_count
          FROM message_reads mr
          WHERE mr.message_id = m.id
        ) reads ON true
        LEFT JOIN LATERAL (
          SELECT CASE
            WHEN m.target_all = 1 THEN (
              SELECT COUNT(*)
              FROM users u2
              WHERE u2.role = 'student' AND u2.is_active = 1
                AND (
                  (m.course_id IS NULL AND m.subject_id IS NULL AND m.group_number IS NULL)
                  OR u2.course_id = m.course_id
                )
            )
            WHEN m.subject_id IS NOT NULL THEN (
              SELECT COUNT(DISTINCT sg.student_id)
              FROM student_groups sg
              JOIN users u3 ON u3.id = sg.student_id
              WHERE sg.subject_id = m.subject_id AND sg.group_number = m.group_number
                AND u3.course_id = m.course_id AND u3.is_active = 1
            )
            ELSE (
              SELECT COUNT(*)
              FROM message_targets mt
              JOIN users u4 ON u4.id = mt.user_id
              WHERE mt.message_id = m.id AND u4.course_id = m.course_id AND u4.is_active = 1
            )
          END AS target_count
        ) targets ON true
        WHERE (
          m.course_id = ?
          OR (m.target_all = 1 AND m.subject_id IS NULL AND m.group_number IS NULL AND m.course_id IS NULL)
        )${activeSemester
          ? ` AND (
              m.semester_id = ?
              OR (m.target_all = 1 AND m.subject_id IS NULL AND m.group_number IS NULL AND m.semester_id IS NULL)
            )`
          : ''}
        ORDER BY m.created_at DESC
        LIMIT 200
      `,
      activeSemester ? [courseId, activeSemester.id] : [courseId]
    );
  } catch (err) {
    return handleDbError(res, err, 'starosta.messages');
  }

  let allowedSections = null;
  try {
    allowedSections = await getRoleAllowedSectionsForRoleKeys(getSessionRoleList(req), 'starosta');
  } catch (err) {
    allowedSections = getRoleAllowedSections('starosta');
  }

  try {
    return res.render('admin', {
      username: req.session.user.username,
      userId: req.session.user.id,
      role: 'starosta',
      schedule: [],
      homework,
      homeworkTags,
      users,
      subjects,
      studentGroups: [],
      logs: [],
      teamworkTasks,
      adminMessages,
      courses,
      semesters,
      activeSemester,
      selectedCourseId: courseId,
      limitedStaffView: true,
      allowedSections,
      allowCourseSelect,
      filters: {
        group_number: group_number || '',
        day: '',
        subject: subject || '',
        q: q || '',
        homework_from: homework_from || '',
        homework_to: homework_to || '',
        homework_tag: homework_tag || '',
      },
      usersStatus: 'active',
      sorts: {
        schedule: '',
        homework: sort_homework || '',
      },
    });
  } catch (renderErr) {
    return handleDbError(res, renderErr, 'starosta.render');
  }
});

app.get('/deanery', requireDeanery, (req, res) => {
  (async () => {
    try {
      await ensureDbReady();
    } catch (err) {
      return handleDbError(res, err, 'deanery.init');
    }
    const baseCourseId = Number(req.session.user.course_id || 1);
    let allCourses = [];
    try {
      allCourses = await getCoursesCached();
    } catch (err) {
      return handleDbError(res, err, 'deanery.courses');
    }
    const { allowedCourseIds, allowedCourses } = await buildStaffCourseAccess(baseCourseId, allCourses, getSessionRoleList(req));
    if (!allowedCourses.length) {
      return res.status(403).send('Forbidden (course access)');
    }
    const requestedCourse = Number(req.query.course);
    let courseId = allowedCourseIds.has(requestedCourse) ? requestedCourse : baseCourseId;
    if (allowedCourses.length && !allowedCourses.some((course) => Number(course.id) === Number(courseId))) {
      courseId = Number(allowedCourses[0].id);
    }
    req.session.adminCourse = courseId;
    const allowCourseSelect = allowedCourses.length > 1;
    let allowedSections = null;
    try {
      allowedSections = await getRoleAllowedSectionsForRoleKeys(getSessionRoleList(req), 'deanery');
    } catch (err) {
      allowedSections = getRoleAllowedSections('deanery');
    }
    const { group_number, day, subject, sort_schedule, schedule_date } = req.query;
    let activeSemester = null;
    try {
      activeSemester = await getActiveSemester(courseId);
    } catch (err) {
      return handleDbError(res, err, 'deanery.activeSemester');
    }
    const scheduleFilters = [];
    const scheduleParams = [];
    scheduleFilters.push('se.course_id = ?');
    scheduleParams.push(courseId);
    if (activeSemester) {
      scheduleFilters.push('se.semester_id = ?');
      scheduleParams.push(activeSemester.id);
    }
    if (group_number) {
      scheduleFilters.push('se.group_number = ?');
      scheduleParams.push(group_number);
    }
    if (day) {
      scheduleFilters.push('se.day_of_week = ?');
      scheduleParams.push(day);
    }
    if (subject) {
      scheduleFilters.push('s.name LIKE ?');
      scheduleParams.push(`%${subject}%`);
    }
    if (schedule_date && activeSemester && activeSemester.start_date) {
      const mapped = getWeekDayForDate(schedule_date, activeSemester.start_date);
      if (mapped) {
        scheduleFilters.push('se.week_number = ?');
        scheduleParams.push(mapped.weekNumber);
        scheduleFilters.push('se.day_of_week = ?');
        scheduleParams.push(mapped.dayName);
      }
    }
    const scheduleWhere = scheduleFilters.length ? `WHERE ${scheduleFilters.join(' AND ')}` : '';
    const scheduleSql = `
      SELECT se.*, s.name AS subject_name
      FROM schedule_entries se
      JOIN subjects s ON s.id = se.subject_id
      ${scheduleWhere}
      ORDER BY se.week_number, se.day_of_week, se.class_number
    `;
    const courses = allowedCourses;
    db.all(
      'SELECT * FROM semesters WHERE course_id = ? ORDER BY start_date DESC',
      [courseId],
      (semErr, semesters) => {
        if (semErr) {
          return handleDbError(res, semErr, 'deanery.semesters');
        }
        db.all('SELECT * FROM subjects WHERE course_id = ? ORDER BY name', [courseId], (subjectErr, subjects) => {
          if (subjectErr) {
            return handleDbError(res, subjectErr, 'deanery.subjects');
          }
          db.all(scheduleSql, scheduleParams, (scheduleErr, scheduleRows) => {
            if (scheduleErr) {
              return handleDbError(res, scheduleErr, 'deanery.schedule');
            }
            const schedule = sortSchedule(scheduleRows, sort_schedule);
            try {
              return res.render('admin', {
                username: req.session.user.username,
                userId: req.session.user.id,
                role: 'deanery',
                schedule,
                homework: [],
                users: [],
                subjects,
                studentGroups: [],
                logs: [],
                teamworkTasks: [],
                adminMessages: [],
                courses,
                semesters,
                activeSemester,
                selectedCourseId: courseId,
                limitedStaffView: true,
                allowedSections,
                allowCourseSelect,
                filters: {
                  group_number: group_number || '',
                  day: day || '',
                  subject: subject || '',
                  schedule_date: schedule_date || '',
                },
                usersStatus: 'active',
                sorts: {
                  schedule: sort_schedule || '',
                  homework: '',
                },
              });
            } catch (renderErr) {
              return handleDbError(res, renderErr, 'deanery.render');
            }
          });
        });
      }
    );
  })();
});

app.post('/subgroup/join', requireLogin, (req, res) => {
  const { subgroup_id } = req.body;
  const { username } = req.session.user;

  if (!subgroup_id) {
    return res.status(400).send('Missing fields');
  }

  db.get(
    `
      SELECT s.homework_id
      FROM subgroups s
      WHERE s.id = ?
      LIMIT 1
    `,
    [subgroup_id],
    (homeErr, row) => {
      if (homeErr || !row) {
        return res.status(500).send('Database error');
      }
      db.get(
        `
          SELECT sm.id
          FROM subgroup_members sm
          JOIN subgroups s ON s.id = sm.subgroup_id
          WHERE s.homework_id = ? AND sm.member_username = ?
          LIMIT 1
        `,
        [row.homework_id, username],
        (existingErr, existing) => {
          if (existingErr) {
            return res.status(500).send('Database error');
          }
          if (existing) {
            return res.redirect('/schedule?sg=exists');
          }
          const joinedAt = new Date().toISOString();
          db.run(
            'INSERT INTO subgroup_members (subgroup_id, member_username, joined_at) VALUES (?, ?, ?) ON CONFLICT(subgroup_id, member_username) DO NOTHING',
            [subgroup_id, username, joinedAt],
            (err) => {
              if (err) {
                return res.status(500).send('Database error');
              }
              return res.redirect('/schedule');
            }
          );
        }
      );
    }
  );
});

app.post('/admin/schedule/add', requireScheduleSectionAccess, async (req, res) => {
  const { subject_id, group_number, group_numbers, day_of_week, class_number, week_numbers, semester_id, lesson_type } = req.body;
  const groupNum = Number(group_number);
  const classNum = Number(class_number);
  const lessonType = normalizeLessonType(lesson_type);
  const courseId = getStaffCourse(req);
  const panelBase = getStaffPanelBase(req, courseId);
  const withStatus = (status) => `${panelBase}&${status}`;
  const semesterId = Number(semester_id);

  if (!subject_id || !day_of_week || !week_numbers || Number.isNaN(classNum) || Number.isNaN(semesterId)) {
    return res.redirect(withStatus('err=Missing%20fields'));
  }
  const dayAllowed = await isCourseDayActive(courseId, day_of_week);
  if (!dayAllowed) {
    return res.redirect(withStatus('err=Invalid%20day'));
  }
  if (classNum < 1 || classNum > 7) {
    return res.redirect(withStatus('err=Invalid%20class%20number'));
  }
  try {
    const subjectRow = await db.get(
      'SELECT course_id, group_count, is_general FROM subjects WHERE id = ?',
      [subject_id]
    );
    if (!subjectRow || (subjectRow.course_id && Number(subjectRow.course_id) !== Number(courseId))) {
      return res.redirect(withStatus('err=Invalid%20subject'));
    }
    const maxGroups = Number(subjectRow.group_count || 1);
    const isGeneral = subjectRow.is_general === true || Number(subjectRow.is_general) === 1;
    const parsedGroups = Array.isArray(group_numbers)
      ? group_numbers
      : typeof group_numbers === 'string' && group_numbers.trim().length
      ? group_numbers.split(',')
      : [];
    const multiGroups = Array.from(
      new Set(
        parsedGroups
          .map((value) => Number(String(value).trim()))
          .filter((value) => Number.isFinite(value))
      )
    ).sort((a, b) => a - b);

    const semRow = await db.get('SELECT weeks_count FROM semesters WHERE id = ? AND course_id = ?', [semesterId, courseId]);
    if (!semRow) {
      return res.redirect(withStatus('err=Invalid%20semester'));
    }
    const maxWeeks = Number(semRow.weeks_count) || 15;
    const weeks = week_numbers
      .split(',')
      .map((w) => Number(w.trim()))
      .filter((w) => !Number.isNaN(w) && w >= 1 && w <= maxWeeks);
    const uniqueWeeks = Array.from(new Set(weeks));
    if (!uniqueWeeks.length) {
      return res.redirect(withStatus('err=Invalid%20weeks'));
    }

    let targetGroups = [];
    if (lessonType === 'lecture') {
      targetGroups = [1];
    } else if (multiGroups.length && !isGeneral) {
      targetGroups = multiGroups;
    } else {
      if (Number.isNaN(groupNum)) {
        return res.redirect(withStatus('err=Missing%20fields'));
      }
      targetGroups = [groupNum];
    }

    if (!targetGroups.length || targetGroups.some((g) => g < 1 || g > maxGroups)) {
      return res.redirect(withStatus('err=Invalid%20group'));
    }

    const stmt = db.prepare(
      'INSERT INTO schedule_entries (subject_id, group_number, day_of_week, class_number, week_number, course_id, semester_id, lesson_type) VALUES (?, ?, ?, ?, ?, ?, ?, ?)'
    );
    uniqueWeeks.forEach((week) => {
      targetGroups.forEach((group) => {
        stmt.run(subject_id, group, day_of_week, classNum, week, courseId, semesterId, lessonType);
      });
    });
    stmt.finalize((err) => {
      if (err) {
        return res.redirect(withStatus('err=Database%20error'));
      }
      logAction(db, req, 'schedule_add', {
        subject_id,
        group_numbers: targetGroups,
        day_of_week,
        class_number: classNum,
        weeks: uniqueWeeks,
        semester_id: semesterId,
      });
      logActivity(db, req, 'schedule_add', 'schedule', null, {
        subject_id,
        group_numbers: targetGroups,
        day_of_week,
        class_number: classNum,
        weeks: uniqueWeeks,
        semester_id: semesterId,
      });
      return res.redirect(withStatus('ok=Class%20added'));
    });
  } catch (err) {
    console.error('Failed to add schedule entry', err);
    return res.redirect(withStatus('err=Database%20error'));
  }
});

app.post('/admin/schedule/edit/:id', requireScheduleSectionAccess, async (req, res) => {
  const { id } = req.params;
  const { subject_id, group_number, day_of_week, class_number, week_number, semester_id, lesson_type } = req.body;
  const groupNum = Number(group_number);
  const classNum = Number(class_number);
  const weekNum = Number(week_number);
  const lessonType = normalizeLessonType(lesson_type);
  const courseId = getStaffCourse(req);
  const panelBase = getStaffPanelBase(req, courseId);
  const withStatus = (status) => `${panelBase}&${status}`;
  const semesterId = Number(semester_id);

  if (!subject_id || !day_of_week || Number.isNaN(groupNum) || Number.isNaN(classNum) || Number.isNaN(weekNum) || Number.isNaN(semesterId)) {
    return res.redirect(withStatus('err=Missing%20fields'));
  }
  const dayAllowed = await isCourseDayActive(courseId, day_of_week);
  if (!dayAllowed) {
    return res.redirect(withStatus('err=Invalid%20day'));
  }
  if (classNum < 1 || classNum > 7) {
    return res.redirect(withStatus('err=Invalid%20class%20or%20week'));
  }
  try {
    const semRow = await db.get('SELECT weeks_count FROM semesters WHERE id = ? AND course_id = ?', [semesterId, courseId]);
    if (!semRow) {
      return res.redirect(withStatus('err=Invalid%20semester'));
    }
    const maxWeeks = Number(semRow.weeks_count) || 15;
    if (weekNum < 1 || weekNum > maxWeeks) {
      return res.redirect(withStatus('err=Invalid%20class%20or%20week'));
    }
    db.run(
      `
        UPDATE schedule_entries
        SET subject_id = ?, group_number = ?, day_of_week = ?, class_number = ?, week_number = ?, semester_id = ?, lesson_type = ?
        WHERE id = ? AND course_id = ?
      `,
      [subject_id, groupNum, day_of_week, classNum, weekNum, semesterId, lessonType, id, courseId],
      (err) => {
        if (err) {
          return res.redirect(withStatus('err=Database%20error'));
        }
        logAction(db, req, 'schedule_edit', { id, subject_id, group_number: groupNum, day_of_week, class_number: classNum, week_number: weekNum, semester_id: semesterId });
        logActivity(db, req, 'schedule_edit', 'schedule', Number(id) || null, {
          subject_id,
          group_number: groupNum,
          day_of_week,
          class_number: classNum,
          week_number: weekNum,
          semester_id: semesterId,
        });
        return res.redirect(withStatus('ok=Class%20updated'));
      }
    );
  } catch (err) {
    console.error('Failed to update schedule entry', err);
    return res.redirect(withStatus('err=Database%20error'));
  }
});

app.post('/admin/schedule/delete/:id', requireScheduleSectionAccess, (req, res) => {
  const { id } = req.params;
  const courseId = getStaffCourse(req);
  const referer = req.get('referer');
  const fallbackBase = getStaffPanelBase(req, courseId);
  const redirectBase = referer && referer.includes('/admin/schedule-list') ? referer : fallbackBase;
  const withStatus = (base, status) => (base.includes('?') ? `${base}&${status}` : `${base}?${status}`);
  db.run('DELETE FROM schedule_entries WHERE id = ? AND course_id = ?', [id, courseId], (err) => {
    if (err) {
      return res.redirect(withStatus(redirectBase, 'err=Database%20error'));
    }
    logActivity(db, req, 'schedule_delete', 'schedule', Number(id) || null, null, courseId);
    logAction(db, req, 'schedule_delete', { id });
    return res.redirect(withStatus(redirectBase, 'ok=Class%20deleted'));
  });
});

app.post('/admin/schedule/delete-multiple', requireScheduleSectionAccess, (req, res) => {
  const ids = req.body.delete_ids;
  const returnTo = req.body.return_to || req.query.return_to || '';
  const referer = req.get('referer');
  const courseId = getStaffCourse(req);
  const fallback = getStaffPanelBase(req, courseId);
  const redirectBase =
    (returnTo && returnTo.startsWith('/admin/schedule-list') ? returnTo : null) ||
    (referer && referer.includes('/admin/schedule-list') ? referer : null) ||
    fallback;
  const withStatus = (base, status) => (base.includes('?') ? `${base}&${status}` : `${base}?${status}`);
  if (!ids) {
    return res.redirect(withStatus(redirectBase, 'err=No%20items%20selected'));
  }
  const list = Array.isArray(ids) ? ids : [ids];
  const placeholders = list.map(() => '?').join(',');
  db.run(`DELETE FROM schedule_entries WHERE course_id = ? AND id IN (${placeholders})`, [courseId, ...list], (err) => {
    if (err) {
      return res.redirect(withStatus(redirectBase, 'err=Database%20error'));
    }
    logActivity(db, req, 'schedule_delete_multiple', 'schedule', null, { ids: list }, courseId);
    logAction(db, req, 'schedule_delete_multiple', { ids: list });
    return res.redirect(withStatus(redirectBase, 'ok=Selected%20classes%20deleted'));
  });
});

app.post('/admin/schedule/clear-all', requireScheduleSectionAccess, (req, res) => {
  const courseId = getStaffCourse(req);
  const referer = req.get('referer');
  const fallbackBase = getStaffPanelBase(req, courseId);
  const redirectBase = referer && referer.includes('/admin/schedule-list') ? referer : fallbackBase;
  const withStatus = (base, status) => (base.includes('?') ? `${base}&${status}` : `${base}?${status}`);
  db.run('DELETE FROM schedule_entries WHERE course_id = ?', [courseId], (err) => {
    if (err) {
      return res.redirect(withStatus(redirectBase, 'err=Database%20error'));
    }
    logActivity(db, req, 'schedule_clear_all', 'schedule', null, null, courseId);
    logAction(db, req, 'schedule_clear_all');
    return res.redirect(withStatus(redirectBase, 'ok=Schedule%20cleared'));
  });
});

app.post('/admin/homework/delete/:id', requireHomeworkSectionAccess, (req, res) => {
  const { id } = req.params;
  db.get('SELECT file_path FROM homework WHERE id = ?', [id], (err, row) => {
    if (err) {
      return res.redirect('/admin?err=Database%20error');
    }
    db.all('SELECT id FROM subgroups WHERE homework_id = ?', [id], (sgErr, subgroups) => {
      if (sgErr) {
        return res.redirect('/admin?err=Database%20error');
      }
      const subgroupIds = subgroups.map((sg) => sg.id);
      const placeholders = subgroupIds.map(() => '?').join(',');
      const deleteMembers = subgroupIds.length
        ? `DELETE FROM subgroup_members WHERE subgroup_id IN (${placeholders})`
        : null;

      const afterMembers = () => {
        const deleteSubgroups = subgroupIds.length
          ? `DELETE FROM subgroups WHERE id IN (${placeholders})`
          : null;
        const afterSubgroups = () => {
          db.run('DELETE FROM homework WHERE id = ?', [id], (delErr) => {
            if (delErr) {
              return res.redirect('/admin?err=Database%20error');
            }
            if (row && row.file_path) {
              const relativePath = row.file_path.replace(/^\/+/, '');
              const absPath = path.join(__dirname, relativePath);
              fs.unlink(absPath, () => {});
            }
            logActivity(db, req, 'homework_delete', 'homework', Number(id) || null, null);
            logAction(db, req, 'homework_delete', { id });
            return res.redirect('/admin?ok=Homework%20deleted');
          });
        };

        if (deleteSubgroups) {
          db.run(deleteSubgroups, subgroupIds, (delSgErr) => {
            if (delSgErr) {
              return res.redirect('/admin?err=Database%20error');
            }
            return afterSubgroups();
          });
        } else {
          return afterSubgroups();
        }
      };

      if (deleteMembers) {
        db.run(deleteMembers, subgroupIds, (delMemErr) => {
          if (delMemErr) {
            return res.redirect('/admin?err=Database%20error');
          }
          return afterMembers();
        });
      } else {
        return afterMembers();
      }
    });
  });
});

app.post('/admin/subjects/add', requireSubjectsSectionAccess, (req, res) => {
  const { name, group_count, default_group, show_in_teamwork, visible, is_required, is_general } = req.body;
  const count = Number(group_count);
  const def = Number(default_group);
  const teamworkFlag = String(show_in_teamwork) === '1' ? 1 : 0;
  const visibleFlag = String(visible) === '0' ? 0 : 1;
  const requiredFlag = String(is_required) === '0' ? 0 : 1;
  const generalFlag = String(is_general) === '1' || String(is_general) === 'on' ? 1 : 0;
  const courseId = getAdminCourse(req);
  if (!name || Number.isNaN(count) || count < 1 || count > 3) {
    return res.redirect('/admin?err=Invalid%20subject%20data');
  }
  if (Number.isNaN(def) || def < 1 || def > count) {
    return res.redirect('/admin?err=Invalid%20default%20group');
  }
  db.run(
    'INSERT INTO subjects (name, group_count, default_group, show_in_teamwork, visible, is_required, is_general, course_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?)',
    [name, count, def, teamworkFlag, visibleFlag, requiredFlag, generalFlag, courseId],
    (err) => {
    if (err) {
      return res.redirect('/admin?err=Database%20error');
    }
    logAction(db, req, 'subject_add', { name, group_count: count, default_group: def, show_in_teamwork: teamworkFlag, visible: visibleFlag, is_required: requiredFlag, is_general: generalFlag });
    logActivity(db, req, 'subject_add', 'subject', null, { name, group_count: count, default_group: def, visible: visibleFlag, is_required: requiredFlag, is_general: generalFlag }, courseId);
    invalidateSubjectsCache(courseId);
    return res.redirect('/admin?ok=Subject%20added');
    }
  );
});

app.post('/admin/subjects/edit/:id', requireSubjectsSectionAccess, (req, res) => {
  const { id } = req.params;
  const { name, group_count, default_group, show_in_teamwork, visible, is_required, is_general } = req.body;
  const count = Number(group_count);
  const def = Number(default_group);
  const teamworkFlag = String(show_in_teamwork) === '1' ? 1 : 0;
  const visibleFlag = String(visible) === '0' ? 0 : 1;
  const requiredFlag = String(is_required) === '0' ? 0 : 1;
  const generalFlag = String(is_general) === '1' || String(is_general) === 'on' ? 1 : 0;
  const courseId = getAdminCourse(req);
  if (!name || Number.isNaN(count) || count < 1 || count > 3) {
    return res.redirect('/admin?err=Invalid%20subject%20data');
  }
  if (Number.isNaN(def) || def < 1 || def > count) {
    return res.redirect('/admin?err=Invalid%20default%20group');
  }
  db.run(
    'UPDATE subjects SET name = ?, group_count = ?, default_group = ?, show_in_teamwork = ?, visible = ?, is_required = ?, is_general = ? WHERE id = ? AND course_id = ?',
    [name, count, def, teamworkFlag, visibleFlag, requiredFlag, generalFlag, id, courseId],
    (err) => {
      if (err) {
        return res.redirect('/admin?err=Database%20error');
      }
      logAction(db, req, 'subject_edit', { id, name, group_count: count, default_group: def, show_in_teamwork: teamworkFlag, visible: visibleFlag, is_required: requiredFlag, is_general: generalFlag });
      logActivity(db, req, 'subject_edit', 'subject', Number(id) || null, { name, group_count: count, default_group: def, visible: visibleFlag, is_required: requiredFlag, is_general: generalFlag }, courseId);
      invalidateSubjectsCache(courseId);
      return res.redirect('/admin?ok=Subject%20updated');
    }
  );
});

app.post('/admin/api/subjects/:subjectId/clone', requireScheduleSectionAccess, async (req, res) => {
  const subjectId = Number(req.params.subjectId);
  const { new_name, copy_settings } = req.body || {};
  if (Number.isNaN(subjectId) || !new_name || !new_name.trim()) {
    return res.status(400).json({ error: 'Invalid input' });
  }
  const courseId = hasSessionRole(req, 'admin') ? getAdminCourse(req) : (req.session.user.course_id || 1);
  try {
    const subject = await db.get('SELECT * FROM subjects WHERE id = ? AND course_id = ?', [subjectId, courseId]);
    if (!subject) return res.status(404).json({ error: 'Subject not found' });
    const copySettings = copy_settings !== false;
    const row = await db.get(
      `INSERT INTO subjects (name, group_count, default_group, show_in_teamwork, visible, is_general, course_id)
       VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id`,
      [
        new_name.trim(),
        copySettings ? subject.group_count : 1,
        copySettings ? subject.default_group : 1,
        copySettings ? subject.show_in_teamwork : 1,
        copySettings ? subject.visible : 1,
        copySettings ? (subject.is_general === false || subject.is_general === 0 ? 0 : 1) : 1,
        courseId,
      ]
    );
    invalidateSubjectsCache(courseId);
    return res.json({ ok: true, id: row?.id });
  } catch (err) {
    return res.status(500).json({ error: 'Database error' });
  }
});

app.post('/admin/api/schedule/weeks/clone', requireScheduleSectionAccess, async (req, res) => {
  const { source_week, target_week, mode } = req.body || {};
  const srcWeek = Number(source_week);
  const tgtWeek = Number(target_week);
  if (Number.isNaN(srcWeek) || Number.isNaN(tgtWeek) || srcWeek < 1 || tgtWeek < 1) {
    return res.status(400).json({ error: 'Invalid week' });
  }
  const courseId = hasSessionRole(req, 'admin') ? getAdminCourse(req) : (req.session.user.course_id || 1);
  let activeSemester = null;
  try {
    activeSemester = await getActiveSemester(courseId);
  } catch (err) {
    return res.status(500).json({ error: 'Semester error' });
  }
  try {
    const studyDays = await getCourseStudyDays(courseId);
    const activeDaySet = new Set((studyDays || []).filter((d) => d.is_active).map((d) => d.day_name));
    const rows = await db.all(
      `SELECT * FROM schedule_entries
       WHERE course_id = ? AND semester_id = ? AND week_number = ?`,
      [courseId, activeSemester ? activeSemester.id : null, srcWeek]
    );
    let inserted = 0;
    for (const row of rows) {
      if (activeDaySet.size && !activeDaySet.has(row.day_of_week)) continue;
      const conflict = await db.get(
        `SELECT id FROM schedule_entries
         WHERE course_id = ? AND semester_id = ? AND week_number = ?
           AND day_of_week = ? AND class_number = ? AND group_number = ?`,
        [courseId, activeSemester ? activeSemester.id : null, tgtWeek, row.day_of_week, row.class_number, row.group_number]
      );
      if (conflict && mode !== 'overwrite') {
        continue;
      }
      if (conflict && mode === 'overwrite') {
        await db.run('DELETE FROM schedule_entries WHERE id = ?', [conflict.id]);
      }
      await db.run(
        `INSERT INTO schedule_entries
         (subject_id, group_number, day_of_week, class_number, week_number, course_id, semester_id, lesson_type)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          row.subject_id,
          row.group_number,
          row.day_of_week,
          row.class_number,
          tgtWeek,
          courseId,
          activeSemester ? activeSemester.id : null,
          row.lesson_type || null,
        ]
      );
      inserted += 1;
    }
    return res.json({ ok: true, inserted });
  } catch (err) {
    return res.status(500).json({ error: 'Database error' });
  }
});

app.post('/admin/api/homework/:homeworkId/clone', requireHomeworkSectionAccess, async (req, res) => {
  const homeworkId = Number(req.params.homeworkId);
  if (Number.isNaN(homeworkId)) return res.status(400).json({ error: 'Invalid homework' });
  const courseId = hasSessionRole(req, 'admin') ? getAdminCourse(req) : (req.session.user.course_id || 1);
  let activeSemester = null;
  try {
    activeSemester = await getActiveSemester(courseId);
  } catch (err) {
    return res.status(500).json({ error: 'Semester error' });
  }
  const { target = {}, copy_attachments = true, copy_links = true } = req.body || {};
  try {
    const hw = await db.get(
      `SELECT * FROM homework WHERE id = ? AND course_id = ? AND semester_id = ?`,
      [homeworkId, courseId, activeSemester ? activeSemester.id : null]
    );
    if (!hw) return res.status(404).json({ error: 'Not found' });
    const createdAt = new Date().toISOString();
    let classDate = null;
    let customDue = null;
    let isCustom = 0;
    let weekNumber = hw.week_number || null;
    let dayOfWeek = hw.day_of_week;
    if (target.week) {
      const w = Number(target.week);
      if (Number.isFinite(w) && w > 0 && dayOfWeek) {
        classDate = getDateForWeekDay(w, dayOfWeek, activeSemester ? activeSemester.start_date : null);
        weekNumber = w;
      }
    } else if (target.class_date) {
      classDate = String(target.class_date).slice(0, 10);
      const mapped = getWeekDayForDate(classDate, activeSemester ? activeSemester.start_date : null);
      if (mapped) {
        weekNumber = mapped.weekNumber;
        dayOfWeek = mapped.dayName;
      }
    } else if (target.deadline) {
      customDue = String(target.deadline).slice(0, 10);
      isCustom = 1;
    }
    const row = await db.get(
      `INSERT INTO homework
       (group_name, subject, day, time, week_number, class_number, subject_id, group_number, day_of_week,
        created_by_id, description, class_date, meeting_url, link_url, file_path, file_name, created_by, created_at,
        course_id, semester_id, is_custom_deadline, custom_due_date, status, scheduled_at, published_at)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
       RETURNING id`,
      [
        hw.group_name,
        hw.subject,
        hw.day,
        hw.time,
        weekNumber,
        hw.class_number,
        hw.subject_id,
        hw.group_number,
        dayOfWeek,
        hw.created_by_id,
        hw.description,
        classDate || hw.class_date,
        copy_links ? hw.meeting_url : null,
        copy_links ? hw.link_url : null,
        copy_attachments ? hw.file_path : null,
        copy_attachments ? hw.file_name : null,
        hw.created_by,
        createdAt,
        courseId,
        activeSemester ? activeSemester.id : null,
        isCustom,
        customDue,
        'published',
        null,
        createdAt,
      ]
    );
    return res.json({ ok: true, id: row?.id });
  } catch (err) {
    return res.status(500).json({ error: 'Database error' });
  }
});

app.post('/admin/subjects/delete/:id', requireSubjectsSectionAccess, (req, res) => {
  const { id } = req.params;
  const courseId = getAdminCourse(req);
  db.run('DELETE FROM student_groups WHERE subject_id = ?', [id], (delErr) => {
    if (delErr) {
      return res.redirect('/admin?err=Database%20error');
    }
    db.run('DELETE FROM subjects WHERE id = ? AND course_id = ?', [id, courseId], (err) => {
      if (err) {
        return res.redirect('/admin?err=Database%20error');
      }
      logAction(db, req, 'subject_delete', { id });
      logActivity(db, req, 'subject_delete', 'subject', Number(id) || null, null, courseId);
      invalidateSubjectsCache(courseId);
      return res.redirect('/admin?ok=Subject%20deleted');
    });
  });
});

app.post('/admin/courses/add', requireCoursesSectionAccess, (req, res) => {
  const { id, name, is_teacher_course, location } = req.body;
  const courseId = Number(id);
  const teacherFlag = String(is_teacher_course) === '1' ? 1 : 0;
  const campus = String(location || 'kyiv').toLowerCase() === 'munich' ? 'munich' : 'kyiv';
  if (Number.isNaN(courseId) || courseId < 1 || !name || !name.trim()) {
    return res.redirect('/admin?err=Invalid%20course');
  }
  db.run(
    'INSERT INTO courses (id, name, is_teacher_course, location) VALUES (?, ?, ?, ?)',
    [courseId, name.trim(), teacherFlag, campus],
    (err) => {
    if (err) {
      return res.redirect('/admin?err=Database%20error');
    }
    logAction(db, req, 'course_add', { id: courseId, name: name.trim(), is_teacher_course: teacherFlag, location: campus });
    invalidateCoursesCache();
    return res.redirect('/admin?ok=Course%20created');
    }
  );
});

app.post('/admin/courses/edit/:id', requireCoursesSectionAccess, (req, res) => {
  const { id } = req.params;
  const { name, is_teacher_course, location } = req.body;
  const courseId = Number(id);
  const teacherFlag = String(is_teacher_course) === '1' ? 1 : 0;
  const campus = String(location || 'kyiv').toLowerCase() === 'munich' ? 'munich' : 'kyiv';
  if (Number.isNaN(courseId) || !name || !name.trim()) {
    return res.redirect('/admin?err=Invalid%20course');
  }
  db.run(
    'UPDATE courses SET name = ?, is_teacher_course = ?, location = ? WHERE id = ?',
    [name.trim(), teacherFlag, campus, courseId],
    (err) => {
    if (err) {
      return res.redirect('/admin?err=Database%20error');
    }
    logAction(db, req, 'course_edit', { id: courseId, name: name.trim(), is_teacher_course: teacherFlag, location: campus });
    invalidateCoursesCache();
    return res.redirect('/admin?ok=Course%20updated');
  });
});

app.post('/admin/courses/delete/:id', requireCoursesSectionAccess, (req, res) => {
  const { id } = req.params;
  const courseId = Number(id);
  if (Number.isNaN(courseId)) {
    return res.redirect('/admin?err=Invalid%20course');
  }
  db.get('SELECT COUNT(*) AS cnt FROM users WHERE course_id = ?', [courseId], (userErr, userRow) => {
    if (userErr) {
      return res.redirect('/admin?err=Database%20error');
    }
    if (Number(userRow.cnt) > 0) {
      return res.redirect('/admin?err=Course%20has%20users');
    }
    db.get('SELECT COUNT(*) AS cnt FROM subjects WHERE course_id = ?', [courseId], (subErr, subRow) => {
      if (subErr) {
        return res.redirect('/admin?err=Database%20error');
      }
      if (Number(subRow.cnt) > 0) {
        return res.redirect('/admin?err=Course%20has%20subjects');
      }
      db.get('SELECT COUNT(*) AS cnt FROM semesters WHERE course_id = ?', [courseId], (semErr, semRow) => {
        if (semErr) {
          return res.redirect('/admin?err=Database%20error');
        }
        if (Number(semRow.cnt) > 0) {
          return res.redirect('/admin?err=Course%20has%20semesters');
        }
        db.run('DELETE FROM courses WHERE id = ?', [courseId], (err) => {
          if (err) {
            return res.redirect('/admin?err=Database%20error');
          }
          logAction(db, req, 'course_delete', { id: courseId });
          invalidateCoursesCache();
          invalidateSubjectsCache(courseId);
          invalidateSemestersCache(courseId);
          invalidateStudyDaysCache(courseId);
          return res.redirect('/admin?ok=Course%20deleted');
        });
      });
    });
  });
});

app.post('/admin/teacher-requests/:userId/approve', requireTeachersSectionAccess, async (req, res) => {
  const userId = Number(req.params.userId);
  if (Number.isNaN(userId)) {
    return res.redirect('/admin?err=Invalid%20user');
  }
  try {
    await ensureDbReady();
    const courseId = getAdminCourse(req);
    const targetUser = await db.get('SELECT id, full_name, role FROM users WHERE id = ? AND course_id = ?', [userId, courseId]);
    if (!targetUser) {
      return res.redirect('/admin?err=User%20not%20found');
    }
    const beforeSnapshot = await getUserRoleSnapshot(userId, targetUser.role || 'student');
    await db.run('UPDATE teacher_requests SET status = ?, updated_at = NOW() WHERE user_id = ?', ['approved', userId]);
    await assignUserRoles(userId, ['teacher'], { preferredPrimary: 'teacher' });
    await recordUserRoleChangeEvent({
      userId,
      actorUserId: Number(req.session.user.id),
      actorName: req.session.user.username,
      courseId,
      source: 'teacher_request_approve',
      reason: 'Teacher request approved',
      beforeRoles: beforeSnapshot.role_keys,
      afterRoles: ['teacher'],
      beforePrimaryRole: beforeSnapshot.primary_role,
      afterPrimaryRole: 'teacher',
      targetFullName: targetUser.full_name || null,
    });
    await recomputeUserSecurityCase(userId, { courseId, allowAutoQuarantine: false });
    logAction(db, req, 'teacher_request_approve', { user_id: userId });
    broadcast('users_updated');
    return res.redirect('/admin?ok=Teacher%20approved');
  } catch (err) {
    console.error('Approve teacher failed', err);
    return res.redirect('/admin?err=Database%20error');
  }
});

app.post('/admin/teacher-requests/:userId/reject', requireTeachersSectionAccess, async (req, res) => {
  const userId = Number(req.params.userId);
  if (Number.isNaN(userId)) {
    return res.redirect('/admin?err=Invalid%20user');
  }
  try {
    await ensureDbReady();
    const courseId = getAdminCourse(req);
    const targetUser = await db.get('SELECT id, full_name, role FROM users WHERE id = ? AND course_id = ?', [userId, courseId]);
    if (!targetUser) {
      return res.redirect('/admin?err=User%20not%20found');
    }
    const beforeSnapshot = await getUserRoleSnapshot(userId, targetUser.role || 'student');
    await db.run('UPDATE teacher_requests SET status = ?, updated_at = NOW() WHERE user_id = ?', ['rejected', userId]);
    await assignUserRoles(userId, ['student'], { preferredPrimary: 'student' });
    await recordUserRoleChangeEvent({
      userId,
      actorUserId: Number(req.session.user.id),
      actorName: req.session.user.username,
      courseId,
      source: 'teacher_request_reject',
      reason: 'Teacher request rejected',
      beforeRoles: beforeSnapshot.role_keys,
      afterRoles: ['student'],
      beforePrimaryRole: beforeSnapshot.primary_role,
      afterPrimaryRole: 'student',
      targetFullName: targetUser.full_name || null,
    });
    await recomputeUserSecurityCase(userId, { courseId, allowAutoQuarantine: false });
    logAction(db, req, 'teacher_request_reject', { user_id: userId });
    broadcast('users_updated');
    return res.redirect('/admin?ok=Teacher%20rejected');
  } catch (err) {
    console.error('Reject teacher failed', err);
    return res.redirect('/admin?err=Database%20error');
  }
});

app.get('/admin/api/courses/:courseId/study-days', requireScheduleSectionAccess, async (req, res) => {
  const courseId = Number(req.params.courseId);
  if (Number.isNaN(courseId) || courseId < 1) {
    return res.status(400).json({ error: 'Invalid course' });
  }
  if (hasSessionRole(req, 'deanery') && !hasSessionRole(req, 'admin') && Number(req.session.user.course_id) !== courseId) {
    return res.status(403).json({ error: 'Forbidden' });
  }
  try {
    const course = await db.get('SELECT id FROM courses WHERE id = ?', [courseId]);
    if (!course) return res.status(404).json({ error: 'Course not found' });
    const studyDays = await getCourseStudyDays(courseId);
    const subjects = await getSubjectsCached(courseId);
    const subjectRows = (subjects || []).map((s) => ({ id: s.id, name: s.name }));
    return res.json({ days: studyDays, subjects: subjectRows });
  } catch (err) {
    return res.status(500).json({ error: 'Database error' });
  }
});

app.patch('/admin/api/courses/:courseId/study-days/:weekday', requireScheduleSectionAccess, async (req, res) => {
  const courseId = Number(req.params.courseId);
  const weekday = Number(req.params.weekday);
  const { is_active } = req.body || {};
  if (Number.isNaN(courseId) || courseId < 1 || Number.isNaN(weekday) || weekday < 1 || weekday > 7) {
    return res.status(400).json({ error: 'Invalid input' });
  }
  if (hasSessionRole(req, 'deanery') && !hasSessionRole(req, 'admin') && Number(req.session.user.course_id) !== courseId) {
    return res.status(403).json({ error: 'Forbidden' });
  }
  try {
    const course = await db.get('SELECT id FROM courses WHERE id = ?', [courseId]);
    if (!course) return res.status(404).json({ error: 'Course not found' });
    await ensureCourseStudyDays(courseId);
    const updatedAt = new Date().toISOString();
    await db.run(
      'UPDATE course_study_days SET is_active = ?, updated_at = ? WHERE course_id = ? AND weekday = ?',
      [is_active ? 1 : 0, updatedAt, courseId, weekday]
    );
    invalidateStudyDaysCache(courseId);
    return res.json({ ok: true });
  } catch (err) {
    return res.status(500).json({ error: 'Database error' });
  }
});

app.post('/admin/api/courses/:courseId/study-days/:weekday/subjects', requireScheduleSectionAccess, async (req, res) => {
  const courseId = Number(req.params.courseId);
  const weekday = Number(req.params.weekday);
  const subjectId = Number(req.body?.subject_id);
  if (Number.isNaN(courseId) || Number.isNaN(weekday) || Number.isNaN(subjectId) || weekday < 1 || weekday > 7) {
    return res.status(400).json({ error: 'Invalid input' });
  }
  if (hasSessionRole(req, 'deanery') && !hasSessionRole(req, 'admin') && Number(req.session.user.course_id) !== courseId) {
    return res.status(403).json({ error: 'Forbidden' });
  }
  try {
    const course = await db.get('SELECT id FROM courses WHERE id = ?', [courseId]);
    if (!course) return res.status(404).json({ error: 'Course not found' });
    const subject = await db.get('SELECT id, course_id FROM subjects WHERE id = ?', [subjectId]);
    if (!subject || Number(subject.course_id) !== courseId) {
      return res.status(400).json({ error: 'Invalid subject' });
    }
    await ensureCourseStudyDays(courseId);
    const dayRow = await db.get(
      'SELECT id FROM course_study_days WHERE course_id = ? AND weekday = ?',
      [courseId, weekday]
    );
    if (!dayRow) return res.status(404).json({ error: 'Day not found' });
    await db.run(
      'INSERT INTO course_day_subjects (course_study_day_id, subject_id) VALUES (?, ?) ON CONFLICT DO NOTHING',
      [dayRow.id, subjectId]
    );
    invalidateStudyDaysCache(courseId);
    return res.json({ ok: true });
  } catch (err) {
    return res.status(500).json({ error: 'Database error' });
  }
});

app.delete('/admin/api/courses/:courseId/study-days/:weekday/subjects/:subjectId', requireScheduleSectionAccess, async (req, res) => {
  const courseId = Number(req.params.courseId);
  const weekday = Number(req.params.weekday);
  const subjectId = Number(req.params.subjectId);
  if (Number.isNaN(courseId) || Number.isNaN(weekday) || Number.isNaN(subjectId) || weekday < 1 || weekday > 7) {
    return res.status(400).json({ error: 'Invalid input' });
  }
  if (hasSessionRole(req, 'deanery') && !hasSessionRole(req, 'admin') && Number(req.session.user.course_id) !== courseId) {
    return res.status(403).json({ error: 'Forbidden' });
  }
  try {
    const dayRow = await db.get(
      'SELECT id FROM course_study_days WHERE course_id = ? AND weekday = ?',
      [courseId, weekday]
    );
    if (!dayRow) return res.status(404).json({ error: 'Day not found' });
    await db.run(
      'DELETE FROM course_day_subjects WHERE course_study_day_id = ? AND subject_id = ?',
      [dayRow.id, subjectId]
    );
    invalidateStudyDaysCache(courseId);
    return res.json({ ok: true });
  } catch (err) {
    return res.status(500).json({ error: 'Database error' });
  }
});

app.get('/admin/api/courses/:courseId/week-time', requireScheduleSectionAccess, async (req, res) => {
  const courseId = Number(req.params.courseId);
  if (Number.isNaN(courseId) || courseId < 1) {
    return res.status(400).json({ error: 'Invalid course' });
  }
  if (hasSessionRole(req, 'deanery') && !hasSessionRole(req, 'admin') && Number(req.session.user.course_id) !== courseId) {
    return res.status(403).json({ error: 'Forbidden' });
  }
  try {
    const course = await db.get('SELECT id FROM courses WHERE id = ?', [courseId]);
    if (!course) return res.status(404).json({ error: 'Course not found' });
    const semester = await getActiveSemester(courseId);
    if (!semester) {
      return res.json({ weeks: [], semester: null });
    }
    const weeks = await getCourseWeekTimeList(courseId, semester);
    return res.json({
      weeks,
      semester: { id: semester.id, weeks_count: semester.weeks_count },
    });
  } catch (err) {
    return res.status(500).json({ error: 'Database error' });
  }
});

app.patch('/admin/api/courses/:courseId/week-time/:weekNumber', requireScheduleSectionAccess, async (req, res) => {
  const courseId = Number(req.params.courseId);
  const weekNumber = Number(req.params.weekNumber);
  const { use_local_time } = req.body || {};
  if (Number.isNaN(courseId) || courseId < 1 || Number.isNaN(weekNumber) || weekNumber < 1) {
    return res.status(400).json({ error: 'Invalid input' });
  }
  if (hasSessionRole(req, 'deanery') && !hasSessionRole(req, 'admin') && Number(req.session.user.course_id) !== courseId) {
    return res.status(403).json({ error: 'Forbidden' });
  }
  try {
    const course = await db.get('SELECT id FROM courses WHERE id = ?', [courseId]);
    if (!course) return res.status(404).json({ error: 'Course not found' });
    const semester = await getActiveSemester(courseId);
    if (!semester || !semester.id) {
      return res.status(400).json({ error: 'No active semester' });
    }
    const totalWeeks = Number(semester.weeks_count || 0);
    if (!totalWeeks || weekNumber > totalWeeks) {
      return res.status(400).json({ error: 'Invalid week' });
    }
    const now = new Date().toISOString();
    await db.run(
      `INSERT INTO course_week_time_modes (course_id, semester_id, week_number, use_local_time, created_at, updated_at)
       VALUES (?, ?, ?, ?, ?, ?)
       ON CONFLICT (course_id, semester_id, week_number)
       DO UPDATE SET use_local_time = EXCLUDED.use_local_time, updated_at = EXCLUDED.updated_at`,
      [courseId, semester.id, weekNumber, use_local_time ? 1 : 0, now, now]
    );
    invalidateWeekTimeCache();
    return res.json({ ok: true });
  } catch (err) {
    return res.status(500).json({ error: 'Database error' });
  }
});

app.post('/admin/api/homework/bulk', requireHomeworkSectionAccess, writeLimiter, async (req, res) => {
  const { ids, action, payload } = req.body || {};
  const list = Array.isArray(ids) ? ids.map((id) => Number(id)).filter((id) => Number.isFinite(id)) : [];
  if (!list.length || !action) {
    return res.status(400).json({ error: 'Invalid input' });
  }
  const courseId = hasSessionRole(req, 'admin') ? getAdminCourse(req) : (req.session.user.course_id || 1);
  let activeSemester = null;
  try {
    activeSemester = await getActiveSemester(courseId);
  } catch (err) {
    return res.status(500).json({ error: 'Semester error' });
  }
  const placeholders = list.map(() => '?').join(',');
  const scoped = await db.all(
    `SELECT id, day_of_week, class_date, custom_due_date, week_number FROM homework
     WHERE id IN (${placeholders}) AND course_id = ? AND semester_id = ?`,
    [...list, courseId, activeSemester ? activeSemester.id : null]
  );
  const scopedIds = scoped.map((row) => row.id);
  if (!scopedIds.length) {
    return res.status(404).json({ error: 'No items found' });
  }
  const scopedPlaceholders = scopedIds.map(() => '?').join(',');

  try {
    if (action === 'add_tags' || action === 'remove_tags') {
      const tagNames = Array.isArray(payload?.tags) ? payload.tags.map((t) => String(t).trim()).filter(Boolean) : [];
      if (!tagNames.length) return res.status(400).json({ error: 'No tags' });
      const tagIds = [];
      for (const name of tagNames) {
        const row = await db.get(
          'INSERT INTO homework_tags (name) VALUES (?) ON CONFLICT (name) DO UPDATE SET name = EXCLUDED.name RETURNING id',
          [name]
        );
        if (row && row.id) tagIds.push(row.id);
      }
      if (action === 'add_tags') {
        for (const hwId of scopedIds) {
          for (const tagId of tagIds) {
            await db.run(
              'INSERT INTO homework_tag_map (homework_id, tag_id) VALUES (?, ?) ON CONFLICT DO NOTHING',
              [hwId, tagId]
            );
          }
        }
      } else {
        const tagPlaceholders = tagIds.map(() => '?').join(',');
        await db.run(
          `DELETE FROM homework_tag_map WHERE homework_id IN (${scopedPlaceholders}) AND tag_id IN (${tagPlaceholders})`,
          [...scopedIds, ...tagIds]
        );
      }
      return res.json({ ok: true });
    }

    if (action === 'set_deadline') {
      const deadline = payload?.deadline ? String(payload.deadline).slice(0, 10) : '';
      if (!deadline) return res.status(400).json({ error: 'Invalid deadline' });
      await db.run(
        `UPDATE homework SET custom_due_date = ?, is_custom_deadline = 1 WHERE id IN (${scopedPlaceholders})`,
        [deadline, ...scopedIds]
      );
      return res.json({ ok: true });
    }

    if (action === 'shift_deadline') {
      const daysShift = Number(payload?.days || 0);
      if (!Number.isFinite(daysShift) || daysShift === 0) {
        return res.status(400).json({ error: 'Invalid shift' });
      }
      for (const row of scoped) {
        const base = row.custom_due_date || row.class_date;
        if (!base) continue;
        const d = new Date(`${base}T00:00:00Z`);
        d.setUTCDate(d.getUTCDate() + daysShift);
        const newDate = d.toISOString().slice(0, 10);
        await db.run('UPDATE homework SET custom_due_date = ?, is_custom_deadline = 1 WHERE id = ?', [newDate, row.id]);
      }
      return res.json({ ok: true });
    }

    if (action === 'move_to_week') {
      const targetWeek = Number(payload?.week || 0);
      if (!Number.isFinite(targetWeek) || targetWeek < 1) {
        return res.status(400).json({ error: 'Invalid week' });
      }
      for (const row of scoped) {
        if (!row.day_of_week) continue;
        const newDate = getDateForWeekDay(targetWeek, row.day_of_week, activeSemester ? activeSemester.start_date : null);
        await db.run(
          'UPDATE homework SET class_date = ?, week_number = ?, custom_due_date = NULL, is_custom_deadline = 0 WHERE id = ?',
          [newDate, targetWeek, row.id]
        );
      }
      return res.json({ ok: true });
    }

    if (action === 'delete') {
      await db.run(`DELETE FROM homework WHERE id IN (${scopedPlaceholders})`, scopedIds);
      return res.json({ ok: true });
    }

    if (action === 'export_csv') {
      const rows = await db.all(
        `SELECT h.id, h.description, h.group_number, h.custom_due_date, h.class_date, h.created_by, h.created_at,
                s.name AS subject_name
         FROM homework h
         LEFT JOIN subjects s ON s.id = h.subject_id
         WHERE h.id IN (${scopedPlaceholders})
         ORDER BY h.id`,
        scopedIds
      );
      const header = ['id','title','subject','group','deadline','is_weird','created_by','created_at'];
      const csv = [header.join(',')];
      rows.forEach((r) => {
        const deadline = r.custom_due_date || r.class_date || '';
        const isWeird = r.custom_due_date && r.custom_due_date !== r.class_date ? '1' : '0';
        const line = [
          r.id,
          r.description || '',
          r.subject_name || '',
          r.group_number || '',
          deadline,
          isWeird,
          r.created_by || '',
          r.created_at || '',
        ].map((v) => escapeCsvValue(v)).join(',');
        csv.push(line);
      });
      res.setHeader('Content-Type', 'text/csv; charset=utf-8');
      res.setHeader('Content-Disposition', 'attachment; filename=\"homework_export.csv\"');
      return res.send(csv.join('\n'));
    }

    return res.status(400).json({ error: 'Unknown action' });
  } catch (err) {
    return res.status(500).json({ error: 'Database error' });
  }
});

app.get('/admin/api/schedule/validate', requireScheduleSectionAccess, async (req, res) => {
  const courseId = getStaffCourse(req);
  let activeSemester = null;
  try {
    activeSemester = await getActiveSemester(courseId);
  } catch (err) {
    return res.status(500).json({ error: 'Semester error' });
  }
  const week = req.query.week ? Number(req.query.week) : null;
  if (req.query.week && (Number.isNaN(week) || week < 1)) {
    return res.status(400).json({ error: 'Invalid week' });
  }
  const filters = ['se.course_id = ?', 'se.semester_id = ?'];
  const params = [courseId, activeSemester ? activeSemester.id : null];
  if (week) {
    filters.push('se.week_number = ?');
    params.push(week);
  }
  const where = `WHERE ${filters.join(' AND ')}`;
  try {
    const studyDays = await getCourseStudyDays(courseId);
    const activeDaySet = new Set(
      (studyDays || []).filter((d) => d.is_active).map((d) => d.day_name)
    );
    const subjects = await getSubjectsCached(courseId);
    const subjectMap = new Map((subjects || []).map((s) => [s.id, { id: s.id, name: s.name, group_count: s.group_count }]));
    const rows = await db.all(
      `SELECT se.*
       FROM schedule_entries se
       ${where}`,
      params
    );

    const issues = [];
    const collisionMap = new Map();
    (rows || []).forEach((row) => {
      const key = `${row.week_number}|${row.day_of_week}|${row.class_number}|${row.group_number}`;
      if (!collisionMap.has(key)) collisionMap.set(key, []);
      collisionMap.get(key).push(row);

      if (!Number.isFinite(Number(row.class_number)) || row.class_number < 1 || row.class_number > 7) {
        issues.push({
          type: 'invalid_class_number',
          severity: 'error',
          message: 'Невірний номер пари',
          context: {
            week: row.week_number,
            day_of_week: row.day_of_week,
            class_number: row.class_number,
            group: row.group_number,
            schedule_ids: [row.id],
          },
          fix_url: `/admin?course=${courseId}&day=${encodeURIComponent(row.day_of_week)}&group_number=${row.group_number}`,
        });
      }

      if (activeDaySet.size && !activeDaySet.has(row.day_of_week)) {
        issues.push({
          type: 'day_disabled',
          severity: 'warning',
          message: 'Пара на вимкнений день',
          context: {
            week: row.week_number,
            day_of_week: row.day_of_week,
            class_number: row.class_number,
            group: row.group_number,
            schedule_ids: [row.id],
          },
          fix_url: `/admin?course=${courseId}&day=${encodeURIComponent(row.day_of_week)}&group_number=${row.group_number}`,
        });
      }

      const subject = subjectMap.get(row.subject_id);
      if (subject && subject.group_count && row.group_number > subject.group_count) {
        issues.push({
          type: 'subject_group_missing',
          severity: 'warning',
          message: 'Група не відповідає предмету',
          context: {
            week: row.week_number,
            day_of_week: row.day_of_week,
            class_number: row.class_number,
            group: row.group_number,
            schedule_ids: [row.id],
          },
          fix_url: `/admin?course=${courseId}&day=${encodeURIComponent(row.day_of_week)}&group_number=${row.group_number}`,
        });
      }
    });

    collisionMap.forEach((list, key) => {
      if (list.length > 1) {
        const sample = list[0];
        issues.push({
          type: 'collision',
          severity: 'error',
          message: 'Конфлікт пар в одному слоті',
          context: {
            week: sample.week_number,
            day_of_week: sample.day_of_week,
            class_number: sample.class_number,
            group: sample.group_number,
            schedule_ids: list.map((r) => r.id),
          },
          fix_url: `/admin?course=${courseId}&day=${encodeURIComponent(sample.day_of_week)}&group_number=${sample.group_number}`,
        });
      }
    });

    const summary = {
      errors: issues.filter((i) => i.severity === 'error').length,
      warnings: issues.filter((i) => i.severity === 'warning').length,
    };
    return res.json({ issues, summary });
  } catch (err) {
    return res.status(500).json({ error: 'Database error' });
  }
});

app.post('/admin/semesters/add', requireSemestersSectionAccess, (req, res) => {
  const { title, start_date, weeks_count, is_active } = req.body;
  const courseId = getAdminCourse(req);
  const weeks = Number(weeks_count);
  const active = String(is_active) === '1' ? 1 : 0;
  if (!title || !start_date || Number.isNaN(weeks) || weeks < 1 || weeks > 30) {
    return res.redirect('/admin?err=Invalid%20semester');
  }
  const create = () => {
    db.run(
      'INSERT INTO semesters (course_id, title, start_date, weeks_count, is_active, is_archived) VALUES (?, ?, ?, ?, ?, 0)',
      [courseId, title.trim(), start_date, weeks, active],
      (err) => {
        if (err) {
          return res.redirect('/admin?err=Database%20error');
        }
        logAction(db, req, 'semester_add', { title, start_date, weeks_count: weeks, is_active: active });
        invalidateSemestersCache(courseId);
        return res.redirect('/admin?ok=Semester%20created');
      }
    );
  };
  if (active) {
    db.run('UPDATE semesters SET is_active = 0 WHERE course_id = ?', [courseId], (err) => {
      if (err) {
        return res.redirect('/admin?err=Database%20error');
      }
      create();
    });
  } else {
    create();
  }
});

app.post('/admin/semesters/edit/:id', requireSemestersSectionAccess, (req, res) => {
  const { id } = req.params;
  const { title, start_date, weeks_count } = req.body;
  const courseId = getAdminCourse(req);
  const weeks = Number(weeks_count);
  if (!title || !start_date || Number.isNaN(weeks) || weeks < 1 || weeks > 30) {
    return res.redirect('/admin?err=Invalid%20semester');
  }
  db.run(
    'UPDATE semesters SET title = ?, start_date = ?, weeks_count = ? WHERE id = ? AND course_id = ?',
    [title.trim(), start_date, weeks, id, courseId],
    (err) => {
    if (err) {
      return res.redirect('/admin?err=Database%20error');
    }
    logAction(db, req, 'semester_edit', { id, title, start_date, weeks_count: weeks });
    invalidateSemestersCache(courseId);
    return res.redirect('/admin?ok=Semester%20updated');
  }
);
});

app.post('/admin/semesters/set-active/:id', requireSemestersSectionAccess, (req, res) => {
  const { id } = req.params;
  const courseId = getAdminCourse(req);
  db.run('UPDATE semesters SET is_active = 0 WHERE course_id = ?', [courseId], (err) => {
    if (err) {
      return res.redirect('/admin?err=Database%20error');
    }
    db.run('UPDATE semesters SET is_active = 1, is_archived = 0 WHERE id = ? AND course_id = ?', [id, courseId], (err2) => {
      if (err2) {
        return res.redirect('/admin?err=Database%20error');
      }
      logAction(db, req, 'semester_set_active', { id });
      invalidateSemestersCache(courseId);
      return res.redirect('/admin?ok=Semester%20activated');
    });
  });
});

app.post('/admin/semesters/archive/:id', requireSemestersSectionAccess, (req, res) => {
  const { id } = req.params;
  const courseId = getAdminCourse(req);
  db.run('UPDATE semesters SET is_archived = 1, is_active = 0 WHERE id = ? AND course_id = ?', [id, courseId], (err) => {
    if (err) {
      return res.redirect('/admin?err=Database%20error');
    }
    logAction(db, req, 'semester_archive', { id });
    invalidateSemestersCache(courseId);
    return res.redirect('/admin?ok=Semester%20archived');
  });
});

app.post('/admin/semesters/finalize/:id', requireSemestersSectionAccess, async (req, res) => {
  const semesterId = Number(req.params.id);
  const courseId = getAdminCourse(req);
  if (!Number.isFinite(semesterId) || semesterId < 1) {
    return res.redirect('/admin?err=Invalid%20semester');
  }
  if (!isStepUpPhraseValid(req.body.confirm_phrase || req.body.stepup_code, STEPUP_CODE_FINALIZE)) {
    return res.redirect('/admin?err=Type%20FINALIZE%20to%20confirm');
  }

  try {
    const semester = await db.get(
      `
        SELECT id, title, start_date, weeks_count, is_active, is_archived
        FROM semesters
        WHERE id = ? AND course_id = ?
        LIMIT 1
      `,
      [semesterId, courseId]
    );
    if (!semester) {
      return res.redirect('/admin?err=Semester%20not%20found');
    }

    const archiveSnapshot = await buildSemesterJournalArchiveSnapshot({
      courseId,
      semester,
      actorUserId: Number(req.session.user.id),
    });

    await withTransaction(async (client) => {
      const query = (sql, params = []) => client.query(convertPlaceholders(sql), params);
      await query(
        `
          UPDATE semesters
          SET is_archived = 1,
              is_active = 0
          WHERE id = ?
            AND course_id = ?
        `,
        [semesterId, courseId]
      );
      await query(
        `
          UPDATE journal_columns
          SET is_locked = 1,
              locked_by = ?,
              locked_at = COALESCE(locked_at, NOW()),
              updated_at = NOW()
          WHERE course_id = ?
            AND semester_id = ?
            AND COALESCE(is_archived, 0) = 0
        `,
        [Number(req.session.user.id), courseId, semesterId]
      );
    });

    logAction(db, req, 'semester_finalize', {
      id: semesterId,
      archive_summary_file: archiveSnapshot.summary_file?.filePath || null,
      archive_manifest_file: archiveSnapshot.manifest_file?.filePath || null,
      subjects_count: Number(archiveSnapshot.subjects_count || 0),
      students_rows_count: Number(archiveSnapshot.students_rows_count || 0),
      generated_at: archiveSnapshot.generated_at || null,
    });
    logActivity(
      db,
      req,
      'semester_finalize',
      'semester',
      semesterId,
      {
        archive_summary_file: archiveSnapshot.summary_file?.filePath || null,
        archive_manifest_file: archiveSnapshot.manifest_file?.filePath || null,
        subjects_count: Number(archiveSnapshot.subjects_count || 0),
        students_rows_count: Number(archiveSnapshot.students_rows_count || 0),
      },
      courseId,
      semesterId
    );
    invalidateSemestersCache(courseId);
    return res.redirect(
      `/admin?ok=${encodeURIComponent(`Semester finalized: archived + journals locked + backup generated (${Number(archiveSnapshot.subjects_count || 0)} subjects)`)}`
    );
  } catch (err) {
    return handleDbError(res, err, 'admin.semesters.finalize');
  }
});

app.get('/admin/semesters/archive-export/:id', requireSemestersSectionAccess, async (req, res) => {
  const semesterId = Number(req.params.id);
  const courseId = getAdminCourse(req);
  if (!Number.isFinite(semesterId) || semesterId < 1) {
    return res.redirect('/admin?err=Invalid%20semester');
  }

  try {
    const semester = await db.get(
      `
        SELECT id
        FROM semesters
        WHERE id = ? AND course_id = ?
        LIMIT 1
      `,
      [semesterId, courseId]
    );
    if (!semester) {
      return res.redirect('/admin?err=Semester%20not%20found');
    }

    const archiveDir = path.join(
      uploadsDir,
      SEMESTER_ARCHIVE_UPLOADS_DIR,
      `course-${courseId}`,
      `semester-${semesterId}`
    );
    const latestSummaryFileName = `semester-${semesterId}-archive-summary-latest.csv`;
    const absolutePath = path.join(archiveDir, latestSummaryFileName);
    if (!fs.existsSync(absolutePath)) {
      return res.redirect('/admin?err=Archive%20summary%20not%20found');
    }
    return res.download(absolutePath, latestSummaryFileName);
  } catch (err) {
    return handleDbError(res, err, 'admin.semesters.archiveExport');
  }
});

app.post('/admin/semesters/restore/:id', requireSemestersSectionAccess, (req, res) => {
  const { id } = req.params;
  const courseId = getAdminCourse(req);
  db.run('UPDATE semesters SET is_archived = 0 WHERE id = ? AND course_id = ?', [id, courseId], (err) => {
    if (err) {
      return res.redirect('/admin?err=Database%20error');
    }
    logAction(db, req, 'semester_restore', { id });
    invalidateSemestersCache(courseId);
    return res.redirect('/admin?ok=Semester%20restored');
  });
});

app.post('/admin/semesters/delete/:id', requireSemestersSectionAccess, (req, res) => {
  const { id } = req.params;
  const courseId = getAdminCourse(req);
  db.get('SELECT is_active FROM semesters WHERE id = ? AND course_id = ?', [id, courseId], (semErr, semRow) => {
    if (semErr || !semRow) {
      return res.redirect('/admin?err=Semester%20not%20found');
    }
    if (semRow.is_active === 1) {
      return res.redirect('/admin?err=Cannot%20delete%20active%20semester');
    }
    db.get('SELECT COUNT(*) AS cnt FROM schedule_entries WHERE semester_id = ?', [id], (cntErr, cntRow) => {
      if (cntErr) {
        return res.redirect('/admin?err=Database%20error');
      }
      if (Number(cntRow.cnt) > 0) {
        return res.redirect('/admin?err=Semester%20in%20use');
      }
      db.run('DELETE FROM semesters WHERE id = ? AND course_id = ?', [id, courseId], (err) => {
        if (err) {
          return res.redirect('/admin?err=Database%20error');
        }
        logAction(db, req, 'semester_delete', { id });
        invalidateSemestersCache(courseId);
        return res.redirect('/admin?ok=Semester%20deleted');
      });
    });
  });
});

app.post('/admin/semesters/hard-delete/:id', requireSemestersSectionAccess, async (req, res) => {
  const semesterId = Number(req.params.id);
  const courseId = getAdminCourse(req);
  if (!Number.isFinite(semesterId) || semesterId <= 0) {
    return res.redirect('/admin?err=Invalid%20semester');
  }
  try {
    const semRow = await db.get('SELECT id, is_active FROM semesters WHERE id = ? AND course_id = ?', [semesterId, courseId]);
    if (!semRow) {
      return res.redirect('/admin?err=Semester%20not%20found');
    }
    if (Number(semRow.is_active) === 1) {
      await db.run('UPDATE semesters SET is_active = 0 WHERE id = ? AND course_id = ?', [semesterId, courseId]);
    }

    await db.run('DELETE FROM schedule_entries WHERE semester_id = ?', [semesterId]);
    await db.run('DELETE FROM homework WHERE semester_id = ?', [semesterId]);
    await db.run('DELETE FROM teamwork_tasks WHERE semester_id = ?', [semesterId]);
    await db.run('DELETE FROM messages WHERE semester_id = ?', [semesterId]);
    await db.run('DELETE FROM personal_reminders WHERE semester_id = ?', [semesterId]);
    await db.run('DELETE FROM activity_log WHERE semester_id = ?', [semesterId]);
    await db.run('DELETE FROM course_week_time_modes WHERE semester_id = ?', [semesterId]);
    await db.run('DELETE FROM schedule_generator_items WHERE semester_id = ?', [semesterId]);
    await db.run('DELETE FROM schedule_generator_entries WHERE semester_id = ?', [semesterId]);

    await db.run('DELETE FROM semesters WHERE id = ? AND course_id = ?', [semesterId, courseId]);
    logAction(db, req, 'semester_hard_delete', { id: semesterId });
    invalidateSemestersCache(courseId);
    return res.redirect('/admin?ok=Semester%20hard%20deleted');
  } catch (err) {
    return handleDbError(res, err, 'admin.semesters.hardDelete');
  }
});

app.post('/admin/student-groups/set', requireUsersSectionAccess, (req, res) => {
  const { student_id, subject_id, group_number } = req.body;
  const groupNum = Number(group_number);
  const courseId = getAdminCourse(req);
  if (!student_id || !subject_id || Number.isNaN(groupNum)) {
    return res.redirect('/admin?err=Invalid%20group%20assignment');
  }
  db.get('SELECT group_count FROM subjects WHERE id = ? AND course_id = ?', [subject_id, courseId], (err, subject) => {
    if (err || !subject) {
      return res.redirect('/admin?err=Database%20error');
    }
    if (groupNum < 1 || groupNum > subject.group_count) {
      return res.redirect('/admin?err=Group%20out%20of%20range');
    }
    db.run(
      `
        INSERT INTO student_groups (student_id, subject_id, group_number)
        VALUES (?, ?, ?)
        ON CONFLICT(student_id, subject_id)
        DO UPDATE SET group_number = excluded.group_number
      `,
      [student_id, subject_id, groupNum],
      (setErr) => {
        if (setErr) {
          return res.redirect('/admin?err=Database%20error');
        }
        logAction(db, req, 'student_group_set', { student_id, subject_id, group_number: groupNum });
        logActivity(db, req, 'group_set', 'student_group', null, { student_id, subject_id, group_number: groupNum }, courseId);
        broadcast('users_updated');
        return res.redirect('/admin?ok=Group%20updated');
      }
    );
  });
});

app.post('/admin/group/remove', requireUsersSectionAccess, (req, res) => {
  const { student_id, subject_id } = req.body;
  if (!student_id || !subject_id) {
    return res.redirect('/admin?err=Invalid%20remove%20request');
  }
  db.run(
    'DELETE FROM student_groups WHERE student_id = ? AND subject_id = ?',
    [student_id, subject_id],
    (err) => {
    if (err) {
      return res.redirect('/admin?err=Database%20error');
    }
    logAction(db, req, 'student_group_remove', { student_id, subject_id });
    logActivity(db, req, 'group_remove', 'student_group', null, { student_id, subject_id }, getAdminCourse(req));
    broadcast('users_updated');
    return res.redirect('/admin?ok=Subject%20removed');
  }
  );
});

app.post('/admin/students/groups/set', requireUsersOrStudentsSectionAccess, (req, res) => {
  const { student_id, subject_id, group_number } = req.body;
  const groupNum = Number(group_number);
  const courseId = getAdminCourse(req);
  if (!student_id || !subject_id || Number.isNaN(groupNum)) {
    return res.redirect('/admin?tab=admin-students&err=Invalid%20group%20assignment');
  }
  db.get(
    'SELECT id, role FROM users WHERE id = ? AND course_id = ?',
    [student_id, courseId],
    (userErr, user) => {
      if (userErr || !user) {
        return res.redirect('/admin?tab=admin-students&err=User%20not%20found');
      }
      if (canManageStudentOnlyScope(req) && !isStudentLikeLegacyRole(user.role)) {
        return res.redirect('/admin?tab=admin-students&err=Forbidden%20student%20scope');
      }
      db.get(
        'SELECT group_count FROM subjects WHERE id = ? AND course_id = ?',
        [subject_id, courseId],
        (err, subject) => {
          if (err || !subject) {
            return res.redirect('/admin?tab=admin-students&err=Database%20error');
          }
          if (groupNum < 1 || groupNum > subject.group_count) {
            return res.redirect('/admin?tab=admin-students&err=Group%20out%20of%20range');
          }
          db.run(
            `
              INSERT INTO student_groups (student_id, subject_id, group_number)
              VALUES (?, ?, ?)
              ON CONFLICT(student_id, subject_id)
              DO UPDATE SET group_number = excluded.group_number
            `,
            [student_id, subject_id, groupNum],
            (setErr) => {
              if (setErr) {
                return res.redirect('/admin?tab=admin-students&err=Database%20error');
              }
              logAction(db, req, 'student_group_set', { student_id, subject_id, group_number: groupNum });
              logActivity(
                db,
                req,
                'group_set',
                'student_group',
                null,
                { student_id, subject_id, group_number: groupNum, scope: 'students' },
                courseId
              );
              broadcast('users_updated');
              return res.redirect('/admin?tab=admin-students&ok=Group%20updated');
            }
          );
        }
      );
    }
  );
});

app.post('/admin/students/group/remove', requireUsersOrStudentsSectionAccess, (req, res) => {
  const { student_id, subject_id } = req.body;
  const courseId = getAdminCourse(req);
  if (!student_id || !subject_id) {
    return res.redirect('/admin?tab=admin-students&err=Invalid%20remove%20request');
  }
  db.get(
    'SELECT id, role FROM users WHERE id = ? AND course_id = ?',
    [student_id, courseId],
    (userErr, user) => {
      if (userErr || !user) {
        return res.redirect('/admin?tab=admin-students&err=User%20not%20found');
      }
      if (canManageStudentOnlyScope(req) && !isStudentLikeLegacyRole(user.role)) {
        return res.redirect('/admin?tab=admin-students&err=Forbidden%20student%20scope');
      }
      db.run(
        'DELETE FROM student_groups WHERE student_id = ? AND subject_id = ?',
        [student_id, subject_id],
        (err) => {
          if (err) {
            return res.redirect('/admin?tab=admin-students&err=Database%20error');
          }
          logAction(db, req, 'student_group_remove', { student_id, subject_id });
          logActivity(
            db,
            req,
            'group_remove',
            'student_group',
            null,
            { student_id, subject_id, scope: 'students' },
            courseId
          );
          broadcast('users_updated');
          return res.redirect('/admin?tab=admin-students&ok=Subject%20removed');
        }
      );
    }
  );
});

app.post('/admin/students/deactivate', requireUsersOrStudentsSectionAccess, (req, res) => {
  const { user_id } = req.body;
  const courseId = getAdminCourse(req);
  const userId = Number(user_id);
  if (!Number.isFinite(userId)) {
    return res.redirect('/admin?tab=admin-students&err=Invalid%20user');
  }
  db.get(
    'SELECT id, role, full_name FROM users WHERE id = ? AND course_id = ?',
    [userId, courseId],
    (err, user) => {
      if (err || !user) {
        return res.redirect('/admin?tab=admin-students&err=User%20not%20found');
      }
      if (normalizeRoleKey(user.role) === 'admin') {
        return res.redirect('/admin?tab=admin-students&err=Cannot%20deactivate%20admin');
      }
      if (canManageStudentOnlyScope(req) && !isStudentLikeLegacyRole(user.role)) {
        return res.redirect('/admin?tab=admin-students&err=Forbidden%20student%20scope');
      }
      db.run('UPDATE users SET is_active = 0 WHERE id = ?', [userId], (updErr) => {
        if (updErr) {
          return res.redirect('/admin?tab=admin-students&err=Database%20error');
        }
        logAction(db, req, 'student_deactivate', { user_id: userId, full_name: user.full_name });
        broadcast('users_updated');
        return res.redirect('/admin?tab=admin-students&ok=Student%20deactivated');
      });
    }
  );
});

app.post('/admin/students/activate', requireUsersOrStudentsSectionAccess, (req, res) => {
  const { user_id } = req.body;
  const courseId = getAdminCourse(req);
  const userId = Number(user_id);
  if (!Number.isFinite(userId)) {
    return res.redirect('/admin?tab=admin-students&err=Invalid%20user');
  }
  db.get(
    'SELECT id, role FROM users WHERE id = ? AND course_id = ?',
    [userId, courseId],
    (err, user) => {
      if (err || !user) {
        return res.redirect('/admin?tab=admin-students&err=User%20not%20found');
      }
      if (canManageStudentOnlyScope(req) && !isStudentLikeLegacyRole(user.role)) {
        return res.redirect('/admin?tab=admin-students&err=Forbidden%20student%20scope');
      }
      db.run('UPDATE users SET is_active = 1 WHERE id = ?', [userId], (updErr) => {
        if (updErr) {
          return res.redirect('/admin?tab=admin-students&err=Database%20error');
        }
        logAction(db, req, 'student_activate', { user_id: userId });
        broadcast('users_updated');
        return res.redirect('/admin?tab=admin-students&ok=Student%20restored');
      });
    }
  );
});

app.get('/admin/users/:id/roles.json', requireRoleAccessSectionAccess, async (req, res) => {
  const userId = Number(req.params.id);
  if (!Number.isFinite(userId) || userId < 1) {
    return res.status(400).json({ error: 'Invalid user' });
  }
  try {
    await ensureDbReady();
  } catch (err) {
    return res.status(500).json({ error: 'Database error' });
  }
  const courseId = getAdminCourse(req);
  try {
    const userRow = await db.get('SELECT id, role FROM users WHERE id = ? AND course_id = ?', [userId, courseId]);
    if (!userRow) {
      return res.status(404).json({ error: 'User not found' });
    }
    const [roles, assignment] = await Promise.all([
      getRbacRolesDetailed(),
      getUserRoleAssignmentsForUserIds([userId]),
    ]);
    const roleKeys = assignment.roleKeysByUser[userId] || [normalizeRoleKey(userRow.role || 'student')];
    const primaryRole = assignment.primaryRoleByUser[userId] || normalizeRoleKey(userRow.role || roleKeys[0] || 'student');
    return res.json({
      user_id: userId,
      role_keys: roleKeys,
      primary_role: primaryRole,
      roles,
    });
  } catch (err) {
    return res.status(500).json({ error: 'Database error' });
  }
});

app.post('/admin/users/roles', requireRoleAccessSectionAccess, async (req, res) => {
  const userId = Number(req.body.user_id);
  const courseId = getAdminCourse(req);
  const selectedRoles = normalizeRoleList(
    Array.isArray(req.body.role_keys) ? req.body.role_keys : (req.body.role_keys ? [req.body.role_keys] : [])
  );
  if (!Number.isFinite(userId) || userId < 1 || !selectedRoles.length) {
    return res.redirect('/admin?err=Invalid%20role%20selection');
  }
  if (!isStepUpPhraseValid(req.body.stepup_code, STEPUP_CODE_ROLE)) {
    return res.redirect('/admin?err=Type%20ROLE%20to%20confirm');
  }
  try {
    await ensureDbReady();
    const user = await db.get('SELECT id, role, full_name FROM users WHERE id = ? AND course_id = ?', [userId, courseId]);
    if (!user) {
      return res.redirect('/admin?err=User%20not%20found');
    }
    if (Number(userId) === Number(req.session.user.id) && !selectedRoles.includes('admin')) {
      return res.redirect('/admin?err=Cannot%20remove%20your%20own%20admin%20role');
    }
    const beforeSnapshot = await getUserRoleSnapshot(userId, user.role || 'student');
    const preferredPrimary = req.body.primary_role || user.role || 'student';
    const result = await assignUserRoles(userId, selectedRoles, { preferredPrimary });
    await recordUserRoleChangeEvent({
      userId,
      actorUserId: Number(req.session.user.id),
      actorName: req.session.user.username,
      courseId,
      source: 'admin_users_roles',
      reason: 'Role Studio update',
      beforeRoles: beforeSnapshot.role_keys,
      afterRoles: result.roleKeys,
      beforePrimaryRole: beforeSnapshot.primary_role,
      afterPrimaryRole: result.primaryRoleKey,
      targetFullName: user.full_name || null,
    });
    await recomputeUserSecurityCase(userId, { courseId, allowAutoQuarantine: false });
    logAction(db, req, 'user_roles_change', { user_id: userId, role_keys: result.roleKeys, primary_role: result.primaryRoleKey });
    broadcast('users_updated');
    return res.redirect('/admin?ok=Roles%20updated');
  } catch (err) {
    if (String(err.message || '').includes('At least one admin required')) {
      return res.redirect('/admin?err=At%20least%20one%20admin%20required');
    }
    if (String(err.message || '').includes('Invalid role')) {
      return res.redirect('/admin?err=Invalid%20role%20selection');
    }
    return res.redirect('/admin?err=Database%20error');
  }
});

app.post('/admin/users/role', requireRoleAccessSectionAccess, async (req, res) => {
  const { user_id, role } = req.body;
  const roleKey = normalizeRoleKey(role);
  if (!user_id || !roleKey || !['student', 'admin', 'starosta', 'deanery', 'teacher'].includes(roleKey)) {
    return res.redirect('/admin?err=Invalid%20role');
  }
  if (!isStepUpPhraseValid(req.body.stepup_code, STEPUP_CODE_ROLE)) {
    return res.redirect('/admin?err=Type%20ROLE%20to%20confirm');
  }
  const userId = Number(user_id);
  const courseId = getAdminCourse(req);
  if (!Number.isFinite(userId) || userId < 1) {
    return res.redirect('/admin?err=Invalid%20role');
  }
  if (userId === Number(req.session.user.id)) {
    return res.redirect('/admin?err=Cannot%20change%20your%20own%20role');
  }
  try {
    await ensureDbReady();
    const user = await db.get('SELECT id, role, full_name FROM users WHERE id = ? AND course_id = ?', [userId, courseId]);
    if (!user) {
      return res.redirect('/admin?err=User%20not%20found');
    }
    const beforeSnapshot = await getUserRoleSnapshot(userId, user.role || 'student');
    await assignUserRoles(userId, [roleKey], { preferredPrimary: roleKey });
    await recordUserRoleChangeEvent({
      userId,
      actorUserId: Number(req.session.user.id),
      actorName: req.session.user.username,
      courseId,
      source: 'admin_users_role',
      reason: 'Legacy role update',
      beforeRoles: beforeSnapshot.role_keys,
      afterRoles: [roleKey],
      beforePrimaryRole: beforeSnapshot.primary_role,
      afterPrimaryRole: roleKey,
      targetFullName: user.full_name || null,
    });
    await recomputeUserSecurityCase(userId, { courseId, allowAutoQuarantine: false });
    logAction(db, req, 'user_role_change', { user_id: userId, role: roleKey });
    broadcast('users_updated');
    return res.redirect('/admin?ok=Role%20updated');
  } catch (err) {
    if (String(err.message || '').includes('At least one admin required')) {
      return res.redirect('/admin?err=At%20least%20one%20admin%20required');
    }
    return res.redirect('/admin?err=Database%20error');
  }
});

app.post('/admin/rbac/roles/create', requireRoleAccessSectionAccess, async (req, res) => {
  const key = String(req.body.key || '').trim().toLowerCase();
  const label = String(req.body.label || '').trim();
  const description = String(req.body.description || '').trim();
  const cloneFrom = String(req.body.clone_from || '').trim().toLowerCase();
  if (!/^[a-z][a-z0-9_-]{1,31}$/.test(key) || !label) {
    return res.redirect('/admin?err=Invalid%20role%20data');
  }
  try {
    await ensureDbReady();
    const courseId = getAdminCourse(req);
    const client = await pool.connect();
    try {
      await client.query('BEGIN');
      const inserted = await client.query(
        `
          INSERT INTO access_roles (key, label, description, is_system, is_active, created_at, updated_at)
          VALUES ($1, $2, $3, false, true, NOW(), NOW())
          RETURNING id
        `,
        [key, label, description]
      );
      const roleId = Number(inserted.rows[0].id);
      if (cloneFrom) {
        await client.query(
          `
            INSERT INTO access_role_permissions (role_id, permission_id, allowed, created_at, updated_at)
            SELECT $1, rp.permission_id, rp.allowed, NOW(), NOW()
            FROM access_role_permissions rp
            JOIN access_roles src ON src.id = rp.role_id
            WHERE src.key = $2
            ON CONFLICT (role_id, permission_id) DO NOTHING
          `,
          [roleId, cloneFrom]
        );
        await client.query(
          `
            INSERT INTO access_role_course_access (role_id, course_kind, allowed, created_at, updated_at)
            SELECT $1, rca.course_kind, rca.allowed, NOW(), NOW()
            FROM access_role_course_access rca
            JOIN access_roles src ON src.id = rca.role_id
            WHERE src.key = $2
            ON CONFLICT (role_id, course_kind) DO NOTHING
          `,
          [roleId, cloneFrom]
        );
      } else {
        await client.query(
          `
            INSERT INTO access_role_course_access (role_id, course_kind, allowed, created_at, updated_at)
            VALUES ($1, 'regular', true, NOW(), NOW())
            ON CONFLICT (role_id, course_kind) DO NOTHING
          `,
          [roleId]
        );
      }
      await client.query('COMMIT');
      const afterState = await getRbacRoleStateByKey(key);
      const operationId = randomUUID();
      await createAdminAuditEntry(req, {
        scopeKey: ADMIN_AUDIT_SCOPE_ROLE_STUDIO,
        targetType: 'rbac_role',
        targetKey: key,
        summary: `Role created: ${key}`,
        beforeState: null,
        afterState,
        operationId,
        courseId,
      });
      logAction(db, req, 'rbac_role_create', { key, label, clone_from: cloneFrom || null });
      broadcast('users_updated');
      return res.redirect(`/admin?tab=admin-role-studio&ok=Role%20created&op=${operationId}`);
    } catch (err) {
      try {
        await client.query('ROLLBACK');
      } catch (_) {
        // ignore rollback error when transaction is already committed
      }
      if (err && err.code === '23505') {
        return res.redirect('/admin?err=Role%20key%20already%20exists');
      }
      return res.redirect('/admin?err=Database%20error');
    } finally {
      client.release();
    }
  } catch (err) {
    return res.redirect('/admin?err=Database%20error');
  }
});

app.post('/admin/rbac/roles/:key/save', requireRoleAccessSectionAccess, async (req, res) => {
  const roleKey = String(req.params.key || '').trim().toLowerCase();
  if (!roleKey) {
    return res.redirect('/admin?err=Invalid%20role');
  }
  const label = String(req.body.label || '').trim();
  const description = String(req.body.description || '').trim();
  const selectedPermissions = normalizeRoleList(
    Array.isArray(req.body.permission_keys)
      ? req.body.permission_keys
      : (req.body.permission_keys ? [req.body.permission_keys] : [])
  );
  const selectedCourseKinds = Array.from(
    new Set(
      (Array.isArray(req.body.course_kinds) ? req.body.course_kinds : (req.body.course_kinds ? [req.body.course_kinds] : []))
        .map((kind) => String(kind))
        .filter((kind) => kind === 'regular' || kind === 'teacher')
    )
  );
  if (!label) {
    return res.redirect('/admin?err=Role%20label%20required');
  }
  try {
    await ensureDbReady();
    const courseId = getAdminCourse(req);
    const beforeState = await getRbacRoleStateByKey(roleKey);
    const roleRow = await db.get('SELECT id, key, is_system FROM access_roles WHERE key = ?', [roleKey]);
    if (!roleRow) {
      return res.redirect('/admin?err=Role%20not%20found');
    }
    const requestedActive = String(req.body.is_active || '').toLowerCase();
    let isActive = requestedActive === '1' || requestedActive === 'true' || requestedActive === 'on';
    if (roleRow.key === 'admin') isActive = true;
    const courseKinds = selectedCourseKinds.length
      ? selectedCourseKinds
      : (roleRow.key === 'admin' ? ['regular', 'teacher'] : ['regular']);
    const permissionRows = await db.all(
      "SELECT key FROM access_permissions WHERE category IN ('admin_section', 'feature')"
    );
    const validPermissions = new Set((permissionRows || []).map((row) => String(row.key)));
    const permissionKeys = selectedPermissions.filter((key) => validPermissions.has(key));
    const client = await pool.connect();
    try {
      await client.query('BEGIN');
      await client.query(
        `
          UPDATE access_roles
          SET label = $1,
              description = $2,
              is_active = $3,
              updated_at = NOW()
          WHERE id = $4
        `,
        [label, description, isActive, roleRow.id]
      );
      await client.query('DELETE FROM access_role_permissions WHERE role_id = $1', [roleRow.id]);
      if (permissionKeys.length) {
        await client.query(
          `
            INSERT INTO access_role_permissions (role_id, permission_id, allowed, created_at, updated_at)
            SELECT $1, p.id, true, NOW(), NOW()
            FROM access_permissions p
            WHERE p.key = ANY($2::text[])
            ON CONFLICT (role_id, permission_id) DO NOTHING
          `,
          [roleRow.id, permissionKeys]
        );
      }
      await client.query('DELETE FROM access_role_course_access WHERE role_id = $1', [roleRow.id]);
      await client.query(
        `
          INSERT INTO access_role_course_access (role_id, course_kind, allowed, created_at, updated_at)
          SELECT $1, kind.kind, true, NOW(), NOW()
          FROM (SELECT UNNEST($2::text[]) AS kind) kind
          ON CONFLICT (role_id, course_kind) DO NOTHING
        `,
        [roleRow.id, courseKinds]
      );
      await client.query('COMMIT');
      const afterState = await getRbacRoleStateByKey(roleRow.key);
      const operationId = randomUUID();
      await createAdminAuditEntry(req, {
        scopeKey: ADMIN_AUDIT_SCOPE_ROLE_STUDIO,
        targetType: 'rbac_role',
        targetKey: roleRow.key,
        summary: `Role updated: ${roleRow.key}`,
        beforeState,
        afterState,
        operationId,
        courseId,
      });
      logAction(db, req, 'rbac_role_update', {
        key: roleRow.key,
        label,
        is_active: isActive,
        permission_keys: permissionKeys,
        course_kinds: courseKinds,
      });
      broadcast('users_updated');
      return res.redirect(`/admin?tab=admin-role-studio&ok=Role%20updated&op=${operationId}`);
    } catch (err) {
      try {
        await client.query('ROLLBACK');
      } catch (_) {
        // ignore rollback error when transaction is already committed
      }
      return res.redirect('/admin?err=Database%20error');
    } finally {
      client.release();
    }
  } catch (err) {
    return res.redirect('/admin?err=Database%20error');
  }
});

app.post('/admin/rbac/roles/:key/delete', requireRoleAccessSectionAccess, async (req, res) => {
  const roleKey = String(req.params.key || '').trim().toLowerCase();
  if (!roleKey) {
    return res.redirect('/admin?err=Invalid%20role');
  }
  try {
    await ensureDbReady();
    const courseId = getAdminCourse(req);
    const beforeState = await getRbacRoleStateByKey(roleKey);
    const roleRow = await db.get('SELECT id, key, is_system FROM access_roles WHERE key = ?', [roleKey]);
    if (!roleRow) {
      return res.redirect('/admin?err=Role%20not%20found');
    }
    if (roleRow.is_system === true || Number(roleRow.is_system) === 1) {
      return res.redirect('/admin?err=Cannot%20delete%20system%20role');
    }
    const usageRow = await db.get('SELECT COUNT(*) AS count FROM user_roles WHERE role_id = ?', [roleRow.id]);
    if (Number(usageRow?.count || 0) > 0) {
      return res.redirect('/admin?err=Role%20is%20assigned%20to%20users');
    }
    await db.run('DELETE FROM access_roles WHERE id = ?', [roleRow.id]);
    const operationId = randomUUID();
    await createAdminAuditEntry(req, {
      scopeKey: ADMIN_AUDIT_SCOPE_ROLE_STUDIO,
      targetType: 'rbac_role',
      targetKey: roleRow.key,
      summary: `Role deleted: ${roleRow.key}`,
      beforeState,
      afterState: null,
      operationId,
      courseId,
    });
    logAction(db, req, 'rbac_role_delete', { key: roleRow.key });
    broadcast('users_updated');
    return res.redirect(`/admin?tab=admin-role-studio&ok=Role%20deleted&op=${operationId}`);
  } catch (err) {
    return res.redirect('/admin?err=Database%20error');
  }
});

app.post('/admin/users/course', requireUsersSectionAccess, (req, res) => {
  const { user_id, course_id } = req.body;
  const userId = Number(user_id);
  const courseId = Number(course_id);
  const currentCourse = getAdminCourse(req);
  if (Number.isNaN(userId) || Number.isNaN(courseId)) {
    return res.redirect('/admin?err=Invalid%20course');
  }
  db.get('SELECT id FROM courses WHERE id = ?', [courseId], (courseErr, courseRow) => {
    if (courseErr || !courseRow) {
      return res.redirect('/admin?err=Invalid%20course');
    }
    db.get('SELECT role FROM users WHERE id = ? AND course_id = ?', [userId, currentCourse], (err, user) => {
      if (err || !user) {
        return res.redirect('/admin?err=User%20not%20found');
      }
      if (user.role === 'admin') {
        return res.redirect('/admin?err=Cannot%20change%20admin%20course');
      }
      db.run('UPDATE users SET course_id = ? WHERE id = ?', [courseId, userId], (updErr) => {
        if (updErr) {
          return res.redirect('/admin?err=Database%20error');
        }
        logAction(db, req, 'user_course_change', { user_id: userId, course_id: courseId });
        broadcast('users_updated');
        return res.redirect(`/admin?course=${currentCourse}&ok=Course%20updated`);
      });
    });
  });
});

app.post('/admin/users/reset-password', requireUsersSectionAccess, (req, res) => {
  const { user_id, new_password } = req.body;
  if (!user_id || !new_password) {
    return res.redirect('/admin?err=Password%20required');
  }
  if (new_password.length < 4) {
    return res.redirect('/admin?err=Password%20too%20short');
  }
  const hash = bcrypt.hashSync(new_password, 10);
  db.run(
    'UPDATE users SET password_hash = ? WHERE id = ?',
    [hash, user_id],
    (err) => {
      if (err) {
        return res.redirect('/admin?err=Database%20error');
      }
      logAction(db, req, 'user_password_reset', { user_id });
      broadcast('users_updated');
      return res.redirect('/admin?ok=Password%20updated');
    }
  );
});

app.post('/admin/homework/migrate', requireHomeworkSectionAccess, (req, res) => {
  const timeToClass = (time) => {
    if (!time) return null;
    const start = time.split('-')[0].trim();
    const match = Object.entries(bellSchedule).find(([, slot]) => slot.start === start);
    return match ? Number(match[0]) : null;
  };

  db.all(
    `
      SELECT id, subject, day, time, subject_id, group_number, day_of_week, class_number
      FROM homework
      WHERE subject_id IS NULL OR group_number IS NULL OR day_of_week IS NULL OR class_number IS NULL
    `,
    (err, rows) => {
      if (err) {
        return res.redirect('/admin?err=Database%20error');
      }
      if (!rows.length) {
        return res.redirect('/admin?ok=Nothing%20to%20migrate');
      }
      db.all('SELECT id, name FROM subjects', (sErr, subjects) => {
        if (sErr) {
          return res.redirect('/admin?err=Database%20error');
        }
        const subjectMap = new Map(subjects.map((s) => [s.name, s.id]));
        const stmt = db.prepare(
          `
            UPDATE homework
            SET subject_id = COALESCE(subject_id, ?),
                group_number = COALESCE(group_number, ?),
                day_of_week = COALESCE(day_of_week, ?),
                class_number = COALESCE(class_number, ?)
            WHERE id = ?
          `
        );
        rows.forEach((row) => {
          const subjectId = subjectMap.get(row.subject) || row.subject_id;
          const classNum = row.class_number || timeToClass(row.time);
          const day = row.day_of_week || row.day;
          stmt.run(subjectId || null, 1, day || null, classNum || null, row.id);
        });
        stmt.finalize(() => {
          logAction(db, req, 'homework_migrate', { count: rows.length });
          return res.redirect('/admin?ok=Homework%20migrated');
        });
      });
    }
  );
});

app.post('/admin/users/delete-multiple', requireUsersSectionAccess, (req, res) => {
  const ids = req.body.delete_user_ids;
  const courseId = getAdminCourse(req);
  if (!ids) {
    return res.redirect('/admin?err=No%20users%20selected');
  }
  const list = Array.isArray(ids) ? ids : [ids];
  const placeholders = list.map(() => '?').join(',');
  db.all(
    `SELECT id, role FROM users WHERE course_id = ? AND id IN (${placeholders})`,
    [courseId, ...list],
    (err, rows) => {
      if (err) {
        return res.redirect('/admin?err=Database%20error');
      }
      const deleteIds = rows.filter((u) => u.role !== 'admin').map((u) => u.id);
      if (!deleteIds.length) {
        return res.redirect('/admin?err=No%20students%20to%20delete');
      }
      const delPlaceholders = deleteIds.map(() => '?').join(',');
      db.run(`UPDATE users SET is_active = 0 WHERE id IN (${delPlaceholders})`, deleteIds, (delErr) => {
        if (delErr) {
          return res.redirect('/admin?err=Database%20error');
        }
        logAction(db, req, 'users_deactivate_multiple', { ids: deleteIds });
        broadcast('users_updated');
        return res.redirect('/admin?ok=Users%20deactivated');
      });
    }
  );
});

app.post('/admin/users/clear-all', requireUsersSectionAccess, (req, res) => {
  const courseId = getAdminCourse(req);
  db.all('SELECT id FROM users WHERE role != ? AND course_id = ?', ['admin', courseId], (err, rows) => {
    if (err) {
      return res.redirect('/admin?err=Database%20error');
    }
    const ids = rows.map((r) => r.id);
    if (!ids.length) {
      return res.redirect('/admin?err=No%20students%20to%20delete');
    }
    const placeholders = ids.map(() => '?').join(',');
    db.run(`UPDATE users SET is_active = 0 WHERE id IN (${placeholders})`, ids, (delErr) => {
      if (delErr) {
        return res.redirect('/admin?err=Database%20error');
      }
      logAction(db, req, 'users_deactivate_all', { ids });
      broadcast('users_updated');
      return res.redirect('/admin?ok=All%20students%20deactivated');
    });
  });
});

app.post('/admin/users/deactivate', requireUsersSectionAccess, (req, res) => {
  const { user_id } = req.body;
  const courseId = getAdminCourse(req);
  if (!user_id) {
    return res.status(400).json({ error: 'Missing user_id' });
  }
  db.get('SELECT role, full_name FROM users WHERE id = ? AND course_id = ?', [user_id, courseId], (err, user) => {
    if (err || !user) {
      return res.status(404).json({ error: 'User not found' });
    }
    if (user.role === 'admin') {
      return res.status(400).json({ error: 'Cannot deactivate admin' });
    }
    db.run('UPDATE users SET is_active = 0 WHERE id = ?', [user_id], (updErr) => {
      if (updErr) {
        return res.status(500).json({ error: 'Database error' });
      }
      logAction(db, req, 'user_deactivate', { user_id, full_name: user.full_name });
      broadcast('users_updated');
      return res.json({ ok: true });
    });
  });
});

app.post('/admin/users/activate', requireUsersSectionAccess, (req, res) => {
  const { user_id } = req.body;
  const courseId = getAdminCourse(req);
  if (!user_id) {
    return res.status(400).json({ error: 'Missing user_id' });
  }
  db.run('UPDATE users SET is_active = 1 WHERE id = ? AND course_id = ?', [user_id, courseId], (updErr) => {
    if (updErr) {
      return res.status(500).json({ error: 'Database error' });
    }
    logAction(db, req, 'user_activate', { user_id });
    broadcast('users_updated');
    return res.json({ ok: true });
  });
});

app.post('/admin/users/delete-permanent', requireUsersSectionAccess, async (req, res) => {
  const { user_id } = req.body;
  const userId = Number(user_id);
  const courseId = getAdminCourse(req);
  if (Number.isNaN(userId)) {
    return res.redirect('/admin?err=Invalid%20user');
  }
  try {
    const user = await db.get('SELECT role FROM users WHERE id = ? AND course_id = ?', [userId, courseId]);
    if (!user) {
      return res.redirect('/admin?err=User%20not%20found');
    }
    if (user.role === 'admin') {
      return res.redirect('/admin?err=Cannot%20delete%20admin');
    }
    await db.run('DELETE FROM student_groups WHERE student_id = ?', [userId]);
    await db.run('DELETE FROM login_history WHERE user_id = ?', [userId]);
    await db.run('DELETE FROM message_reads WHERE user_id = ?', [userId]);
    await db.run('DELETE FROM message_targets WHERE user_id = ?', [userId]);
    await db.run('DELETE FROM teamwork_members WHERE user_id = ?', [userId]);
    await db.run('UPDATE homework SET created_by_id = NULL WHERE created_by_id = ?', [userId]);
    await db.run('UPDATE messages SET created_by_id = ? WHERE created_by_id = ?', [req.session.user.id, userId]);
    await db.run('UPDATE teamwork_tasks SET created_by = ? WHERE created_by = ?', [req.session.user.id, userId]);
    await db.run('UPDATE teamwork_groups SET leader_id = ? WHERE leader_id = ?', [req.session.user.id, userId]);
    await db.run('DELETE FROM users WHERE id = ?', [userId]);
    logAction(db, req, 'user_delete_permanent', { user_id: userId });
    broadcast('users_updated');
    return res.redirect('/admin?ok=User%20deleted');
  } catch (err) {
    return res.redirect('/admin?err=Database%20error');
  }
});

app.post('/admin/switch-to-student', requireAdmin, async (req, res) => {
  const mode = req.body.mode === 'self' ? 'self' : 'manual';
  let courseId = Number(req.body.course_id || req.body.course);
  let groupNumber = Number(req.body.group_number);
  if (!Number.isFinite(groupNumber) || groupNumber < 1 || groupNumber > 3) {
    groupNumber = 1;
  }
  if (mode === 'self') {
    courseId = Number(req.session.user.course_id || 1);
  }
  try {
    const courses = await getCoursesCached();
    const match = (courses || []).find((c) => Number(c.id) === Number(courseId));
    if (!match) {
      courseId = getAdminCourse(req);
    }
  } catch (err) {
    courseId = getAdminCourse(req);
  }
  if (!Number.isFinite(courseId)) {
    courseId = getAdminCourse(req);
  }
  req.session.viewAs = 'student';
  req.session.viewAsMode = mode;
  req.session.viewAsCourseId = courseId;
  req.session.viewAsGroupNumber = mode === 'self' ? null : groupNumber;
  return res.redirect('/schedule');
});

app.post('/admin/switch-to-admin', requireAdmin, (req, res) => {
  req.session.viewAs = null;
  req.session.viewAsMode = null;
  req.session.viewAsCourseId = null;
  req.session.viewAsGroupNumber = null;
  return res.redirect('/admin');
});

app.post('/logout', (req, res) => {
  req.session.destroy(() => {
    res.redirect('/login');
  });
});

const startScheduler = () => {
  const intervalMs = (typeof schedulerIntervalMs === 'number' && Number.isFinite(schedulerIntervalMs))
    ? schedulerIntervalMs
    : resolveSchedulerIntervalMs();
  schedulerHealthState.interval_ms = intervalMs;
  if (!Number.isFinite(intervalMs) || intervalMs < 10000) {
    schedulerHealthState.enabled = false;
    return;
  }
  schedulerHealthState.enabled = true;
  clearRuntimeErrorEvents((event) => (
    String(event && event.message ? event.message : '').toLowerCase().includes('schedulerintervalms is not defined')
  ));
  setInterval(() => {
    if (typeof publishScheduledItems !== 'function') {
      return;
    }
    publishScheduledItems().catch((err) => {
      console.error('Scheduler error', err);
    });
  }, intervalMs);
};

const startSessionHealthProbes = () => {
  const runProbe = (reason) =>
    probeSessionStoreHealth(reason).catch((err) => {
      const message = normalizeSessionHealthError(err && err.message ? err.message : err);
      console.error('Session health probe crashed', message);
      sessionHealthState.ok = false;
      sessionHealthState.lastError = message;
      sessionHealthState.lastErrorAt = new Date().toISOString();
      sessionHealthState.failures += 1;
      pushRuntimeErrorEvent('session', `probe_crashed:${reason}`, message);
      logSessionHealth('probe_crashed', { reason, error: message });
    });

  logSessionHealth('probe_scheduler_started', {
    interval_seconds: sessionHealthProbeIntervalSeconds,
    table: sessionTableName,
  });
  runProbe('startup');
  setInterval(() => {
    runProbe('interval');
  }, sessionHealthProbeIntervalMs);
};

const startServer = () => {
  console.log('Starting server', {
    port: PORT,
    node: process.version,
    env: process.env.NODE_ENV || 'unknown',
  });
  server.listen(PORT, '0.0.0.0', () => console.log(`Listening on ${PORT}`));
  ensureDbReady().catch((err) => {
    console.error('Failed to initialize database', err);
  });
  startSessionHealthProbes();
  startScheduler();
};

app.use((err, req, res, next) => {
  pushRuntimeErrorEvent('unhandled', 'express_middleware', err && err.message ? err.message : err);
  console.error('Unhandled error', err);
  const wantsJson = String(req.get && req.get('accept') ? req.get('accept') : '').toLowerCase().includes('application/json')
    || String(req.headers && req.headers.accept ? req.headers.accept : '').toLowerCase().includes('application/json');
  if (wantsJson) {
    if (process.env.DB_DEBUG === 'true') {
      return res.status(500).json({
        error: err && err.message ? String(err.message) : 'Internal Server Error',
        details: err && err.stack ? String(err.stack) : String(err),
      });
    }
    return res.status(500).json({ error: 'Internal Server Error' });
  }
  if (process.env.DB_DEBUG === 'true') {
    return res.status(500).send(err && err.stack ? err.stack : String(err));
  }
  return res.status(500).send('Internal Server Error');
});

startServer();
